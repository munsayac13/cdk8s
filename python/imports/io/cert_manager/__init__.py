from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

from ._jsii import *

import cdk8s as _cdk8s_d3d9af27
import constructs as _constructs_77d1e7e8


class Certificate(
    _cdk8s_d3d9af27.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="iocert-manager.Certificate",
):
    '''A Certificate resource should be created to ensure an up to date and signed X.509 certificate is stored in the Kubernetes Secret resource named in ``spec.secretName``.

    The stored certificate will be renewed before it expires (as configured by ``spec.renewBefore``).

    :schema: Certificate
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["CertificateSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "Certificate" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param metadata: 
        :param spec: Specification of the desired state of the Certificate resource. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83eb4f4530b52ea6853e7191f39bd5a69bc44c12fc79ff4293d5c610eaab4318)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CertificateProps(metadata=metadata, spec=spec)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["CertificateSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "Certificate".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param metadata: 
        :param spec: Specification of the desired state of the Certificate resource. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        '''
        props = CertificateProps(metadata=metadata, spec=spec)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> _cdk8s_d3d9af27.GroupVersionKind:
        '''Returns the apiVersion and kind for "Certificate".'''
        return typing.cast(_cdk8s_d3d9af27.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="iocert-manager.CertificateProps",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class CertificateProps:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["CertificateSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''A Certificate resource should be created to ensure an up to date and signed X.509 certificate is stored in the Kubernetes Secret resource named in ``spec.secretName``.

        The stored certificate will be renewed before it expires (as configured by ``spec.renewBefore``).

        :param metadata: 
        :param spec: Specification of the desired state of the Certificate resource. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status

        :schema: Certificate
        '''
        if isinstance(metadata, dict):
            metadata = _cdk8s_d3d9af27.ApiObjectMetadata(**metadata)
        if isinstance(spec, dict):
            spec = CertificateSpec(**spec)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45dc788c1d2b0c9f9222a2fa306cf217f2020644af3fa92be5fa925ad20fa0c3)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata]:
        '''
        :schema: Certificate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata], result)

    @builtins.property
    def spec(self) -> typing.Optional["CertificateSpec"]:
        '''Specification of the desired state of the Certificate resource.

        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status

        :schema: Certificate#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["CertificateSpec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CertificateRequest(
    _cdk8s_d3d9af27.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="iocert-manager.CertificateRequest",
):
    '''A CertificateRequest is used to request a signed certificate from one of the configured issuers.

    All fields within the CertificateRequest's ``spec`` are immutable after creation.
    A CertificateRequest will either succeed or fail, as denoted by its ``Ready`` status
    condition and its ``status.failureTime`` field.

    A CertificateRequest is a one-shot resource, meaning it represents a single
    point in time request for a certificate and cannot be re-used.

    :schema: CertificateRequest
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["CertificateRequestSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "CertificateRequest" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param metadata: 
        :param spec: Specification of the desired state of the CertificateRequest resource. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__85bad730ae89d75454fbc0817d7d071091cfa8f7250fd3c08b7acacddb415e25)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CertificateRequestProps(metadata=metadata, spec=spec)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["CertificateRequestSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "CertificateRequest".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param metadata: 
        :param spec: Specification of the desired state of the CertificateRequest resource. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        '''
        props = CertificateRequestProps(metadata=metadata, spec=spec)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> _cdk8s_d3d9af27.GroupVersionKind:
        '''Returns the apiVersion and kind for "CertificateRequest".'''
        return typing.cast(_cdk8s_d3d9af27.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="iocert-manager.CertificateRequestProps",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class CertificateRequestProps:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["CertificateRequestSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''A CertificateRequest is used to request a signed certificate from one of the configured issuers.

        All fields within the CertificateRequest's ``spec`` are immutable after creation.
        A CertificateRequest will either succeed or fail, as denoted by its ``Ready`` status
        condition and its ``status.failureTime`` field.

        A CertificateRequest is a one-shot resource, meaning it represents a single
        point in time request for a certificate and cannot be re-used.

        :param metadata: 
        :param spec: Specification of the desired state of the CertificateRequest resource. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status

        :schema: CertificateRequest
        '''
        if isinstance(metadata, dict):
            metadata = _cdk8s_d3d9af27.ApiObjectMetadata(**metadata)
        if isinstance(spec, dict):
            spec = CertificateRequestSpec(**spec)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c9252068788769c92948b7c5a29fa8e75a833c80c13e459f19af04e9476a3ad)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata]:
        '''
        :schema: CertificateRequest#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata], result)

    @builtins.property
    def spec(self) -> typing.Optional["CertificateRequestSpec"]:
        '''Specification of the desired state of the CertificateRequest resource.

        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status

        :schema: CertificateRequest#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["CertificateRequestSpec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateRequestProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.CertificateRequestSpec",
    jsii_struct_bases=[],
    name_mapping={
        "issuer_ref": "issuerRef",
        "request": "request",
        "duration": "duration",
        "extra": "extra",
        "groups": "groups",
        "is_ca": "isCa",
        "uid": "uid",
        "usages": "usages",
        "username": "username",
    },
)
class CertificateRequestSpec:
    def __init__(
        self,
        *,
        issuer_ref: typing.Union["CertificateRequestSpecIssuerRef", typing.Dict[builtins.str, typing.Any]],
        request: builtins.str,
        duration: typing.Optional[builtins.str] = None,
        extra: typing.Optional[typing.Mapping[builtins.str, typing.Sequence[builtins.str]]] = None,
        groups: typing.Optional[typing.Sequence[builtins.str]] = None,
        is_ca: typing.Optional[builtins.bool] = None,
        uid: typing.Optional[builtins.str] = None,
        usages: typing.Optional[typing.Sequence["CertificateRequestSpecUsages"]] = None,
        username: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Specification of the desired state of the CertificateRequest resource.

        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status

        :param issuer_ref: Reference to the issuer responsible for issuing the certificate. If the issuer is namespace-scoped, it must be in the same namespace as the Certificate. If the issuer is cluster-scoped, it can be used from any namespace. The ``name`` field of the reference must always be specified.
        :param request: The PEM-encoded X.509 certificate signing request to be submitted to the issuer for signing. If the CSR has a BasicConstraints extension, its isCA attribute must match the ``isCA`` value of this CertificateRequest. If the CSR has a KeyUsage extension, its key usages must match the key usages in the ``usages`` field of this CertificateRequest. If the CSR has a ExtKeyUsage extension, its extended key usages must match the extended key usages in the ``usages`` field of this CertificateRequest.
        :param duration: Requested 'duration' (i.e. lifetime) of the Certificate. Note that the issuer may choose to ignore the requested duration, just like any other requested attribute.
        :param extra: Extra contains extra attributes of the user that created the CertificateRequest. Populated by the cert-manager webhook on creation and immutable.
        :param groups: Groups contains group membership of the user that created the CertificateRequest. Populated by the cert-manager webhook on creation and immutable.
        :param is_ca: Requested basic constraints isCA value. Note that the issuer may choose to ignore the requested isCA value, just like any other requested attribute. NOTE: If the CSR in the ``Request`` field has a BasicConstraints extension, it must have the same isCA value as specified here. If true, this will automatically add the ``cert sign`` usage to the list of requested ``usages``.
        :param uid: UID contains the uid of the user that created the CertificateRequest. Populated by the cert-manager webhook on creation and immutable.
        :param usages: Requested key usages and extended key usages. NOTE: If the CSR in the ``Request`` field has uses the KeyUsage or ExtKeyUsage extension, these extensions must have the same values as specified here without any additional values. If unset, defaults to ``digital signature`` and ``key encipherment``.
        :param username: Username contains the name of the user that created the CertificateRequest. Populated by the cert-manager webhook on creation and immutable.

        :schema: CertificateRequestSpec
        '''
        if isinstance(issuer_ref, dict):
            issuer_ref = CertificateRequestSpecIssuerRef(**issuer_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__852c3e842d58b913717e1498bc2afc1f9e926550814236cafdf93d20eedcbcf7)
            check_type(argname="argument issuer_ref", value=issuer_ref, expected_type=type_hints["issuer_ref"])
            check_type(argname="argument request", value=request, expected_type=type_hints["request"])
            check_type(argname="argument duration", value=duration, expected_type=type_hints["duration"])
            check_type(argname="argument extra", value=extra, expected_type=type_hints["extra"])
            check_type(argname="argument groups", value=groups, expected_type=type_hints["groups"])
            check_type(argname="argument is_ca", value=is_ca, expected_type=type_hints["is_ca"])
            check_type(argname="argument uid", value=uid, expected_type=type_hints["uid"])
            check_type(argname="argument usages", value=usages, expected_type=type_hints["usages"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "issuer_ref": issuer_ref,
            "request": request,
        }
        if duration is not None:
            self._values["duration"] = duration
        if extra is not None:
            self._values["extra"] = extra
        if groups is not None:
            self._values["groups"] = groups
        if is_ca is not None:
            self._values["is_ca"] = is_ca
        if uid is not None:
            self._values["uid"] = uid
        if usages is not None:
            self._values["usages"] = usages
        if username is not None:
            self._values["username"] = username

    @builtins.property
    def issuer_ref(self) -> "CertificateRequestSpecIssuerRef":
        '''Reference to the issuer responsible for issuing the certificate.

        If the issuer is namespace-scoped, it must be in the same namespace
        as the Certificate. If the issuer is cluster-scoped, it can be used
        from any namespace.

        The ``name`` field of the reference must always be specified.

        :schema: CertificateRequestSpec#issuerRef
        '''
        result = self._values.get("issuer_ref")
        assert result is not None, "Required property 'issuer_ref' is missing"
        return typing.cast("CertificateRequestSpecIssuerRef", result)

    @builtins.property
    def request(self) -> builtins.str:
        '''The PEM-encoded X.509 certificate signing request to be submitted to the issuer for signing.

        If the CSR has a BasicConstraints extension, its isCA attribute must
        match the ``isCA`` value of this CertificateRequest.
        If the CSR has a KeyUsage extension, its key usages must match the
        key usages in the ``usages`` field of this CertificateRequest.
        If the CSR has a ExtKeyUsage extension, its extended key usages
        must match the extended key usages in the ``usages`` field of this
        CertificateRequest.

        :schema: CertificateRequestSpec#request
        '''
        result = self._values.get("request")
        assert result is not None, "Required property 'request' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def duration(self) -> typing.Optional[builtins.str]:
        '''Requested 'duration' (i.e. lifetime) of the Certificate. Note that the issuer may choose to ignore the requested duration, just like any other requested attribute.

        :schema: CertificateRequestSpec#duration
        '''
        result = self._values.get("duration")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def extra(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.List[builtins.str]]]:
        '''Extra contains extra attributes of the user that created the CertificateRequest.

        Populated by the cert-manager webhook on creation and immutable.

        :schema: CertificateRequestSpec#extra
        '''
        result = self._values.get("extra")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.List[builtins.str]]], result)

    @builtins.property
    def groups(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Groups contains group membership of the user that created the CertificateRequest.

        Populated by the cert-manager webhook on creation and immutable.

        :schema: CertificateRequestSpec#groups
        '''
        result = self._values.get("groups")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def is_ca(self) -> typing.Optional[builtins.bool]:
        '''Requested basic constraints isCA value.

        Note that the issuer may choose
        to ignore the requested isCA value, just like any other requested attribute.

        NOTE: If the CSR in the ``Request`` field has a BasicConstraints extension,
        it must have the same isCA value as specified here.

        If true, this will automatically add the ``cert sign`` usage to the list
        of requested ``usages``.

        :schema: CertificateRequestSpec#isCA
        '''
        result = self._values.get("is_ca")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def uid(self) -> typing.Optional[builtins.str]:
        '''UID contains the uid of the user that created the CertificateRequest.

        Populated by the cert-manager webhook on creation and immutable.

        :schema: CertificateRequestSpec#uid
        '''
        result = self._values.get("uid")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def usages(self) -> typing.Optional[typing.List["CertificateRequestSpecUsages"]]:
        '''Requested key usages and extended key usages.

        NOTE: If the CSR in the ``Request`` field has uses the KeyUsage or
        ExtKeyUsage extension, these extensions must have the same values
        as specified here without any additional values.

        If unset, defaults to ``digital signature`` and ``key encipherment``.

        :schema: CertificateRequestSpec#usages
        '''
        result = self._values.get("usages")
        return typing.cast(typing.Optional[typing.List["CertificateRequestSpecUsages"]], result)

    @builtins.property
    def username(self) -> typing.Optional[builtins.str]:
        '''Username contains the name of the user that created the CertificateRequest.

        Populated by the cert-manager webhook on creation and immutable.

        :schema: CertificateRequestSpec#username
        '''
        result = self._values.get("username")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateRequestSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.CertificateRequestSpecIssuerRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "group": "group", "kind": "kind"},
)
class CertificateRequestSpecIssuerRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        group: typing.Optional[builtins.str] = None,
        kind: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to the issuer responsible for issuing the certificate.

        If the issuer is namespace-scoped, it must be in the same namespace
        as the Certificate. If the issuer is cluster-scoped, it can be used
        from any namespace.

        The ``name`` field of the reference must always be specified.

        :param name: Name of the resource being referred to.
        :param group: Group of the resource being referred to.
        :param kind: Kind of the resource being referred to.

        :schema: CertificateRequestSpecIssuerRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9a9d227c2e96d30d52fa91c7d0c2454b38e3f73b481889c1995bca89d98a081f)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument group", value=group, expected_type=type_hints["group"])
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if group is not None:
            self._values["group"] = group
        if kind is not None:
            self._values["kind"] = kind

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        :schema: CertificateRequestSpecIssuerRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group(self) -> typing.Optional[builtins.str]:
        '''Group of the resource being referred to.

        :schema: CertificateRequestSpecIssuerRef#group
        '''
        result = self._values.get("group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        '''Kind of the resource being referred to.

        :schema: CertificateRequestSpecIssuerRef#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateRequestSpecIssuerRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="iocert-manager.CertificateRequestSpecUsages")
class CertificateRequestSpecUsages(enum.Enum):
    '''KeyUsage specifies valid usage contexts for keys. See: https://tools.ietf.org/html/rfc5280#section-4.2.1.3 https://tools.ietf.org/html/rfc5280#section-4.2.1.12.

    Valid KeyUsage values are as follows:
    "signing",
    "digital signature",
    "content commitment",
    "key encipherment",
    "key agreement",
    "data encipherment",
    "cert sign",
    "crl sign",
    "encipher only",
    "decipher only",
    "any",
    "server auth",
    "client auth",
    "code signing",
    "email protection",
    "s/mime",
    "ipsec end system",
    "ipsec tunnel",
    "ipsec user",
    "timestamping",
    "ocsp signing",
    "microsoft sgc",
    "netscape sgc"

    :schema: CertificateRequestSpecUsages
    '''

    SIGNING = "SIGNING"
    '''signing.'''
    DIGITAL_SIGNATURE = "DIGITAL_SIGNATURE"
    '''digital signature.'''
    CONTENT_COMMITMENT = "CONTENT_COMMITMENT"
    '''content commitment.'''
    KEY_ENCIPHERMENT = "KEY_ENCIPHERMENT"
    '''key encipherment.'''
    KEY_AGREEMENT = "KEY_AGREEMENT"
    '''key agreement.'''
    DATA_ENCIPHERMENT = "DATA_ENCIPHERMENT"
    '''data encipherment.'''
    CERT_SIGN = "CERT_SIGN"
    '''cert sign.'''
    CRL_SIGN = "CRL_SIGN"
    '''crl sign.'''
    ENCIPHER_ONLY = "ENCIPHER_ONLY"
    '''encipher only.'''
    DECIPHER_ONLY = "DECIPHER_ONLY"
    '''decipher only.'''
    ANY = "ANY"
    '''any.'''
    SERVER_AUTH = "SERVER_AUTH"
    '''server auth.'''
    CLIENT_AUTH = "CLIENT_AUTH"
    '''client auth.'''
    CODE_SIGNING = "CODE_SIGNING"
    '''code signing.'''
    EMAIL_PROTECTION = "EMAIL_PROTECTION"
    '''email protection.'''
    S_FORWARD_SLASH_MIME = "S_FORWARD_SLASH_MIME"
    '''s/mime.'''
    IPSEC_END_SYSTEM = "IPSEC_END_SYSTEM"
    '''ipsec end system.'''
    IPSEC_TUNNEL = "IPSEC_TUNNEL"
    '''ipsec tunnel.'''
    IPSEC_USER = "IPSEC_USER"
    '''ipsec user.'''
    TIMESTAMPING = "TIMESTAMPING"
    '''timestamping.'''
    OCSP_SIGNING = "OCSP_SIGNING"
    '''ocsp signing.'''
    MICROSOFT_SGC = "MICROSOFT_SGC"
    '''microsoft sgc.'''
    NETSCAPE_SGC = "NETSCAPE_SGC"
    '''netscape sgc.'''


@jsii.data_type(
    jsii_type="iocert-manager.CertificateSpec",
    jsii_struct_bases=[],
    name_mapping={
        "issuer_ref": "issuerRef",
        "secret_name": "secretName",
        "additional_output_formats": "additionalOutputFormats",
        "common_name": "commonName",
        "dns_names": "dnsNames",
        "duration": "duration",
        "email_addresses": "emailAddresses",
        "encode_usages_in_request": "encodeUsagesInRequest",
        "ip_addresses": "ipAddresses",
        "is_ca": "isCa",
        "keystores": "keystores",
        "literal_subject": "literalSubject",
        "name_constraints": "nameConstraints",
        "other_names": "otherNames",
        "private_key": "privateKey",
        "renew_before": "renewBefore",
        "renew_before_percentage": "renewBeforePercentage",
        "revision_history_limit": "revisionHistoryLimit",
        "secret_template": "secretTemplate",
        "subject": "subject",
        "uris": "uris",
        "usages": "usages",
    },
)
class CertificateSpec:
    def __init__(
        self,
        *,
        issuer_ref: typing.Union["CertificateSpecIssuerRef", typing.Dict[builtins.str, typing.Any]],
        secret_name: builtins.str,
        additional_output_formats: typing.Optional[typing.Sequence[typing.Union["CertificateSpecAdditionalOutputFormats", typing.Dict[builtins.str, typing.Any]]]] = None,
        common_name: typing.Optional[builtins.str] = None,
        dns_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        duration: typing.Optional[builtins.str] = None,
        email_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
        encode_usages_in_request: typing.Optional[builtins.bool] = None,
        ip_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
        is_ca: typing.Optional[builtins.bool] = None,
        keystores: typing.Optional[typing.Union["CertificateSpecKeystores", typing.Dict[builtins.str, typing.Any]]] = None,
        literal_subject: typing.Optional[builtins.str] = None,
        name_constraints: typing.Optional[typing.Union["CertificateSpecNameConstraints", typing.Dict[builtins.str, typing.Any]]] = None,
        other_names: typing.Optional[typing.Sequence[typing.Union["CertificateSpecOtherNames", typing.Dict[builtins.str, typing.Any]]]] = None,
        private_key: typing.Optional[typing.Union["CertificateSpecPrivateKey", typing.Dict[builtins.str, typing.Any]]] = None,
        renew_before: typing.Optional[builtins.str] = None,
        renew_before_percentage: typing.Optional[jsii.Number] = None,
        revision_history_limit: typing.Optional[jsii.Number] = None,
        secret_template: typing.Optional[typing.Union["CertificateSpecSecretTemplate", typing.Dict[builtins.str, typing.Any]]] = None,
        subject: typing.Optional[typing.Union["CertificateSpecSubject", typing.Dict[builtins.str, typing.Any]]] = None,
        uris: typing.Optional[typing.Sequence[builtins.str]] = None,
        usages: typing.Optional[typing.Sequence["CertificateSpecUsages"]] = None,
    ) -> None:
        '''Specification of the desired state of the Certificate resource.

        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status

        :param issuer_ref: Reference to the issuer responsible for issuing the certificate. If the issuer is namespace-scoped, it must be in the same namespace as the Certificate. If the issuer is cluster-scoped, it can be used from any namespace. The ``name`` field of the reference must always be specified.
        :param secret_name: Name of the Secret resource that will be automatically created and managed by this Certificate resource. It will be populated with a private key and certificate, signed by the denoted issuer. The Secret resource lives in the same namespace as the Certificate resource.
        :param additional_output_formats: Defines extra output formats of the private key and signed certificate chain to be written to this Certificate's target Secret. This is a Beta Feature enabled by default. It can be disabled with the ``--feature-gates=AdditionalCertificateOutputFormats=false`` option set on both the controller and webhook components.
        :param common_name: Requested common name X509 certificate subject attribute. More info: https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.6 NOTE: TLS clients will ignore this value when any subject alternative name is set (see https://tools.ietf.org/html/rfc6125#section-6.4.4). Should have a length of 64 characters or fewer to avoid generating invalid CSRs. Cannot be set if the ``literalSubject`` field is set.
        :param dns_names: Requested DNS subject alternative names.
        :param duration: Requested 'duration' (i.e. lifetime) of the Certificate. Note that the issuer may choose to ignore the requested duration, just like any other requested attribute. If unset, this defaults to 90 days. Minimum accepted duration is 1 hour. Value must be in units accepted by Go time.ParseDuration https://golang.org/pkg/time/#ParseDuration.
        :param email_addresses: Requested email subject alternative names.
        :param encode_usages_in_request: Whether the KeyUsage and ExtKeyUsage extensions should be set in the encoded CSR. This option defaults to true, and should only be disabled if the target issuer does not support CSRs with these X509 KeyUsage/ ExtKeyUsage extensions.
        :param ip_addresses: Requested IP address subject alternative names.
        :param is_ca: Requested basic constraints isCA value. The isCA value is used to set the ``isCA`` field on the created CertificateRequest resources. Note that the issuer may choose to ignore the requested isCA value, just like any other requested attribute. If true, this will automatically add the ``cert sign`` usage to the list of requested ``usages``.
        :param keystores: Additional keystore output formats to be stored in the Certificate's Secret.
        :param literal_subject: Requested X.509 certificate subject, represented using the LDAP "String Representation of a Distinguished Name" [1]. Important: the LDAP string format also specifies the order of the attributes in the subject, this is important when issuing certs for LDAP authentication. Example: ``CN=foo,DC=corp,DC=example,DC=com`` More info [1]: https://datatracker.ietf.org/doc/html/rfc4514 More info: https://github.com/cert-manager/cert-manager/issues/3203 More info: https://github.com/cert-manager/cert-manager/issues/4424. Cannot be set if the ``subject`` or ``commonName`` field is set.
        :param name_constraints: x.509 certificate NameConstraint extension which MUST NOT be used in a non-CA certificate. More Info: https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.10. This is an Alpha Feature and is only enabled with the ``--feature-gates=NameConstraints=true`` option set on both the controller and webhook components.
        :param other_names: ``otherNames`` is an escape hatch for SAN that allows any type. We currently restrict the support to string like otherNames, cf RFC 5280 p 37 Any UTF8 String valued otherName can be passed with by setting the keys oid: x.x.x.x and UTF8Value: somevalue for ``otherName``. Most commonly this would be UPN set with oid: 1.3.6.1.4.1.311.20.2.3 You should ensure that any OID passed is valid for the UTF8String type as we do not explicitly validate this.
        :param private_key: Private key options. These include the key algorithm and size, the used encoding and the rotation policy.
        :param renew_before: How long before the currently issued certificate's expiry cert-manager should renew the certificate. For example, if a certificate is valid for 60 minutes, and ``renewBefore=10m``, cert-manager will begin to attempt to renew the certificate 50 minutes after it was issued (i.e. when there are 10 minutes remaining until the certificate is no longer valid). NOTE: The actual lifetime of the issued certificate is used to determine the renewal time. If an issuer returns a certificate with a different lifetime than the one requested, cert-manager will use the lifetime of the issued certificate. If unset, this defaults to 1/3 of the issued certificate's lifetime. Minimum accepted value is 5 minutes. Value must be in units accepted by Go time.ParseDuration https://golang.org/pkg/time/#ParseDuration. Cannot be set if the ``renewBeforePercentage`` field is set.
        :param renew_before_percentage: ``renewBeforePercentage`` is like ``renewBefore``, except it is a relative percentage rather than an absolute duration. For example, if a certificate is valid for 60 minutes, and ``renewBeforePercentage=25``, cert-manager will begin to attempt to renew the certificate 45 minutes after it was issued (i.e. when there are 15 minutes (25%) remaining until the certificate is no longer valid). NOTE: The actual lifetime of the issued certificate is used to determine the renewal time. If an issuer returns a certificate with a different lifetime than the one requested, cert-manager will use the lifetime of the issued certificate. Value must be an integer in the range (0,100). The minimum effective ``renewBefore`` derived from the ``renewBeforePercentage`` and ``duration`` fields is 5 minutes. Cannot be set if the ``renewBefore`` field is set.
        :param revision_history_limit: The maximum number of CertificateRequest revisions that are maintained in the Certificate's history. Each revision represents a single ``CertificateRequest`` created by this Certificate, either when it was created, renewed, or Spec was changed. Revisions will be removed by oldest first if the number of revisions exceeds this number. If set, revisionHistoryLimit must be a value of ``1`` or greater. If unset (``nil``), revisions will not be garbage collected. Default value is ``nil``.
        :param secret_template: Defines annotations and labels to be copied to the Certificate's Secret. Labels and annotations on the Secret will be changed as they appear on the SecretTemplate when added or removed. SecretTemplate annotations are added in conjunction with, and cannot overwrite, the base set of annotations cert-manager sets on the Certificate's Secret.
        :param subject: Requested set of X509 certificate subject attributes. More info: https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.6. The common name attribute is specified separately in the ``commonName`` field. Cannot be set if the ``literalSubject`` field is set.
        :param uris: Requested URI subject alternative names.
        :param usages: Requested key usages and extended key usages. These usages are used to set the ``usages`` field on the created CertificateRequest resources. If ``encodeUsagesInRequest`` is unset or set to ``true``, the usages will additionally be encoded in the ``request`` field which contains the CSR blob. If unset, defaults to ``digital signature`` and ``key encipherment``.

        :schema: CertificateSpec
        '''
        if isinstance(issuer_ref, dict):
            issuer_ref = CertificateSpecIssuerRef(**issuer_ref)
        if isinstance(keystores, dict):
            keystores = CertificateSpecKeystores(**keystores)
        if isinstance(name_constraints, dict):
            name_constraints = CertificateSpecNameConstraints(**name_constraints)
        if isinstance(private_key, dict):
            private_key = CertificateSpecPrivateKey(**private_key)
        if isinstance(secret_template, dict):
            secret_template = CertificateSpecSecretTemplate(**secret_template)
        if isinstance(subject, dict):
            subject = CertificateSpecSubject(**subject)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32dc1d8bfeef97dbd877eaeb718c4dc3768875c6ca7b447e1282f47888feb140)
            check_type(argname="argument issuer_ref", value=issuer_ref, expected_type=type_hints["issuer_ref"])
            check_type(argname="argument secret_name", value=secret_name, expected_type=type_hints["secret_name"])
            check_type(argname="argument additional_output_formats", value=additional_output_formats, expected_type=type_hints["additional_output_formats"])
            check_type(argname="argument common_name", value=common_name, expected_type=type_hints["common_name"])
            check_type(argname="argument dns_names", value=dns_names, expected_type=type_hints["dns_names"])
            check_type(argname="argument duration", value=duration, expected_type=type_hints["duration"])
            check_type(argname="argument email_addresses", value=email_addresses, expected_type=type_hints["email_addresses"])
            check_type(argname="argument encode_usages_in_request", value=encode_usages_in_request, expected_type=type_hints["encode_usages_in_request"])
            check_type(argname="argument ip_addresses", value=ip_addresses, expected_type=type_hints["ip_addresses"])
            check_type(argname="argument is_ca", value=is_ca, expected_type=type_hints["is_ca"])
            check_type(argname="argument keystores", value=keystores, expected_type=type_hints["keystores"])
            check_type(argname="argument literal_subject", value=literal_subject, expected_type=type_hints["literal_subject"])
            check_type(argname="argument name_constraints", value=name_constraints, expected_type=type_hints["name_constraints"])
            check_type(argname="argument other_names", value=other_names, expected_type=type_hints["other_names"])
            check_type(argname="argument private_key", value=private_key, expected_type=type_hints["private_key"])
            check_type(argname="argument renew_before", value=renew_before, expected_type=type_hints["renew_before"])
            check_type(argname="argument renew_before_percentage", value=renew_before_percentage, expected_type=type_hints["renew_before_percentage"])
            check_type(argname="argument revision_history_limit", value=revision_history_limit, expected_type=type_hints["revision_history_limit"])
            check_type(argname="argument secret_template", value=secret_template, expected_type=type_hints["secret_template"])
            check_type(argname="argument subject", value=subject, expected_type=type_hints["subject"])
            check_type(argname="argument uris", value=uris, expected_type=type_hints["uris"])
            check_type(argname="argument usages", value=usages, expected_type=type_hints["usages"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "issuer_ref": issuer_ref,
            "secret_name": secret_name,
        }
        if additional_output_formats is not None:
            self._values["additional_output_formats"] = additional_output_formats
        if common_name is not None:
            self._values["common_name"] = common_name
        if dns_names is not None:
            self._values["dns_names"] = dns_names
        if duration is not None:
            self._values["duration"] = duration
        if email_addresses is not None:
            self._values["email_addresses"] = email_addresses
        if encode_usages_in_request is not None:
            self._values["encode_usages_in_request"] = encode_usages_in_request
        if ip_addresses is not None:
            self._values["ip_addresses"] = ip_addresses
        if is_ca is not None:
            self._values["is_ca"] = is_ca
        if keystores is not None:
            self._values["keystores"] = keystores
        if literal_subject is not None:
            self._values["literal_subject"] = literal_subject
        if name_constraints is not None:
            self._values["name_constraints"] = name_constraints
        if other_names is not None:
            self._values["other_names"] = other_names
        if private_key is not None:
            self._values["private_key"] = private_key
        if renew_before is not None:
            self._values["renew_before"] = renew_before
        if renew_before_percentage is not None:
            self._values["renew_before_percentage"] = renew_before_percentage
        if revision_history_limit is not None:
            self._values["revision_history_limit"] = revision_history_limit
        if secret_template is not None:
            self._values["secret_template"] = secret_template
        if subject is not None:
            self._values["subject"] = subject
        if uris is not None:
            self._values["uris"] = uris
        if usages is not None:
            self._values["usages"] = usages

    @builtins.property
    def issuer_ref(self) -> "CertificateSpecIssuerRef":
        '''Reference to the issuer responsible for issuing the certificate.

        If the issuer is namespace-scoped, it must be in the same namespace
        as the Certificate. If the issuer is cluster-scoped, it can be used
        from any namespace.

        The ``name`` field of the reference must always be specified.

        :schema: CertificateSpec#issuerRef
        '''
        result = self._values.get("issuer_ref")
        assert result is not None, "Required property 'issuer_ref' is missing"
        return typing.cast("CertificateSpecIssuerRef", result)

    @builtins.property
    def secret_name(self) -> builtins.str:
        '''Name of the Secret resource that will be automatically created and managed by this Certificate resource.

        It will be populated with a
        private key and certificate, signed by the denoted issuer. The Secret
        resource lives in the same namespace as the Certificate resource.

        :schema: CertificateSpec#secretName
        '''
        result = self._values.get("secret_name")
        assert result is not None, "Required property 'secret_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def additional_output_formats(
        self,
    ) -> typing.Optional[typing.List["CertificateSpecAdditionalOutputFormats"]]:
        '''Defines extra output formats of the private key and signed certificate chain to be written to this Certificate's target Secret.

        This is a Beta Feature enabled by default. It can be disabled with the
        ``--feature-gates=AdditionalCertificateOutputFormats=false`` option set on both
        the controller and webhook components.

        :schema: CertificateSpec#additionalOutputFormats
        '''
        result = self._values.get("additional_output_formats")
        return typing.cast(typing.Optional[typing.List["CertificateSpecAdditionalOutputFormats"]], result)

    @builtins.property
    def common_name(self) -> typing.Optional[builtins.str]:
        '''Requested common name X509 certificate subject attribute.

        More info: https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.6
        NOTE: TLS clients will ignore this value when any subject alternative name is
        set (see https://tools.ietf.org/html/rfc6125#section-6.4.4).

        Should have a length of 64 characters or fewer to avoid generating invalid CSRs.
        Cannot be set if the ``literalSubject`` field is set.

        :schema: CertificateSpec#commonName
        '''
        result = self._values.get("common_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dns_names(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Requested DNS subject alternative names.

        :schema: CertificateSpec#dnsNames
        '''
        result = self._values.get("dns_names")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def duration(self) -> typing.Optional[builtins.str]:
        '''Requested 'duration' (i.e. lifetime) of the Certificate. Note that the issuer may choose to ignore the requested duration, just like any other requested attribute.

        If unset, this defaults to 90 days.
        Minimum accepted duration is 1 hour.
        Value must be in units accepted by Go time.ParseDuration https://golang.org/pkg/time/#ParseDuration.

        :schema: CertificateSpec#duration
        '''
        result = self._values.get("duration")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def email_addresses(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Requested email subject alternative names.

        :schema: CertificateSpec#emailAddresses
        '''
        result = self._values.get("email_addresses")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def encode_usages_in_request(self) -> typing.Optional[builtins.bool]:
        '''Whether the KeyUsage and ExtKeyUsage extensions should be set in the encoded CSR.

        This option defaults to true, and should only be disabled if the target
        issuer does not support CSRs with these X509 KeyUsage/ ExtKeyUsage extensions.

        :schema: CertificateSpec#encodeUsagesInRequest
        '''
        result = self._values.get("encode_usages_in_request")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def ip_addresses(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Requested IP address subject alternative names.

        :schema: CertificateSpec#ipAddresses
        '''
        result = self._values.get("ip_addresses")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def is_ca(self) -> typing.Optional[builtins.bool]:
        '''Requested basic constraints isCA value.

        The isCA value is used to set the ``isCA`` field on the created CertificateRequest
        resources. Note that the issuer may choose to ignore the requested isCA value, just
        like any other requested attribute.

        If true, this will automatically add the ``cert sign`` usage to the list
        of requested ``usages``.

        :schema: CertificateSpec#isCA
        '''
        result = self._values.get("is_ca")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def keystores(self) -> typing.Optional["CertificateSpecKeystores"]:
        '''Additional keystore output formats to be stored in the Certificate's Secret.

        :schema: CertificateSpec#keystores
        '''
        result = self._values.get("keystores")
        return typing.cast(typing.Optional["CertificateSpecKeystores"], result)

    @builtins.property
    def literal_subject(self) -> typing.Optional[builtins.str]:
        '''Requested X.509 certificate subject, represented using the LDAP "String Representation of a Distinguished Name" [1]. Important: the LDAP string format also specifies the order of the attributes in the subject, this is important when issuing certs for LDAP authentication. Example: ``CN=foo,DC=corp,DC=example,DC=com`` More info [1]: https://datatracker.ietf.org/doc/html/rfc4514 More info: https://github.com/cert-manager/cert-manager/issues/3203 More info: https://github.com/cert-manager/cert-manager/issues/4424.

        Cannot be set if the ``subject`` or ``commonName`` field is set.

        :schema: CertificateSpec#literalSubject
        '''
        result = self._values.get("literal_subject")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name_constraints(self) -> typing.Optional["CertificateSpecNameConstraints"]:
        '''x.509 certificate NameConstraint extension which MUST NOT be used in a non-CA certificate. More Info: https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.10.

        This is an Alpha Feature and is only enabled with the
        ``--feature-gates=NameConstraints=true`` option set on both
        the controller and webhook components.

        :schema: CertificateSpec#nameConstraints
        '''
        result = self._values.get("name_constraints")
        return typing.cast(typing.Optional["CertificateSpecNameConstraints"], result)

    @builtins.property
    def other_names(self) -> typing.Optional[typing.List["CertificateSpecOtherNames"]]:
        '''``otherNames`` is an escape hatch for SAN that allows any type.

        We currently restrict the support to string like otherNames, cf RFC 5280 p 37
        Any UTF8 String valued otherName can be passed with by setting the keys oid: x.x.x.x and UTF8Value: somevalue for ``otherName``.
        Most commonly this would be UPN set with oid: 1.3.6.1.4.1.311.20.2.3
        You should ensure that any OID passed is valid for the UTF8String type as we do not explicitly validate this.

        :schema: CertificateSpec#otherNames
        '''
        result = self._values.get("other_names")
        return typing.cast(typing.Optional[typing.List["CertificateSpecOtherNames"]], result)

    @builtins.property
    def private_key(self) -> typing.Optional["CertificateSpecPrivateKey"]:
        '''Private key options.

        These include the key algorithm and size, the used
        encoding and the rotation policy.

        :schema: CertificateSpec#privateKey
        '''
        result = self._values.get("private_key")
        return typing.cast(typing.Optional["CertificateSpecPrivateKey"], result)

    @builtins.property
    def renew_before(self) -> typing.Optional[builtins.str]:
        '''How long before the currently issued certificate's expiry cert-manager should renew the certificate.

        For example, if a certificate is valid for 60 minutes,
        and ``renewBefore=10m``, cert-manager will begin to attempt to renew the certificate
        50 minutes after it was issued (i.e. when there are 10 minutes remaining until
        the certificate is no longer valid).

        NOTE: The actual lifetime of the issued certificate is used to determine the
        renewal time. If an issuer returns a certificate with a different lifetime than
        the one requested, cert-manager will use the lifetime of the issued certificate.

        If unset, this defaults to 1/3 of the issued certificate's lifetime.
        Minimum accepted value is 5 minutes.
        Value must be in units accepted by Go time.ParseDuration https://golang.org/pkg/time/#ParseDuration.
        Cannot be set if the ``renewBeforePercentage`` field is set.

        :schema: CertificateSpec#renewBefore
        '''
        result = self._values.get("renew_before")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def renew_before_percentage(self) -> typing.Optional[jsii.Number]:
        '''``renewBeforePercentage`` is like ``renewBefore``, except it is a relative percentage rather than an absolute duration.

        For example, if a certificate is valid for 60
        minutes, and  ``renewBeforePercentage=25``, cert-manager will begin to attempt to
        renew the certificate 45 minutes after it was issued (i.e. when there are 15
        minutes (25%) remaining until the certificate is no longer valid).

        NOTE: The actual lifetime of the issued certificate is used to determine the
        renewal time. If an issuer returns a certificate with a different lifetime than
        the one requested, cert-manager will use the lifetime of the issued certificate.

        Value must be an integer in the range (0,100). The minimum effective
        ``renewBefore`` derived from the ``renewBeforePercentage`` and ``duration`` fields is 5
        minutes.
        Cannot be set if the ``renewBefore`` field is set.

        :schema: CertificateSpec#renewBeforePercentage
        '''
        result = self._values.get("renew_before_percentage")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def revision_history_limit(self) -> typing.Optional[jsii.Number]:
        '''The maximum number of CertificateRequest revisions that are maintained in the Certificate's history.

        Each revision represents a single ``CertificateRequest``
        created by this Certificate, either when it was created, renewed, or Spec
        was changed. Revisions will be removed by oldest first if the number of
        revisions exceeds this number.

        If set, revisionHistoryLimit must be a value of ``1`` or greater.
        If unset (``nil``), revisions will not be garbage collected.
        Default value is ``nil``.

        :schema: CertificateSpec#revisionHistoryLimit
        '''
        result = self._values.get("revision_history_limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def secret_template(self) -> typing.Optional["CertificateSpecSecretTemplate"]:
        '''Defines annotations and labels to be copied to the Certificate's Secret.

        Labels and annotations on the Secret will be changed as they appear on the
        SecretTemplate when added or removed. SecretTemplate annotations are added
        in conjunction with, and cannot overwrite, the base set of annotations
        cert-manager sets on the Certificate's Secret.

        :schema: CertificateSpec#secretTemplate
        '''
        result = self._values.get("secret_template")
        return typing.cast(typing.Optional["CertificateSpecSecretTemplate"], result)

    @builtins.property
    def subject(self) -> typing.Optional["CertificateSpecSubject"]:
        '''Requested set of X509 certificate subject attributes. More info: https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.6.

        The common name attribute is specified separately in the ``commonName`` field.
        Cannot be set if the ``literalSubject`` field is set.

        :schema: CertificateSpec#subject
        '''
        result = self._values.get("subject")
        return typing.cast(typing.Optional["CertificateSpecSubject"], result)

    @builtins.property
    def uris(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Requested URI subject alternative names.

        :schema: CertificateSpec#uris
        '''
        result = self._values.get("uris")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def usages(self) -> typing.Optional[typing.List["CertificateSpecUsages"]]:
        '''Requested key usages and extended key usages.

        These usages are used to set the ``usages`` field on the created CertificateRequest
        resources. If ``encodeUsagesInRequest`` is unset or set to ``true``, the usages
        will additionally be encoded in the ``request`` field which contains the CSR blob.

        If unset, defaults to ``digital signature`` and ``key encipherment``.

        :schema: CertificateSpec#usages
        '''
        result = self._values.get("usages")
        return typing.cast(typing.Optional[typing.List["CertificateSpecUsages"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.CertificateSpecAdditionalOutputFormats",
    jsii_struct_bases=[],
    name_mapping={"type": "type"},
)
class CertificateSpecAdditionalOutputFormats:
    def __init__(self, *, type: "CertificateSpecAdditionalOutputFormatsType") -> None:
        '''CertificateAdditionalOutputFormat defines an additional output format of a Certificate resource.

        These contain supplementary data formats of the signed
        certificate chain and paired private key.

        :param type: Type is the name of the format type that should be written to the Certificate's target Secret.

        :schema: CertificateSpecAdditionalOutputFormats
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b105d0e0ff4812a7d27236854fdec57381ceb1aebb380c990c0158888686634f)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "type": type,
        }

    @builtins.property
    def type(self) -> "CertificateSpecAdditionalOutputFormatsType":
        '''Type is the name of the format type that should be written to the Certificate's target Secret.

        :schema: CertificateSpecAdditionalOutputFormats#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("CertificateSpecAdditionalOutputFormatsType", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateSpecAdditionalOutputFormats(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="iocert-manager.CertificateSpecAdditionalOutputFormatsType")
class CertificateSpecAdditionalOutputFormatsType(enum.Enum):
    '''Type is the name of the format type that should be written to the Certificate's target Secret.

    :schema: CertificateSpecAdditionalOutputFormatsType
    '''

    DER = "DER"
    '''DER.'''
    COMBINED_PEM = "COMBINED_PEM"
    '''CombinedPEM.'''


@jsii.data_type(
    jsii_type="iocert-manager.CertificateSpecIssuerRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "group": "group", "kind": "kind"},
)
class CertificateSpecIssuerRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        group: typing.Optional[builtins.str] = None,
        kind: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to the issuer responsible for issuing the certificate.

        If the issuer is namespace-scoped, it must be in the same namespace
        as the Certificate. If the issuer is cluster-scoped, it can be used
        from any namespace.

        The ``name`` field of the reference must always be specified.

        :param name: Name of the resource being referred to.
        :param group: Group of the resource being referred to.
        :param kind: Kind of the resource being referred to.

        :schema: CertificateSpecIssuerRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__250ffc36555234fb3774546a78f06060f14ef24da211d902560be0f8f100fb0b)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument group", value=group, expected_type=type_hints["group"])
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if group is not None:
            self._values["group"] = group
        if kind is not None:
            self._values["kind"] = kind

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        :schema: CertificateSpecIssuerRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group(self) -> typing.Optional[builtins.str]:
        '''Group of the resource being referred to.

        :schema: CertificateSpecIssuerRef#group
        '''
        result = self._values.get("group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        '''Kind of the resource being referred to.

        :schema: CertificateSpecIssuerRef#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateSpecIssuerRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.CertificateSpecKeystores",
    jsii_struct_bases=[],
    name_mapping={"jks": "jks", "pkcs12": "pkcs12"},
)
class CertificateSpecKeystores:
    def __init__(
        self,
        *,
        jks: typing.Optional[typing.Union["CertificateSpecKeystoresJks", typing.Dict[builtins.str, typing.Any]]] = None,
        pkcs12: typing.Optional[typing.Union["CertificateSpecKeystoresPkcs12", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Additional keystore output formats to be stored in the Certificate's Secret.

        :param jks: JKS configures options for storing a JKS keystore in the ``spec.secretName`` Secret resource.
        :param pkcs12: PKCS12 configures options for storing a PKCS12 keystore in the ``spec.secretName`` Secret resource.

        :schema: CertificateSpecKeystores
        '''
        if isinstance(jks, dict):
            jks = CertificateSpecKeystoresJks(**jks)
        if isinstance(pkcs12, dict):
            pkcs12 = CertificateSpecKeystoresPkcs12(**pkcs12)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__304190a06d3e60433de1a2655ea13ece3d452ac5995f8f0e820230f00e479dd2)
            check_type(argname="argument jks", value=jks, expected_type=type_hints["jks"])
            check_type(argname="argument pkcs12", value=pkcs12, expected_type=type_hints["pkcs12"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if jks is not None:
            self._values["jks"] = jks
        if pkcs12 is not None:
            self._values["pkcs12"] = pkcs12

    @builtins.property
    def jks(self) -> typing.Optional["CertificateSpecKeystoresJks"]:
        '''JKS configures options for storing a JKS keystore in the ``spec.secretName`` Secret resource.

        :schema: CertificateSpecKeystores#jks
        '''
        result = self._values.get("jks")
        return typing.cast(typing.Optional["CertificateSpecKeystoresJks"], result)

    @builtins.property
    def pkcs12(self) -> typing.Optional["CertificateSpecKeystoresPkcs12"]:
        '''PKCS12 configures options for storing a PKCS12 keystore in the ``spec.secretName`` Secret resource.

        :schema: CertificateSpecKeystores#pkcs12
        '''
        result = self._values.get("pkcs12")
        return typing.cast(typing.Optional["CertificateSpecKeystoresPkcs12"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateSpecKeystores(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.CertificateSpecKeystoresJks",
    jsii_struct_bases=[],
    name_mapping={
        "create": "create",
        "alias": "alias",
        "password": "password",
        "password_secret_ref": "passwordSecretRef",
    },
)
class CertificateSpecKeystoresJks:
    def __init__(
        self,
        *,
        create: builtins.bool,
        alias: typing.Optional[builtins.str] = None,
        password: typing.Optional[builtins.str] = None,
        password_secret_ref: typing.Optional[typing.Union["CertificateSpecKeystoresJksPasswordSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''JKS configures options for storing a JKS keystore in the ``spec.secretName`` Secret resource.

        :param create: Create enables JKS keystore creation for the Certificate. If true, a file named ``keystore.jks`` will be created in the target Secret resource, encrypted using the password stored in ``passwordSecretRef`` or ``password``. The keystore file will be updated immediately. If the issuer provided a CA certificate, a file named ``truststore.jks`` will also be created in the target Secret resource, encrypted using the password stored in ``passwordSecretRef`` containing the issuing Certificate Authority
        :param alias: Alias specifies the alias of the key in the keystore, required by the JKS format. If not provided, the default alias ``certificate`` will be used.
        :param password: Password provides a literal password used to encrypt the JKS keystore. Mutually exclusive with passwordSecretRef. One of password or passwordSecretRef must provide a password with a non-zero length.
        :param password_secret_ref: PasswordSecretRef is a reference to a non-empty key in a Secret resource containing the password used to encrypt the JKS keystore. Mutually exclusive with password. One of password or passwordSecretRef must provide a password with a non-zero length.

        :schema: CertificateSpecKeystoresJks
        '''
        if isinstance(password_secret_ref, dict):
            password_secret_ref = CertificateSpecKeystoresJksPasswordSecretRef(**password_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__571b4581314dc6da5154732cbc505ea05f780b18877fbcbc24fd2e2fa8274e62)
            check_type(argname="argument create", value=create, expected_type=type_hints["create"])
            check_type(argname="argument alias", value=alias, expected_type=type_hints["alias"])
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
            check_type(argname="argument password_secret_ref", value=password_secret_ref, expected_type=type_hints["password_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "create": create,
        }
        if alias is not None:
            self._values["alias"] = alias
        if password is not None:
            self._values["password"] = password
        if password_secret_ref is not None:
            self._values["password_secret_ref"] = password_secret_ref

    @builtins.property
    def create(self) -> builtins.bool:
        '''Create enables JKS keystore creation for the Certificate.

        If true, a file named ``keystore.jks`` will be created in the target
        Secret resource, encrypted using the password stored in
        ``passwordSecretRef`` or ``password``.
        The keystore file will be updated immediately.
        If the issuer provided a CA certificate, a file named ``truststore.jks``
        will also be created in the target Secret resource, encrypted using the
        password stored in ``passwordSecretRef``
        containing the issuing Certificate Authority

        :schema: CertificateSpecKeystoresJks#create
        '''
        result = self._values.get("create")
        assert result is not None, "Required property 'create' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def alias(self) -> typing.Optional[builtins.str]:
        '''Alias specifies the alias of the key in the keystore, required by the JKS format.

        If not provided, the default alias ``certificate`` will be used.

        :schema: CertificateSpecKeystoresJks#alias
        '''
        result = self._values.get("alias")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        '''Password provides a literal password used to encrypt the JKS keystore.

        Mutually exclusive with passwordSecretRef.
        One of password or passwordSecretRef must provide a password with a non-zero length.

        :schema: CertificateSpecKeystoresJks#password
        '''
        result = self._values.get("password")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def password_secret_ref(
        self,
    ) -> typing.Optional["CertificateSpecKeystoresJksPasswordSecretRef"]:
        '''PasswordSecretRef is a reference to a non-empty key in a Secret resource containing the password used to encrypt the JKS keystore.

        Mutually exclusive with password.
        One of password or passwordSecretRef must provide a password with a non-zero length.

        :schema: CertificateSpecKeystoresJks#passwordSecretRef
        '''
        result = self._values.get("password_secret_ref")
        return typing.cast(typing.Optional["CertificateSpecKeystoresJksPasswordSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateSpecKeystoresJks(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.CertificateSpecKeystoresJksPasswordSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class CertificateSpecKeystoresJksPasswordSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''PasswordSecretRef is a reference to a non-empty key in a Secret resource containing the password used to encrypt the JKS keystore.

        Mutually exclusive with password.
        One of password or passwordSecretRef must provide a password with a non-zero length.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: CertificateSpecKeystoresJksPasswordSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c705b97f1ec6666fe596694a6020ae107ebdb667b49d9a0e8e70230b3299e82)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: CertificateSpecKeystoresJksPasswordSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: CertificateSpecKeystoresJksPasswordSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateSpecKeystoresJksPasswordSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.CertificateSpecKeystoresPkcs12",
    jsii_struct_bases=[],
    name_mapping={
        "create": "create",
        "password": "password",
        "password_secret_ref": "passwordSecretRef",
        "profile": "profile",
    },
)
class CertificateSpecKeystoresPkcs12:
    def __init__(
        self,
        *,
        create: builtins.bool,
        password: typing.Optional[builtins.str] = None,
        password_secret_ref: typing.Optional[typing.Union["CertificateSpecKeystoresPkcs12PasswordSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        profile: typing.Optional["CertificateSpecKeystoresPkcs12Profile"] = None,
    ) -> None:
        '''PKCS12 configures options for storing a PKCS12 keystore in the ``spec.secretName`` Secret resource.

        :param create: Create enables PKCS12 keystore creation for the Certificate. If true, a file named ``keystore.p12`` will be created in the target Secret resource, encrypted using the password stored in ``passwordSecretRef`` or in ``password``. The keystore file will be updated immediately. If the issuer provided a CA certificate, a file named ``truststore.p12`` will also be created in the target Secret resource, encrypted using the password stored in ``passwordSecretRef`` containing the issuing Certificate Authority
        :param password: Password provides a literal password used to encrypt the PKCS#12 keystore. Mutually exclusive with passwordSecretRef. One of password or passwordSecretRef must provide a password with a non-zero length.
        :param password_secret_ref: PasswordSecretRef is a reference to a non-empty key in a Secret resource containing the password used to encrypt the PKCS#12 keystore. Mutually exclusive with password. One of password or passwordSecretRef must provide a password with a non-zero length.
        :param profile: Profile specifies the key and certificate encryption algorithms and the HMAC algorithm used to create the PKCS12 keystore. Default value is ``LegacyRC2`` for backward compatibility. If provided, allowed values are: ``LegacyRC2``: Deprecated. Not supported by default in OpenSSL 3 or Java 20. ``LegacyDES``: Less secure algorithm. Use this option for maximal compatibility. ``Modern2023``: Secure algorithm. Use this option in case you have to always use secure algorithms (eg. because of company policy). Please note that the security of the algorithm is not that important in reality, because the unencrypted certificate and private key are also stored in the Secret.

        :schema: CertificateSpecKeystoresPkcs12
        '''
        if isinstance(password_secret_ref, dict):
            password_secret_ref = CertificateSpecKeystoresPkcs12PasswordSecretRef(**password_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5382e8480294729cddd333c0c832e9c632efa49695fb65db41f2232ecd5fb79)
            check_type(argname="argument create", value=create, expected_type=type_hints["create"])
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
            check_type(argname="argument password_secret_ref", value=password_secret_ref, expected_type=type_hints["password_secret_ref"])
            check_type(argname="argument profile", value=profile, expected_type=type_hints["profile"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "create": create,
        }
        if password is not None:
            self._values["password"] = password
        if password_secret_ref is not None:
            self._values["password_secret_ref"] = password_secret_ref
        if profile is not None:
            self._values["profile"] = profile

    @builtins.property
    def create(self) -> builtins.bool:
        '''Create enables PKCS12 keystore creation for the Certificate.

        If true, a file named ``keystore.p12`` will be created in the target
        Secret resource, encrypted using the password stored in
        ``passwordSecretRef`` or in ``password``.
        The keystore file will be updated immediately.
        If the issuer provided a CA certificate, a file named ``truststore.p12`` will
        also be created in the target Secret resource, encrypted using the
        password stored in ``passwordSecretRef`` containing the issuing Certificate
        Authority

        :schema: CertificateSpecKeystoresPkcs12#create
        '''
        result = self._values.get("create")
        assert result is not None, "Required property 'create' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        '''Password provides a literal password used to encrypt the PKCS#12 keystore.

        Mutually exclusive with passwordSecretRef.
        One of password or passwordSecretRef must provide a password with a non-zero length.

        :schema: CertificateSpecKeystoresPkcs12#password
        '''
        result = self._values.get("password")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def password_secret_ref(
        self,
    ) -> typing.Optional["CertificateSpecKeystoresPkcs12PasswordSecretRef"]:
        '''PasswordSecretRef is a reference to a non-empty key in a Secret resource containing the password used to encrypt the PKCS#12 keystore.

        Mutually exclusive with password.
        One of password or passwordSecretRef must provide a password with a non-zero length.

        :schema: CertificateSpecKeystoresPkcs12#passwordSecretRef
        '''
        result = self._values.get("password_secret_ref")
        return typing.cast(typing.Optional["CertificateSpecKeystoresPkcs12PasswordSecretRef"], result)

    @builtins.property
    def profile(self) -> typing.Optional["CertificateSpecKeystoresPkcs12Profile"]:
        '''Profile specifies the key and certificate encryption algorithms and the HMAC algorithm used to create the PKCS12 keystore.

        Default value is ``LegacyRC2`` for backward compatibility.

        If provided, allowed values are:
        ``LegacyRC2``: Deprecated. Not supported by default in OpenSSL 3 or Java 20.
        ``LegacyDES``: Less secure algorithm. Use this option for maximal compatibility.
        ``Modern2023``: Secure algorithm. Use this option in case you have to always use secure algorithms
        (eg. because of company policy). Please note that the security of the algorithm is not that important
        in reality, because the unencrypted certificate and private key are also stored in the Secret.

        :schema: CertificateSpecKeystoresPkcs12#profile
        '''
        result = self._values.get("profile")
        return typing.cast(typing.Optional["CertificateSpecKeystoresPkcs12Profile"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateSpecKeystoresPkcs12(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.CertificateSpecKeystoresPkcs12PasswordSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class CertificateSpecKeystoresPkcs12PasswordSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''PasswordSecretRef is a reference to a non-empty key in a Secret resource containing the password used to encrypt the PKCS#12 keystore.

        Mutually exclusive with password.
        One of password or passwordSecretRef must provide a password with a non-zero length.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: CertificateSpecKeystoresPkcs12PasswordSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20086e6fd1b2e1e2a9457b1cfb63413328de2c314da016e54e9a15a2a0a98681)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: CertificateSpecKeystoresPkcs12PasswordSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: CertificateSpecKeystoresPkcs12PasswordSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateSpecKeystoresPkcs12PasswordSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="iocert-manager.CertificateSpecKeystoresPkcs12Profile")
class CertificateSpecKeystoresPkcs12Profile(enum.Enum):
    '''Profile specifies the key and certificate encryption algorithms and the HMAC algorithm used to create the PKCS12 keystore.

    Default value is ``LegacyRC2`` for backward compatibility.

    If provided, allowed values are:
    ``LegacyRC2``: Deprecated. Not supported by default in OpenSSL 3 or Java 20.
    ``LegacyDES``: Less secure algorithm. Use this option for maximal compatibility.
    ``Modern2023``: Secure algorithm. Use this option in case you have to always use secure algorithms
    (eg. because of company policy). Please note that the security of the algorithm is not that important
    in reality, because the unencrypted certificate and private key are also stored in the Secret.

    :schema: CertificateSpecKeystoresPkcs12Profile
    '''

    LEGACY_RC2 = "LEGACY_RC2"
    '''LegacyRC2.'''
    LEGACY_DES = "LEGACY_DES"
    '''LegacyDES.'''
    MODERN2023 = "MODERN2023"
    '''Modern2023.'''


@jsii.data_type(
    jsii_type="iocert-manager.CertificateSpecNameConstraints",
    jsii_struct_bases=[],
    name_mapping={
        "critical": "critical",
        "excluded": "excluded",
        "permitted": "permitted",
    },
)
class CertificateSpecNameConstraints:
    def __init__(
        self,
        *,
        critical: typing.Optional[builtins.bool] = None,
        excluded: typing.Optional[typing.Union["CertificateSpecNameConstraintsExcluded", typing.Dict[builtins.str, typing.Any]]] = None,
        permitted: typing.Optional[typing.Union["CertificateSpecNameConstraintsPermitted", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''x.509 certificate NameConstraint extension which MUST NOT be used in a non-CA certificate. More Info: https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.10.

        This is an Alpha Feature and is only enabled with the
        ``--feature-gates=NameConstraints=true`` option set on both
        the controller and webhook components.

        :param critical: if true then the name constraints are marked critical.
        :param excluded: Excluded contains the constraints which must be disallowed. Any name matching a restriction in the excluded field is invalid regardless of information appearing in the permitted
        :param permitted: Permitted contains the constraints in which the names must be located.

        :schema: CertificateSpecNameConstraints
        '''
        if isinstance(excluded, dict):
            excluded = CertificateSpecNameConstraintsExcluded(**excluded)
        if isinstance(permitted, dict):
            permitted = CertificateSpecNameConstraintsPermitted(**permitted)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e41e90c83f48c5162562588989d0033ac0148b3c79315d65e7db457c8bbb031)
            check_type(argname="argument critical", value=critical, expected_type=type_hints["critical"])
            check_type(argname="argument excluded", value=excluded, expected_type=type_hints["excluded"])
            check_type(argname="argument permitted", value=permitted, expected_type=type_hints["permitted"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if critical is not None:
            self._values["critical"] = critical
        if excluded is not None:
            self._values["excluded"] = excluded
        if permitted is not None:
            self._values["permitted"] = permitted

    @builtins.property
    def critical(self) -> typing.Optional[builtins.bool]:
        '''if true then the name constraints are marked critical.

        :schema: CertificateSpecNameConstraints#critical
        '''
        result = self._values.get("critical")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def excluded(self) -> typing.Optional["CertificateSpecNameConstraintsExcluded"]:
        '''Excluded contains the constraints which must be disallowed.

        Any name matching a
        restriction in the excluded field is invalid regardless
        of information appearing in the permitted

        :schema: CertificateSpecNameConstraints#excluded
        '''
        result = self._values.get("excluded")
        return typing.cast(typing.Optional["CertificateSpecNameConstraintsExcluded"], result)

    @builtins.property
    def permitted(self) -> typing.Optional["CertificateSpecNameConstraintsPermitted"]:
        '''Permitted contains the constraints in which the names must be located.

        :schema: CertificateSpecNameConstraints#permitted
        '''
        result = self._values.get("permitted")
        return typing.cast(typing.Optional["CertificateSpecNameConstraintsPermitted"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateSpecNameConstraints(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.CertificateSpecNameConstraintsExcluded",
    jsii_struct_bases=[],
    name_mapping={
        "dns_domains": "dnsDomains",
        "email_addresses": "emailAddresses",
        "ip_ranges": "ipRanges",
        "uri_domains": "uriDomains",
    },
)
class CertificateSpecNameConstraintsExcluded:
    def __init__(
        self,
        *,
        dns_domains: typing.Optional[typing.Sequence[builtins.str]] = None,
        email_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
        ip_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
        uri_domains: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Excluded contains the constraints which must be disallowed.

        Any name matching a
        restriction in the excluded field is invalid regardless
        of information appearing in the permitted

        :param dns_domains: DNSDomains is a list of DNS domains that are permitted or excluded.
        :param email_addresses: EmailAddresses is a list of Email Addresses that are permitted or excluded.
        :param ip_ranges: IPRanges is a list of IP Ranges that are permitted or excluded. This should be a valid CIDR notation.
        :param uri_domains: URIDomains is a list of URI domains that are permitted or excluded.

        :schema: CertificateSpecNameConstraintsExcluded
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__247066a7c5bf96c4f593b9dd37634902faee41c7166476230de716b98d28c0d1)
            check_type(argname="argument dns_domains", value=dns_domains, expected_type=type_hints["dns_domains"])
            check_type(argname="argument email_addresses", value=email_addresses, expected_type=type_hints["email_addresses"])
            check_type(argname="argument ip_ranges", value=ip_ranges, expected_type=type_hints["ip_ranges"])
            check_type(argname="argument uri_domains", value=uri_domains, expected_type=type_hints["uri_domains"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dns_domains is not None:
            self._values["dns_domains"] = dns_domains
        if email_addresses is not None:
            self._values["email_addresses"] = email_addresses
        if ip_ranges is not None:
            self._values["ip_ranges"] = ip_ranges
        if uri_domains is not None:
            self._values["uri_domains"] = uri_domains

    @builtins.property
    def dns_domains(self) -> typing.Optional[typing.List[builtins.str]]:
        '''DNSDomains is a list of DNS domains that are permitted or excluded.

        :schema: CertificateSpecNameConstraintsExcluded#dnsDomains
        '''
        result = self._values.get("dns_domains")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def email_addresses(self) -> typing.Optional[typing.List[builtins.str]]:
        '''EmailAddresses is a list of Email Addresses that are permitted or excluded.

        :schema: CertificateSpecNameConstraintsExcluded#emailAddresses
        '''
        result = self._values.get("email_addresses")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def ip_ranges(self) -> typing.Optional[typing.List[builtins.str]]:
        '''IPRanges is a list of IP Ranges that are permitted or excluded.

        This should be a valid CIDR notation.

        :schema: CertificateSpecNameConstraintsExcluded#ipRanges
        '''
        result = self._values.get("ip_ranges")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def uri_domains(self) -> typing.Optional[typing.List[builtins.str]]:
        '''URIDomains is a list of URI domains that are permitted or excluded.

        :schema: CertificateSpecNameConstraintsExcluded#uriDomains
        '''
        result = self._values.get("uri_domains")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateSpecNameConstraintsExcluded(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.CertificateSpecNameConstraintsPermitted",
    jsii_struct_bases=[],
    name_mapping={
        "dns_domains": "dnsDomains",
        "email_addresses": "emailAddresses",
        "ip_ranges": "ipRanges",
        "uri_domains": "uriDomains",
    },
)
class CertificateSpecNameConstraintsPermitted:
    def __init__(
        self,
        *,
        dns_domains: typing.Optional[typing.Sequence[builtins.str]] = None,
        email_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
        ip_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
        uri_domains: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Permitted contains the constraints in which the names must be located.

        :param dns_domains: DNSDomains is a list of DNS domains that are permitted or excluded.
        :param email_addresses: EmailAddresses is a list of Email Addresses that are permitted or excluded.
        :param ip_ranges: IPRanges is a list of IP Ranges that are permitted or excluded. This should be a valid CIDR notation.
        :param uri_domains: URIDomains is a list of URI domains that are permitted or excluded.

        :schema: CertificateSpecNameConstraintsPermitted
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b620fa1b845e5778a32c4ec4360e6a1161a21008669ce3ff996e0e05cf7c7cf)
            check_type(argname="argument dns_domains", value=dns_domains, expected_type=type_hints["dns_domains"])
            check_type(argname="argument email_addresses", value=email_addresses, expected_type=type_hints["email_addresses"])
            check_type(argname="argument ip_ranges", value=ip_ranges, expected_type=type_hints["ip_ranges"])
            check_type(argname="argument uri_domains", value=uri_domains, expected_type=type_hints["uri_domains"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dns_domains is not None:
            self._values["dns_domains"] = dns_domains
        if email_addresses is not None:
            self._values["email_addresses"] = email_addresses
        if ip_ranges is not None:
            self._values["ip_ranges"] = ip_ranges
        if uri_domains is not None:
            self._values["uri_domains"] = uri_domains

    @builtins.property
    def dns_domains(self) -> typing.Optional[typing.List[builtins.str]]:
        '''DNSDomains is a list of DNS domains that are permitted or excluded.

        :schema: CertificateSpecNameConstraintsPermitted#dnsDomains
        '''
        result = self._values.get("dns_domains")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def email_addresses(self) -> typing.Optional[typing.List[builtins.str]]:
        '''EmailAddresses is a list of Email Addresses that are permitted or excluded.

        :schema: CertificateSpecNameConstraintsPermitted#emailAddresses
        '''
        result = self._values.get("email_addresses")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def ip_ranges(self) -> typing.Optional[typing.List[builtins.str]]:
        '''IPRanges is a list of IP Ranges that are permitted or excluded.

        This should be a valid CIDR notation.

        :schema: CertificateSpecNameConstraintsPermitted#ipRanges
        '''
        result = self._values.get("ip_ranges")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def uri_domains(self) -> typing.Optional[typing.List[builtins.str]]:
        '''URIDomains is a list of URI domains that are permitted or excluded.

        :schema: CertificateSpecNameConstraintsPermitted#uriDomains
        '''
        result = self._values.get("uri_domains")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateSpecNameConstraintsPermitted(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.CertificateSpecOtherNames",
    jsii_struct_bases=[],
    name_mapping={"oid": "oid", "utf8_value": "utf8Value"},
)
class CertificateSpecOtherNames:
    def __init__(
        self,
        *,
        oid: typing.Optional[builtins.str] = None,
        utf8_value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param oid: OID is the object identifier for the otherName SAN. The object identifier must be expressed as a dotted string, for example, "1.2.840.113556.1.4.221".
        :param utf8_value: utf8Value is the string value of the otherName SAN. The utf8Value accepts any valid UTF8 string to set as value for the otherName SAN.

        :schema: CertificateSpecOtherNames
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b7d18e6290327111a832f5aa91793478e1328e8cde647bcafbca8ee289177d21)
            check_type(argname="argument oid", value=oid, expected_type=type_hints["oid"])
            check_type(argname="argument utf8_value", value=utf8_value, expected_type=type_hints["utf8_value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if oid is not None:
            self._values["oid"] = oid
        if utf8_value is not None:
            self._values["utf8_value"] = utf8_value

    @builtins.property
    def oid(self) -> typing.Optional[builtins.str]:
        '''OID is the object identifier for the otherName SAN.

        The object identifier must be expressed as a dotted string, for
        example, "1.2.840.113556.1.4.221".

        :schema: CertificateSpecOtherNames#oid
        '''
        result = self._values.get("oid")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def utf8_value(self) -> typing.Optional[builtins.str]:
        '''utf8Value is the string value of the otherName SAN.

        The utf8Value accepts any valid UTF8 string to set as value for the otherName SAN.

        :schema: CertificateSpecOtherNames#utf8Value
        '''
        result = self._values.get("utf8_value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateSpecOtherNames(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.CertificateSpecPrivateKey",
    jsii_struct_bases=[],
    name_mapping={
        "algorithm": "algorithm",
        "encoding": "encoding",
        "rotation_policy": "rotationPolicy",
        "size": "size",
    },
)
class CertificateSpecPrivateKey:
    def __init__(
        self,
        *,
        algorithm: typing.Optional["CertificateSpecPrivateKeyAlgorithm"] = None,
        encoding: typing.Optional["CertificateSpecPrivateKeyEncoding"] = None,
        rotation_policy: typing.Optional["CertificateSpecPrivateKeyRotationPolicy"] = None,
        size: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Private key options.

        These include the key algorithm and size, the used
        encoding and the rotation policy.

        :param algorithm: Algorithm is the private key algorithm of the corresponding private key for this certificate. If provided, allowed values are either ``RSA``, ``ECDSA`` or ``Ed25519``. If ``algorithm`` is specified and ``size`` is not provided, key size of 2048 will be used for ``RSA`` key algorithm and key size of 256 will be used for ``ECDSA`` key algorithm. key size is ignored when using the ``Ed25519`` key algorithm.
        :param encoding: The private key cryptography standards (PKCS) encoding for this certificate's private key to be encoded in. If provided, allowed values are ``PKCS1`` and ``PKCS8`` standing for PKCS#1 and PKCS#8, respectively. Defaults to ``PKCS1`` if not specified. Default: PKCS1` if not specified.
        :param rotation_policy: RotationPolicy controls how private keys should be regenerated when a re-issuance is being processed. If set to ``Never``, a private key will only be generated if one does not already exist in the target ``spec.secretName``. If one does exist but it does not have the correct algorithm or size, a warning will be raised to await user intervention. If set to ``Always``, a private key matching the specified requirements will be generated whenever a re-issuance occurs. Default is ``Never`` for backward compatibility. Default: Never` for backward compatibility.
        :param size: Size is the key bit size of the corresponding private key for this certificate. If ``algorithm`` is set to ``RSA``, valid values are ``2048``, ``4096`` or ``8192``, and will default to ``2048`` if not specified. If ``algorithm`` is set to ``ECDSA``, valid values are ``256``, ``384`` or ``521``, and will default to ``256`` if not specified. If ``algorithm`` is set to ``Ed25519``, Size is ignored. No other values are allowed.

        :schema: CertificateSpecPrivateKey
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f5431d5942f0586bccd87c567d6a856c8a29cf36d3c9a803a66e150a76e9bd2)
            check_type(argname="argument algorithm", value=algorithm, expected_type=type_hints["algorithm"])
            check_type(argname="argument encoding", value=encoding, expected_type=type_hints["encoding"])
            check_type(argname="argument rotation_policy", value=rotation_policy, expected_type=type_hints["rotation_policy"])
            check_type(argname="argument size", value=size, expected_type=type_hints["size"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if algorithm is not None:
            self._values["algorithm"] = algorithm
        if encoding is not None:
            self._values["encoding"] = encoding
        if rotation_policy is not None:
            self._values["rotation_policy"] = rotation_policy
        if size is not None:
            self._values["size"] = size

    @builtins.property
    def algorithm(self) -> typing.Optional["CertificateSpecPrivateKeyAlgorithm"]:
        '''Algorithm is the private key algorithm of the corresponding private key for this certificate.

        If provided, allowed values are either ``RSA``, ``ECDSA`` or ``Ed25519``.
        If ``algorithm`` is specified and ``size`` is not provided,
        key size of 2048 will be used for ``RSA`` key algorithm and
        key size of 256 will be used for ``ECDSA`` key algorithm.
        key size is ignored when using the ``Ed25519`` key algorithm.

        :schema: CertificateSpecPrivateKey#algorithm
        '''
        result = self._values.get("algorithm")
        return typing.cast(typing.Optional["CertificateSpecPrivateKeyAlgorithm"], result)

    @builtins.property
    def encoding(self) -> typing.Optional["CertificateSpecPrivateKeyEncoding"]:
        '''The private key cryptography standards (PKCS) encoding for this certificate's private key to be encoded in.

        If provided, allowed values are ``PKCS1`` and ``PKCS8`` standing for PKCS#1
        and PKCS#8, respectively.
        Defaults to ``PKCS1`` if not specified.

        :default: PKCS1` if not specified.

        :schema: CertificateSpecPrivateKey#encoding
        '''
        result = self._values.get("encoding")
        return typing.cast(typing.Optional["CertificateSpecPrivateKeyEncoding"], result)

    @builtins.property
    def rotation_policy(
        self,
    ) -> typing.Optional["CertificateSpecPrivateKeyRotationPolicy"]:
        '''RotationPolicy controls how private keys should be regenerated when a re-issuance is being processed.

        If set to ``Never``, a private key will only be generated if one does not
        already exist in the target ``spec.secretName``. If one does exist but it
        does not have the correct algorithm or size, a warning will be raised
        to await user intervention.
        If set to ``Always``, a private key matching the specified requirements
        will be generated whenever a re-issuance occurs.
        Default is ``Never`` for backward compatibility.

        :default: Never` for backward compatibility.

        :schema: CertificateSpecPrivateKey#rotationPolicy
        '''
        result = self._values.get("rotation_policy")
        return typing.cast(typing.Optional["CertificateSpecPrivateKeyRotationPolicy"], result)

    @builtins.property
    def size(self) -> typing.Optional[jsii.Number]:
        '''Size is the key bit size of the corresponding private key for this certificate.

        If ``algorithm`` is set to ``RSA``, valid values are ``2048``, ``4096`` or ``8192``,
        and will default to ``2048`` if not specified.
        If ``algorithm`` is set to ``ECDSA``, valid values are ``256``, ``384`` or ``521``,
        and will default to ``256`` if not specified.
        If ``algorithm`` is set to ``Ed25519``, Size is ignored.
        No other values are allowed.

        :schema: CertificateSpecPrivateKey#size
        '''
        result = self._values.get("size")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateSpecPrivateKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="iocert-manager.CertificateSpecPrivateKeyAlgorithm")
class CertificateSpecPrivateKeyAlgorithm(enum.Enum):
    '''Algorithm is the private key algorithm of the corresponding private key for this certificate.

    If provided, allowed values are either ``RSA``, ``ECDSA`` or ``Ed25519``.
    If ``algorithm`` is specified and ``size`` is not provided,
    key size of 2048 will be used for ``RSA`` key algorithm and
    key size of 256 will be used for ``ECDSA`` key algorithm.
    key size is ignored when using the ``Ed25519`` key algorithm.

    :schema: CertificateSpecPrivateKeyAlgorithm
    '''

    RSA = "RSA"
    '''RSA.'''
    ECDSA = "ECDSA"
    '''ECDSA.'''
    ED25519 = "ED25519"
    '''Ed25519.'''


@jsii.enum(jsii_type="iocert-manager.CertificateSpecPrivateKeyEncoding")
class CertificateSpecPrivateKeyEncoding(enum.Enum):
    '''The private key cryptography standards (PKCS) encoding for this certificate's private key to be encoded in.

    If provided, allowed values are ``PKCS1`` and ``PKCS8`` standing for PKCS#1
    and PKCS#8, respectively.
    Defaults to ``PKCS1`` if not specified.

    :default: PKCS1` if not specified.

    :schema: CertificateSpecPrivateKeyEncoding
    '''

    PKCS1 = "PKCS1"
    '''PKCS1.'''
    PKCS8 = "PKCS8"
    '''PKCS8.'''


@jsii.enum(jsii_type="iocert-manager.CertificateSpecPrivateKeyRotationPolicy")
class CertificateSpecPrivateKeyRotationPolicy(enum.Enum):
    '''RotationPolicy controls how private keys should be regenerated when a re-issuance is being processed.

    If set to ``Never``, a private key will only be generated if one does not
    already exist in the target ``spec.secretName``. If one does exist but it
    does not have the correct algorithm or size, a warning will be raised
    to await user intervention.
    If set to ``Always``, a private key matching the specified requirements
    will be generated whenever a re-issuance occurs.
    Default is ``Never`` for backward compatibility.

    :default: Never` for backward compatibility.

    :schema: CertificateSpecPrivateKeyRotationPolicy
    '''

    NEVER = "NEVER"
    '''Never.'''
    ALWAYS = "ALWAYS"
    '''Always.'''


@jsii.data_type(
    jsii_type="iocert-manager.CertificateSpecSecretTemplate",
    jsii_struct_bases=[],
    name_mapping={"annotations": "annotations", "labels": "labels"},
)
class CertificateSpecSecretTemplate:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Defines annotations and labels to be copied to the Certificate's Secret.

        Labels and annotations on the Secret will be changed as they appear on the
        SecretTemplate when added or removed. SecretTemplate annotations are added
        in conjunction with, and cannot overwrite, the base set of annotations
        cert-manager sets on the Certificate's Secret.

        :param annotations: Annotations is a key value map to be copied to the target Kubernetes Secret.
        :param labels: Labels is a key value map to be copied to the target Kubernetes Secret.

        :schema: CertificateSpecSecretTemplate
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7ae029c4b2099b6a6b000305048c978f265745e3d7c8a735bb3430f37562f6e)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Annotations is a key value map to be copied to the target Kubernetes Secret.

        :schema: CertificateSpecSecretTemplate#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Labels is a key value map to be copied to the target Kubernetes Secret.

        :schema: CertificateSpecSecretTemplate#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateSpecSecretTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.CertificateSpecSubject",
    jsii_struct_bases=[],
    name_mapping={
        "countries": "countries",
        "localities": "localities",
        "organizational_units": "organizationalUnits",
        "organizations": "organizations",
        "postal_codes": "postalCodes",
        "provinces": "provinces",
        "serial_number": "serialNumber",
        "street_addresses": "streetAddresses",
    },
)
class CertificateSpecSubject:
    def __init__(
        self,
        *,
        countries: typing.Optional[typing.Sequence[builtins.str]] = None,
        localities: typing.Optional[typing.Sequence[builtins.str]] = None,
        organizational_units: typing.Optional[typing.Sequence[builtins.str]] = None,
        organizations: typing.Optional[typing.Sequence[builtins.str]] = None,
        postal_codes: typing.Optional[typing.Sequence[builtins.str]] = None,
        provinces: typing.Optional[typing.Sequence[builtins.str]] = None,
        serial_number: typing.Optional[builtins.str] = None,
        street_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Requested set of X509 certificate subject attributes. More info: https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.6.

        The common name attribute is specified separately in the ``commonName`` field.
        Cannot be set if the ``literalSubject`` field is set.

        :param countries: Countries to be used on the Certificate.
        :param localities: Cities to be used on the Certificate.
        :param organizational_units: Organizational Units to be used on the Certificate.
        :param organizations: Organizations to be used on the Certificate.
        :param postal_codes: Postal codes to be used on the Certificate.
        :param provinces: State/Provinces to be used on the Certificate.
        :param serial_number: Serial number to be used on the Certificate.
        :param street_addresses: Street addresses to be used on the Certificate.

        :schema: CertificateSpecSubject
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c09209f0eeb0075bd242146e02938c5900db62860f11fdd3da07883247f6a4de)
            check_type(argname="argument countries", value=countries, expected_type=type_hints["countries"])
            check_type(argname="argument localities", value=localities, expected_type=type_hints["localities"])
            check_type(argname="argument organizational_units", value=organizational_units, expected_type=type_hints["organizational_units"])
            check_type(argname="argument organizations", value=organizations, expected_type=type_hints["organizations"])
            check_type(argname="argument postal_codes", value=postal_codes, expected_type=type_hints["postal_codes"])
            check_type(argname="argument provinces", value=provinces, expected_type=type_hints["provinces"])
            check_type(argname="argument serial_number", value=serial_number, expected_type=type_hints["serial_number"])
            check_type(argname="argument street_addresses", value=street_addresses, expected_type=type_hints["street_addresses"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if countries is not None:
            self._values["countries"] = countries
        if localities is not None:
            self._values["localities"] = localities
        if organizational_units is not None:
            self._values["organizational_units"] = organizational_units
        if organizations is not None:
            self._values["organizations"] = organizations
        if postal_codes is not None:
            self._values["postal_codes"] = postal_codes
        if provinces is not None:
            self._values["provinces"] = provinces
        if serial_number is not None:
            self._values["serial_number"] = serial_number
        if street_addresses is not None:
            self._values["street_addresses"] = street_addresses

    @builtins.property
    def countries(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Countries to be used on the Certificate.

        :schema: CertificateSpecSubject#countries
        '''
        result = self._values.get("countries")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def localities(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Cities to be used on the Certificate.

        :schema: CertificateSpecSubject#localities
        '''
        result = self._values.get("localities")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def organizational_units(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Organizational Units to be used on the Certificate.

        :schema: CertificateSpecSubject#organizationalUnits
        '''
        result = self._values.get("organizational_units")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def organizations(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Organizations to be used on the Certificate.

        :schema: CertificateSpecSubject#organizations
        '''
        result = self._values.get("organizations")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def postal_codes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Postal codes to be used on the Certificate.

        :schema: CertificateSpecSubject#postalCodes
        '''
        result = self._values.get("postal_codes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def provinces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''State/Provinces to be used on the Certificate.

        :schema: CertificateSpecSubject#provinces
        '''
        result = self._values.get("provinces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def serial_number(self) -> typing.Optional[builtins.str]:
        '''Serial number to be used on the Certificate.

        :schema: CertificateSpecSubject#serialNumber
        '''
        result = self._values.get("serial_number")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def street_addresses(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Street addresses to be used on the Certificate.

        :schema: CertificateSpecSubject#streetAddresses
        '''
        result = self._values.get("street_addresses")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateSpecSubject(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="iocert-manager.CertificateSpecUsages")
class CertificateSpecUsages(enum.Enum):
    '''KeyUsage specifies valid usage contexts for keys. See: https://tools.ietf.org/html/rfc5280#section-4.2.1.3 https://tools.ietf.org/html/rfc5280#section-4.2.1.12.

    Valid KeyUsage values are as follows:
    "signing",
    "digital signature",
    "content commitment",
    "key encipherment",
    "key agreement",
    "data encipherment",
    "cert sign",
    "crl sign",
    "encipher only",
    "decipher only",
    "any",
    "server auth",
    "client auth",
    "code signing",
    "email protection",
    "s/mime",
    "ipsec end system",
    "ipsec tunnel",
    "ipsec user",
    "timestamping",
    "ocsp signing",
    "microsoft sgc",
    "netscape sgc"

    :schema: CertificateSpecUsages
    '''

    SIGNING = "SIGNING"
    '''signing.'''
    DIGITAL_SIGNATURE = "DIGITAL_SIGNATURE"
    '''digital signature.'''
    CONTENT_COMMITMENT = "CONTENT_COMMITMENT"
    '''content commitment.'''
    KEY_ENCIPHERMENT = "KEY_ENCIPHERMENT"
    '''key encipherment.'''
    KEY_AGREEMENT = "KEY_AGREEMENT"
    '''key agreement.'''
    DATA_ENCIPHERMENT = "DATA_ENCIPHERMENT"
    '''data encipherment.'''
    CERT_SIGN = "CERT_SIGN"
    '''cert sign.'''
    CRL_SIGN = "CRL_SIGN"
    '''crl sign.'''
    ENCIPHER_ONLY = "ENCIPHER_ONLY"
    '''encipher only.'''
    DECIPHER_ONLY = "DECIPHER_ONLY"
    '''decipher only.'''
    ANY = "ANY"
    '''any.'''
    SERVER_AUTH = "SERVER_AUTH"
    '''server auth.'''
    CLIENT_AUTH = "CLIENT_AUTH"
    '''client auth.'''
    CODE_SIGNING = "CODE_SIGNING"
    '''code signing.'''
    EMAIL_PROTECTION = "EMAIL_PROTECTION"
    '''email protection.'''
    S_FORWARD_SLASH_MIME = "S_FORWARD_SLASH_MIME"
    '''s/mime.'''
    IPSEC_END_SYSTEM = "IPSEC_END_SYSTEM"
    '''ipsec end system.'''
    IPSEC_TUNNEL = "IPSEC_TUNNEL"
    '''ipsec tunnel.'''
    IPSEC_USER = "IPSEC_USER"
    '''ipsec user.'''
    TIMESTAMPING = "TIMESTAMPING"
    '''timestamping.'''
    OCSP_SIGNING = "OCSP_SIGNING"
    '''ocsp signing.'''
    MICROSOFT_SGC = "MICROSOFT_SGC"
    '''microsoft sgc.'''
    NETSCAPE_SGC = "NETSCAPE_SGC"
    '''netscape sgc.'''


class ClusterIssuer(
    _cdk8s_d3d9af27.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="iocert-manager.ClusterIssuer",
):
    '''A ClusterIssuer represents a certificate issuing authority which can be referenced as part of ``issuerRef`` fields.

    It is similar to an Issuer, however it is cluster-scoped and therefore can
    be referenced by resources that exist in *any* namespace, not just the same
    namespace as the referent.

    :schema: ClusterIssuer
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        spec: typing.Union["ClusterIssuerSpec", typing.Dict[builtins.str, typing.Any]],
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "ClusterIssuer" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param spec: Desired state of the ClusterIssuer resource.
        :param metadata: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f688143e7d718d47dfa1c6527ed261b298a036dc3e9d79a1ec8589369c8281c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ClusterIssuerProps(spec=spec, metadata=metadata)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        spec: typing.Union["ClusterIssuerSpec", typing.Dict[builtins.str, typing.Any]],
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "ClusterIssuer".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param spec: Desired state of the ClusterIssuer resource.
        :param metadata: 
        '''
        props = ClusterIssuerProps(spec=spec, metadata=metadata)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> _cdk8s_d3d9af27.GroupVersionKind:
        '''Returns the apiVersion and kind for "ClusterIssuer".'''
        return typing.cast(_cdk8s_d3d9af27.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerProps",
    jsii_struct_bases=[],
    name_mapping={"spec": "spec", "metadata": "metadata"},
)
class ClusterIssuerProps:
    def __init__(
        self,
        *,
        spec: typing.Union["ClusterIssuerSpec", typing.Dict[builtins.str, typing.Any]],
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''A ClusterIssuer represents a certificate issuing authority which can be referenced as part of ``issuerRef`` fields.

        It is similar to an Issuer, however it is cluster-scoped and therefore can
        be referenced by resources that exist in *any* namespace, not just the same
        namespace as the referent.

        :param spec: Desired state of the ClusterIssuer resource.
        :param metadata: 

        :schema: ClusterIssuer
        '''
        if isinstance(spec, dict):
            spec = ClusterIssuerSpec(**spec)
        if isinstance(metadata, dict):
            metadata = _cdk8s_d3d9af27.ApiObjectMetadata(**metadata)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__56b0a5615b6f6e250fd651727f2e68a527c0065c23fb695154f60a5def2d3919)
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "spec": spec,
        }
        if metadata is not None:
            self._values["metadata"] = metadata

    @builtins.property
    def spec(self) -> "ClusterIssuerSpec":
        '''Desired state of the ClusterIssuer resource.

        :schema: ClusterIssuer#spec
        '''
        result = self._values.get("spec")
        assert result is not None, "Required property 'spec' is missing"
        return typing.cast("ClusterIssuerSpec", result)

    @builtins.property
    def metadata(self) -> typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata]:
        '''
        :schema: ClusterIssuer#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpec",
    jsii_struct_bases=[],
    name_mapping={
        "acme": "acme",
        "ca": "ca",
        "self_signed": "selfSigned",
        "vault": "vault",
        "venafi": "venafi",
    },
)
class ClusterIssuerSpec:
    def __init__(
        self,
        *,
        acme: typing.Optional[typing.Union["ClusterIssuerSpecAcme", typing.Dict[builtins.str, typing.Any]]] = None,
        ca: typing.Optional[typing.Union["ClusterIssuerSpecCa", typing.Dict[builtins.str, typing.Any]]] = None,
        self_signed: typing.Optional[typing.Union["ClusterIssuerSpecSelfSigned", typing.Dict[builtins.str, typing.Any]]] = None,
        vault: typing.Optional[typing.Union["ClusterIssuerSpecVault", typing.Dict[builtins.str, typing.Any]]] = None,
        venafi: typing.Optional[typing.Union["ClusterIssuerSpecVenafi", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Desired state of the ClusterIssuer resource.

        :param acme: ACME configures this issuer to communicate with a RFC8555 (ACME) server to obtain signed x509 certificates.
        :param ca: CA configures this issuer to sign certificates using a signing CA keypair stored in a Secret resource. This is used to build internal PKIs that are managed by cert-manager.
        :param self_signed: SelfSigned configures this issuer to 'self sign' certificates using the private key used to create the CertificateRequest object.
        :param vault: Vault configures this issuer to sign certificates using a HashiCorp Vault PKI backend.
        :param venafi: Venafi configures this issuer to sign certificates using a Venafi TPP or Venafi Cloud policy zone.

        :schema: ClusterIssuerSpec
        '''
        if isinstance(acme, dict):
            acme = ClusterIssuerSpecAcme(**acme)
        if isinstance(ca, dict):
            ca = ClusterIssuerSpecCa(**ca)
        if isinstance(self_signed, dict):
            self_signed = ClusterIssuerSpecSelfSigned(**self_signed)
        if isinstance(vault, dict):
            vault = ClusterIssuerSpecVault(**vault)
        if isinstance(venafi, dict):
            venafi = ClusterIssuerSpecVenafi(**venafi)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc77bf1e9be3506aa9d0d03ab0aa9d5dfb37f8ecea565109f44e6b9bc2380ac1)
            check_type(argname="argument acme", value=acme, expected_type=type_hints["acme"])
            check_type(argname="argument ca", value=ca, expected_type=type_hints["ca"])
            check_type(argname="argument self_signed", value=self_signed, expected_type=type_hints["self_signed"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument venafi", value=venafi, expected_type=type_hints["venafi"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if acme is not None:
            self._values["acme"] = acme
        if ca is not None:
            self._values["ca"] = ca
        if self_signed is not None:
            self._values["self_signed"] = self_signed
        if vault is not None:
            self._values["vault"] = vault
        if venafi is not None:
            self._values["venafi"] = venafi

    @builtins.property
    def acme(self) -> typing.Optional["ClusterIssuerSpecAcme"]:
        '''ACME configures this issuer to communicate with a RFC8555 (ACME) server to obtain signed x509 certificates.

        :schema: ClusterIssuerSpec#acme
        '''
        result = self._values.get("acme")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcme"], result)

    @builtins.property
    def ca(self) -> typing.Optional["ClusterIssuerSpecCa"]:
        '''CA configures this issuer to sign certificates using a signing CA keypair stored in a Secret resource.

        This is used to build internal PKIs that are managed by cert-manager.

        :schema: ClusterIssuerSpec#ca
        '''
        result = self._values.get("ca")
        return typing.cast(typing.Optional["ClusterIssuerSpecCa"], result)

    @builtins.property
    def self_signed(self) -> typing.Optional["ClusterIssuerSpecSelfSigned"]:
        '''SelfSigned configures this issuer to 'self sign' certificates using the private key used to create the CertificateRequest object.

        :schema: ClusterIssuerSpec#selfSigned
        '''
        result = self._values.get("self_signed")
        return typing.cast(typing.Optional["ClusterIssuerSpecSelfSigned"], result)

    @builtins.property
    def vault(self) -> typing.Optional["ClusterIssuerSpecVault"]:
        '''Vault configures this issuer to sign certificates using a HashiCorp Vault PKI backend.

        :schema: ClusterIssuerSpec#vault
        '''
        result = self._values.get("vault")
        return typing.cast(typing.Optional["ClusterIssuerSpecVault"], result)

    @builtins.property
    def venafi(self) -> typing.Optional["ClusterIssuerSpecVenafi"]:
        '''Venafi configures this issuer to sign certificates using a Venafi TPP or Venafi Cloud policy zone.

        :schema: ClusterIssuerSpec#venafi
        '''
        result = self._values.get("venafi")
        return typing.cast(typing.Optional["ClusterIssuerSpecVenafi"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcme",
    jsii_struct_bases=[],
    name_mapping={
        "private_key_secret_ref": "privateKeySecretRef",
        "server": "server",
        "ca_bundle": "caBundle",
        "disable_account_key_generation": "disableAccountKeyGeneration",
        "email": "email",
        "enable_duration_feature": "enableDurationFeature",
        "external_account_binding": "externalAccountBinding",
        "preferred_chain": "preferredChain",
        "skip_tls_verify": "skipTlsVerify",
        "solvers": "solvers",
    },
)
class ClusterIssuerSpecAcme:
    def __init__(
        self,
        *,
        private_key_secret_ref: typing.Union["ClusterIssuerSpecAcmePrivateKeySecretRef", typing.Dict[builtins.str, typing.Any]],
        server: builtins.str,
        ca_bundle: typing.Optional[builtins.str] = None,
        disable_account_key_generation: typing.Optional[builtins.bool] = None,
        email: typing.Optional[builtins.str] = None,
        enable_duration_feature: typing.Optional[builtins.bool] = None,
        external_account_binding: typing.Optional[typing.Union["ClusterIssuerSpecAcmeExternalAccountBinding", typing.Dict[builtins.str, typing.Any]]] = None,
        preferred_chain: typing.Optional[builtins.str] = None,
        skip_tls_verify: typing.Optional[builtins.bool] = None,
        solvers: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolvers", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''ACME configures this issuer to communicate with a RFC8555 (ACME) server to obtain signed x509 certificates.

        :param private_key_secret_ref: PrivateKey is the name of a Kubernetes Secret resource that will be used to store the automatically generated ACME account private key. Optionally, a ``key`` may be specified to select a specific entry within the named Secret resource. If ``key`` is not specified, a default of ``tls.key`` will be used.
        :param server: Server is the URL used to access the ACME server's 'directory' endpoint. For example, for Let's Encrypt's staging endpoint, you would use: "https://acme-staging-v02.api.letsencrypt.org/directory". Only ACME v2 endpoints (i.e. RFC 8555) are supported.
        :param ca_bundle: Base64-encoded bundle of PEM CAs which can be used to validate the certificate chain presented by the ACME server. Mutually exclusive with SkipTLSVerify; prefer using CABundle to prevent various kinds of security vulnerabilities. If CABundle and SkipTLSVerify are unset, the system certificate bundle inside the container is used to validate the TLS connection.
        :param disable_account_key_generation: Enables or disables generating a new ACME account key. If true, the Issuer resource will *not* request a new account but will expect the account key to be supplied via an existing secret. If false, the cert-manager system will generate a new ACME account key for the Issuer. Defaults to false. Default: false.
        :param email: Email is the email address to be associated with the ACME account. This field is optional, but it is strongly recommended to be set. It will be used to contact you in case of issues with your account or certificates, including expiry notification emails. This field may be updated after the account is initially registered.
        :param enable_duration_feature: Enables requesting a Not After date on certificates that matches the duration of the certificate. This is not supported by all ACME servers like Let's Encrypt. If set to true when the ACME server does not support it, it will create an error on the Order. Defaults to false. Default: false.
        :param external_account_binding: ExternalAccountBinding is a reference to a CA external account of the ACME server. If set, upon registration cert-manager will attempt to associate the given external account credentials with the registered ACME account.
        :param preferred_chain: PreferredChain is the chain to use if the ACME server outputs multiple. PreferredChain is no guarantee that this one gets delivered by the ACME endpoint. For example, for Let's Encrypt's DST crosssign you would use: "DST Root CA X3" or "ISRG Root X1" for the newer Let's Encrypt root CA. This value picks the first certificate bundle in the combined set of ACME default and alternative chains that has a root-most certificate with this value as its issuer's commonname.
        :param skip_tls_verify: INSECURE: Enables or disables validation of the ACME server TLS certificate. If true, requests to the ACME server will not have the TLS certificate chain validated. Mutually exclusive with CABundle; prefer using CABundle to prevent various kinds of security vulnerabilities. Only enable this option in development environments. If CABundle and SkipTLSVerify are unset, the system certificate bundle inside the container is used to validate the TLS connection. Defaults to false. Default: false.
        :param solvers: Solvers is a list of challenge solvers that will be used to solve ACME challenges for the matching domains. Solver configurations must be provided in order to obtain certificates from an ACME server. For more information, see: https://cert-manager.io/docs/configuration/acme/

        :schema: ClusterIssuerSpecAcme
        '''
        if isinstance(private_key_secret_ref, dict):
            private_key_secret_ref = ClusterIssuerSpecAcmePrivateKeySecretRef(**private_key_secret_ref)
        if isinstance(external_account_binding, dict):
            external_account_binding = ClusterIssuerSpecAcmeExternalAccountBinding(**external_account_binding)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9bb6e0ab2b3fc65f4af6e791c031975f3e851e7b4b71e657cfd39b48d5e56471)
            check_type(argname="argument private_key_secret_ref", value=private_key_secret_ref, expected_type=type_hints["private_key_secret_ref"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument disable_account_key_generation", value=disable_account_key_generation, expected_type=type_hints["disable_account_key_generation"])
            check_type(argname="argument email", value=email, expected_type=type_hints["email"])
            check_type(argname="argument enable_duration_feature", value=enable_duration_feature, expected_type=type_hints["enable_duration_feature"])
            check_type(argname="argument external_account_binding", value=external_account_binding, expected_type=type_hints["external_account_binding"])
            check_type(argname="argument preferred_chain", value=preferred_chain, expected_type=type_hints["preferred_chain"])
            check_type(argname="argument skip_tls_verify", value=skip_tls_verify, expected_type=type_hints["skip_tls_verify"])
            check_type(argname="argument solvers", value=solvers, expected_type=type_hints["solvers"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "private_key_secret_ref": private_key_secret_ref,
            "server": server,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if disable_account_key_generation is not None:
            self._values["disable_account_key_generation"] = disable_account_key_generation
        if email is not None:
            self._values["email"] = email
        if enable_duration_feature is not None:
            self._values["enable_duration_feature"] = enable_duration_feature
        if external_account_binding is not None:
            self._values["external_account_binding"] = external_account_binding
        if preferred_chain is not None:
            self._values["preferred_chain"] = preferred_chain
        if skip_tls_verify is not None:
            self._values["skip_tls_verify"] = skip_tls_verify
        if solvers is not None:
            self._values["solvers"] = solvers

    @builtins.property
    def private_key_secret_ref(self) -> "ClusterIssuerSpecAcmePrivateKeySecretRef":
        '''PrivateKey is the name of a Kubernetes Secret resource that will be used to store the automatically generated ACME account private key.

        Optionally, a ``key`` may be specified to select a specific entry within
        the named Secret resource.
        If ``key`` is not specified, a default of ``tls.key`` will be used.

        :schema: ClusterIssuerSpecAcme#privateKeySecretRef
        '''
        result = self._values.get("private_key_secret_ref")
        assert result is not None, "Required property 'private_key_secret_ref' is missing"
        return typing.cast("ClusterIssuerSpecAcmePrivateKeySecretRef", result)

    @builtins.property
    def server(self) -> builtins.str:
        '''Server is the URL used to access the ACME server's 'directory' endpoint.

        For example, for Let's Encrypt's staging endpoint, you would use:
        "https://acme-staging-v02.api.letsencrypt.org/directory".
        Only ACME v2 endpoints (i.e. RFC 8555) are supported.

        :schema: ClusterIssuerSpecAcme#server
        '''
        result = self._values.get("server")
        assert result is not None, "Required property 'server' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''Base64-encoded bundle of PEM CAs which can be used to validate the certificate chain presented by the ACME server.

        Mutually exclusive with SkipTLSVerify; prefer using CABundle to prevent various
        kinds of security vulnerabilities.
        If CABundle and SkipTLSVerify are unset, the system certificate bundle inside
        the container is used to validate the TLS connection.

        :schema: ClusterIssuerSpecAcme#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def disable_account_key_generation(self) -> typing.Optional[builtins.bool]:
        '''Enables or disables generating a new ACME account key.

        If true, the Issuer resource will *not* request a new account but will expect
        the account key to be supplied via an existing secret.
        If false, the cert-manager system will generate a new ACME account key
        for the Issuer.
        Defaults to false.

        :default: false.

        :schema: ClusterIssuerSpecAcme#disableAccountKeyGeneration
        '''
        result = self._values.get("disable_account_key_generation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def email(self) -> typing.Optional[builtins.str]:
        '''Email is the email address to be associated with the ACME account.

        This field is optional, but it is strongly recommended to be set.
        It will be used to contact you in case of issues with your account or
        certificates, including expiry notification emails.
        This field may be updated after the account is initially registered.

        :schema: ClusterIssuerSpecAcme#email
        '''
        result = self._values.get("email")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_duration_feature(self) -> typing.Optional[builtins.bool]:
        '''Enables requesting a Not After date on certificates that matches the duration of the certificate.

        This is not supported by all ACME servers
        like Let's Encrypt. If set to true when the ACME server does not support
        it, it will create an error on the Order.
        Defaults to false.

        :default: false.

        :schema: ClusterIssuerSpecAcme#enableDurationFeature
        '''
        result = self._values.get("enable_duration_feature")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def external_account_binding(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeExternalAccountBinding"]:
        '''ExternalAccountBinding is a reference to a CA external account of the ACME server.

        If set, upon registration cert-manager will attempt to associate the given
        external account credentials with the registered ACME account.

        :schema: ClusterIssuerSpecAcme#externalAccountBinding
        '''
        result = self._values.get("external_account_binding")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeExternalAccountBinding"], result)

    @builtins.property
    def preferred_chain(self) -> typing.Optional[builtins.str]:
        '''PreferredChain is the chain to use if the ACME server outputs multiple.

        PreferredChain is no guarantee that this one gets delivered by the ACME
        endpoint.
        For example, for Let's Encrypt's DST crosssign you would use:
        "DST Root CA X3" or "ISRG Root X1" for the newer Let's Encrypt root CA.
        This value picks the first certificate bundle in the combined set of
        ACME default and alternative chains that has a root-most certificate with
        this value as its issuer's commonname.

        :schema: ClusterIssuerSpecAcme#preferredChain
        '''
        result = self._values.get("preferred_chain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def skip_tls_verify(self) -> typing.Optional[builtins.bool]:
        '''INSECURE: Enables or disables validation of the ACME server TLS certificate.

        If true, requests to the ACME server will not have the TLS certificate chain
        validated.
        Mutually exclusive with CABundle; prefer using CABundle to prevent various
        kinds of security vulnerabilities.
        Only enable this option in development environments.
        If CABundle and SkipTLSVerify are unset, the system certificate bundle inside
        the container is used to validate the TLS connection.
        Defaults to false.

        :default: false.

        :schema: ClusterIssuerSpecAcme#skipTLSVerify
        '''
        result = self._values.get("skip_tls_verify")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def solvers(self) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolvers"]]:
        '''Solvers is a list of challenge solvers that will be used to solve ACME challenges for the matching domains.

        Solver configurations must be provided in order to obtain certificates
        from an ACME server.
        For more information, see: https://cert-manager.io/docs/configuration/acme/

        :schema: ClusterIssuerSpecAcme#solvers
        '''
        result = self._values.get("solvers")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolvers"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcme(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeExternalAccountBinding",
    jsii_struct_bases=[],
    name_mapping={
        "key_id": "keyId",
        "key_secret_ref": "keySecretRef",
        "key_algorithm": "keyAlgorithm",
    },
)
class ClusterIssuerSpecAcmeExternalAccountBinding:
    def __init__(
        self,
        *,
        key_id: builtins.str,
        key_secret_ref: typing.Union["ClusterIssuerSpecAcmeExternalAccountBindingKeySecretRef", typing.Dict[builtins.str, typing.Any]],
        key_algorithm: typing.Optional["ClusterIssuerSpecAcmeExternalAccountBindingKeyAlgorithm"] = None,
    ) -> None:
        '''ExternalAccountBinding is a reference to a CA external account of the ACME server.

        If set, upon registration cert-manager will attempt to associate the given
        external account credentials with the registered ACME account.

        :param key_id: keyID is the ID of the CA key that the External Account is bound to.
        :param key_secret_ref: keySecretRef is a Secret Key Selector referencing a data item in a Kubernetes Secret which holds the symmetric MAC key of the External Account Binding. The ``key`` is the index string that is paired with the key data in the Secret and should not be confused with the key data itself, or indeed with the External Account Binding keyID above. The secret key stored in the Secret **must** be un-padded, base64 URL encoded data.
        :param key_algorithm: Deprecated: keyAlgorithm field exists for historical compatibility reasons and should not be used. The algorithm is now hardcoded to HS256 in golang/x/crypto/acme.

        :schema: ClusterIssuerSpecAcmeExternalAccountBinding
        '''
        if isinstance(key_secret_ref, dict):
            key_secret_ref = ClusterIssuerSpecAcmeExternalAccountBindingKeySecretRef(**key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e2935c6f1a7d45dfda458b5e86889b8ad9343015a3529a6f2cec671ca66beb3)
            check_type(argname="argument key_id", value=key_id, expected_type=type_hints["key_id"])
            check_type(argname="argument key_secret_ref", value=key_secret_ref, expected_type=type_hints["key_secret_ref"])
            check_type(argname="argument key_algorithm", value=key_algorithm, expected_type=type_hints["key_algorithm"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key_id": key_id,
            "key_secret_ref": key_secret_ref,
        }
        if key_algorithm is not None:
            self._values["key_algorithm"] = key_algorithm

    @builtins.property
    def key_id(self) -> builtins.str:
        '''keyID is the ID of the CA key that the External Account is bound to.

        :schema: ClusterIssuerSpecAcmeExternalAccountBinding#keyID
        '''
        result = self._values.get("key_id")
        assert result is not None, "Required property 'key_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key_secret_ref(
        self,
    ) -> "ClusterIssuerSpecAcmeExternalAccountBindingKeySecretRef":
        '''keySecretRef is a Secret Key Selector referencing a data item in a Kubernetes Secret which holds the symmetric MAC key of the External Account Binding.

        The ``key`` is the index string that is paired with the key data in the
        Secret and should not be confused with the key data itself, or indeed with
        the External Account Binding keyID above.
        The secret key stored in the Secret **must** be un-padded, base64 URL
        encoded data.

        :schema: ClusterIssuerSpecAcmeExternalAccountBinding#keySecretRef
        '''
        result = self._values.get("key_secret_ref")
        assert result is not None, "Required property 'key_secret_ref' is missing"
        return typing.cast("ClusterIssuerSpecAcmeExternalAccountBindingKeySecretRef", result)

    @builtins.property
    def key_algorithm(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeExternalAccountBindingKeyAlgorithm"]:
        '''Deprecated: keyAlgorithm field exists for historical compatibility reasons and should not be used.

        The algorithm is now hardcoded to HS256
        in golang/x/crypto/acme.

        :schema: ClusterIssuerSpecAcmeExternalAccountBinding#keyAlgorithm
        '''
        result = self._values.get("key_algorithm")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeExternalAccountBindingKeyAlgorithm"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeExternalAccountBinding(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeExternalAccountBindingKeyAlgorithm"
)
class ClusterIssuerSpecAcmeExternalAccountBindingKeyAlgorithm(enum.Enum):
    '''Deprecated: keyAlgorithm field exists for historical compatibility reasons and should not be used.

    The algorithm is now hardcoded to HS256
    in golang/x/crypto/acme.

    :schema: ClusterIssuerSpecAcmeExternalAccountBindingKeyAlgorithm
    '''

    HS256 = "HS256"
    '''HS256.'''
    HS384 = "HS384"
    '''HS384.'''
    HS512 = "HS512"
    '''HS512.'''


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeExternalAccountBindingKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecAcmeExternalAccountBindingKeySecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''keySecretRef is a Secret Key Selector referencing a data item in a Kubernetes Secret which holds the symmetric MAC key of the External Account Binding.

        The ``key`` is the index string that is paired with the key data in the
        Secret and should not be confused with the key data itself, or indeed with
        the External Account Binding keyID above.
        The secret key stored in the Secret **must** be un-padded, base64 URL
        encoded data.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecAcmeExternalAccountBindingKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f4e4626d5ac0262d944f0cb16d60ac10e6ac0e5d814aa66216e4f964f609f578)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmeExternalAccountBindingKeySecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecAcmeExternalAccountBindingKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeExternalAccountBindingKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmePrivateKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecAcmePrivateKeySecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''PrivateKey is the name of a Kubernetes Secret resource that will be used to store the automatically generated ACME account private key.

        Optionally, a ``key`` may be specified to select a specific entry within
        the named Secret resource.
        If ``key`` is not specified, a default of ``tls.key`` will be used.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecAcmePrivateKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3974e1faf8d29117a715c76c5e5c381d217a8d161627837b76f459c9a16e5088)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmePrivateKeySecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecAcmePrivateKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmePrivateKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolvers",
    jsii_struct_bases=[],
    name_mapping={"dns01": "dns01", "http01": "http01", "selector": "selector"},
)
class ClusterIssuerSpecAcmeSolvers:
    def __init__(
        self,
        *,
        dns01: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01", typing.Dict[builtins.str, typing.Any]]] = None,
        http01: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01", typing.Dict[builtins.str, typing.Any]]] = None,
        selector: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''An ACMEChallengeSolver describes how to solve ACME challenges for the issuer it is part of.

        A selector may be provided to use different solving strategies for different DNS names.
        Only one of HTTP01 or DNS01 must be provided.

        :param dns01: Configures cert-manager to attempt to complete authorizations by performing the DNS01 challenge flow.
        :param http01: Configures cert-manager to attempt to complete authorizations by performing the HTTP01 challenge flow. It is not possible to obtain certificates for wildcard domain names (e.g. ``*.example.com``) using the HTTP01 challenge mechanism.
        :param selector: Selector selects a set of DNSNames on the Certificate resource that should be solved using this challenge solver. If not specified, the solver will be treated as the 'default' solver with the lowest priority, i.e. if any other solver has a more specific match, it will be used instead.

        :schema: ClusterIssuerSpecAcmeSolvers
        '''
        if isinstance(dns01, dict):
            dns01 = ClusterIssuerSpecAcmeSolversDns01(**dns01)
        if isinstance(http01, dict):
            http01 = ClusterIssuerSpecAcmeSolversHttp01(**http01)
        if isinstance(selector, dict):
            selector = ClusterIssuerSpecAcmeSolversSelector(**selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc060c86c0f89fe7498815c4eb86864460951b48da15e9c8dc8f95452ea54dd4)
            check_type(argname="argument dns01", value=dns01, expected_type=type_hints["dns01"])
            check_type(argname="argument http01", value=http01, expected_type=type_hints["http01"])
            check_type(argname="argument selector", value=selector, expected_type=type_hints["selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dns01 is not None:
            self._values["dns01"] = dns01
        if http01 is not None:
            self._values["http01"] = http01
        if selector is not None:
            self._values["selector"] = selector

    @builtins.property
    def dns01(self) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01"]:
        '''Configures cert-manager to attempt to complete authorizations by performing the DNS01 challenge flow.

        :schema: ClusterIssuerSpecAcmeSolvers#dns01
        '''
        result = self._values.get("dns01")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01"], result)

    @builtins.property
    def http01(self) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01"]:
        '''Configures cert-manager to attempt to complete authorizations by performing the HTTP01 challenge flow.

        It is not possible to obtain certificates for wildcard domain names
        (e.g. ``*.example.com``) using the HTTP01 challenge mechanism.

        :schema: ClusterIssuerSpecAcmeSolvers#http01
        '''
        result = self._values.get("http01")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01"], result)

    @builtins.property
    def selector(self) -> typing.Optional["ClusterIssuerSpecAcmeSolversSelector"]:
        '''Selector selects a set of DNSNames on the Certificate resource that should be solved using this challenge solver.

        If not specified, the solver will be treated as the 'default' solver
        with the lowest priority, i.e. if any other solver has a more specific
        match, it will be used instead.

        :schema: ClusterIssuerSpecAcmeSolvers#selector
        '''
        result = self._values.get("selector")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolvers(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01",
    jsii_struct_bases=[],
    name_mapping={
        "acme_dns": "acmeDns",
        "akamai": "akamai",
        "azure_dns": "azureDns",
        "cloud_dns": "cloudDns",
        "cloudflare": "cloudflare",
        "cname_strategy": "cnameStrategy",
        "digitalocean": "digitalocean",
        "rfc2136": "rfc2136",
        "route53": "route53",
        "webhook": "webhook",
    },
)
class ClusterIssuerSpecAcmeSolversDns01:
    def __init__(
        self,
        *,
        acme_dns: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01AcmeDns", typing.Dict[builtins.str, typing.Any]]] = None,
        akamai: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01Akamai", typing.Dict[builtins.str, typing.Any]]] = None,
        azure_dns: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01AzureDns", typing.Dict[builtins.str, typing.Any]]] = None,
        cloud_dns: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01CloudDns", typing.Dict[builtins.str, typing.Any]]] = None,
        cloudflare: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01Cloudflare", typing.Dict[builtins.str, typing.Any]]] = None,
        cname_strategy: typing.Optional["ClusterIssuerSpecAcmeSolversDns01CnameStrategy"] = None,
        digitalocean: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01Digitalocean", typing.Dict[builtins.str, typing.Any]]] = None,
        rfc2136: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01Rfc2136", typing.Dict[builtins.str, typing.Any]]] = None,
        route53: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01Route53", typing.Dict[builtins.str, typing.Any]]] = None,
        webhook: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01Webhook", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Configures cert-manager to attempt to complete authorizations by performing the DNS01 challenge flow.

        :param acme_dns: Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage DNS01 challenge records.
        :param akamai: Use the Akamai DNS zone management API to manage DNS01 challenge records.
        :param azure_dns: Use the Microsoft Azure DNS API to manage DNS01 challenge records.
        :param cloud_dns: Use the Google Cloud DNS API to manage DNS01 challenge records.
        :param cloudflare: Use the Cloudflare API to manage DNS01 challenge records.
        :param cname_strategy: CNAMEStrategy configures how the DNS01 provider should handle CNAME records when found in DNS zones.
        :param digitalocean: Use the DigitalOcean DNS API to manage DNS01 challenge records.
        :param rfc2136: Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/) to manage DNS01 challenge records.
        :param route53: Use the AWS Route53 API to manage DNS01 challenge records.
        :param webhook: Configure an external webhook based DNS01 challenge solver to manage DNS01 challenge records.

        :schema: ClusterIssuerSpecAcmeSolversDns01
        '''
        if isinstance(acme_dns, dict):
            acme_dns = ClusterIssuerSpecAcmeSolversDns01AcmeDns(**acme_dns)
        if isinstance(akamai, dict):
            akamai = ClusterIssuerSpecAcmeSolversDns01Akamai(**akamai)
        if isinstance(azure_dns, dict):
            azure_dns = ClusterIssuerSpecAcmeSolversDns01AzureDns(**azure_dns)
        if isinstance(cloud_dns, dict):
            cloud_dns = ClusterIssuerSpecAcmeSolversDns01CloudDns(**cloud_dns)
        if isinstance(cloudflare, dict):
            cloudflare = ClusterIssuerSpecAcmeSolversDns01Cloudflare(**cloudflare)
        if isinstance(digitalocean, dict):
            digitalocean = ClusterIssuerSpecAcmeSolversDns01Digitalocean(**digitalocean)
        if isinstance(rfc2136, dict):
            rfc2136 = ClusterIssuerSpecAcmeSolversDns01Rfc2136(**rfc2136)
        if isinstance(route53, dict):
            route53 = ClusterIssuerSpecAcmeSolversDns01Route53(**route53)
        if isinstance(webhook, dict):
            webhook = ClusterIssuerSpecAcmeSolversDns01Webhook(**webhook)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b612595a0aa563b9b8554e32cdf5fb945ded1eb683a5df9ea553623395f4d163)
            check_type(argname="argument acme_dns", value=acme_dns, expected_type=type_hints["acme_dns"])
            check_type(argname="argument akamai", value=akamai, expected_type=type_hints["akamai"])
            check_type(argname="argument azure_dns", value=azure_dns, expected_type=type_hints["azure_dns"])
            check_type(argname="argument cloud_dns", value=cloud_dns, expected_type=type_hints["cloud_dns"])
            check_type(argname="argument cloudflare", value=cloudflare, expected_type=type_hints["cloudflare"])
            check_type(argname="argument cname_strategy", value=cname_strategy, expected_type=type_hints["cname_strategy"])
            check_type(argname="argument digitalocean", value=digitalocean, expected_type=type_hints["digitalocean"])
            check_type(argname="argument rfc2136", value=rfc2136, expected_type=type_hints["rfc2136"])
            check_type(argname="argument route53", value=route53, expected_type=type_hints["route53"])
            check_type(argname="argument webhook", value=webhook, expected_type=type_hints["webhook"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if acme_dns is not None:
            self._values["acme_dns"] = acme_dns
        if akamai is not None:
            self._values["akamai"] = akamai
        if azure_dns is not None:
            self._values["azure_dns"] = azure_dns
        if cloud_dns is not None:
            self._values["cloud_dns"] = cloud_dns
        if cloudflare is not None:
            self._values["cloudflare"] = cloudflare
        if cname_strategy is not None:
            self._values["cname_strategy"] = cname_strategy
        if digitalocean is not None:
            self._values["digitalocean"] = digitalocean
        if rfc2136 is not None:
            self._values["rfc2136"] = rfc2136
        if route53 is not None:
            self._values["route53"] = route53
        if webhook is not None:
            self._values["webhook"] = webhook

    @builtins.property
    def acme_dns(self) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01AcmeDns"]:
        '''Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage DNS01 challenge records.

        :schema: ClusterIssuerSpecAcmeSolversDns01#acmeDNS
        '''
        result = self._values.get("acme_dns")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01AcmeDns"], result)

    @builtins.property
    def akamai(self) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01Akamai"]:
        '''Use the Akamai DNS zone management API to manage DNS01 challenge records.

        :schema: ClusterIssuerSpecAcmeSolversDns01#akamai
        '''
        result = self._values.get("akamai")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01Akamai"], result)

    @builtins.property
    def azure_dns(self) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01AzureDns"]:
        '''Use the Microsoft Azure DNS API to manage DNS01 challenge records.

        :schema: ClusterIssuerSpecAcmeSolversDns01#azureDNS
        '''
        result = self._values.get("azure_dns")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01AzureDns"], result)

    @builtins.property
    def cloud_dns(self) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01CloudDns"]:
        '''Use the Google Cloud DNS API to manage DNS01 challenge records.

        :schema: ClusterIssuerSpecAcmeSolversDns01#cloudDNS
        '''
        result = self._values.get("cloud_dns")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01CloudDns"], result)

    @builtins.property
    def cloudflare(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01Cloudflare"]:
        '''Use the Cloudflare API to manage DNS01 challenge records.

        :schema: ClusterIssuerSpecAcmeSolversDns01#cloudflare
        '''
        result = self._values.get("cloudflare")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01Cloudflare"], result)

    @builtins.property
    def cname_strategy(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01CnameStrategy"]:
        '''CNAMEStrategy configures how the DNS01 provider should handle CNAME records when found in DNS zones.

        :schema: ClusterIssuerSpecAcmeSolversDns01#cnameStrategy
        '''
        result = self._values.get("cname_strategy")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01CnameStrategy"], result)

    @builtins.property
    def digitalocean(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01Digitalocean"]:
        '''Use the DigitalOcean DNS API to manage DNS01 challenge records.

        :schema: ClusterIssuerSpecAcmeSolversDns01#digitalocean
        '''
        result = self._values.get("digitalocean")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01Digitalocean"], result)

    @builtins.property
    def rfc2136(self) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01Rfc2136"]:
        '''Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/) to manage DNS01 challenge records.

        :schema: ClusterIssuerSpecAcmeSolversDns01#rfc2136
        '''
        result = self._values.get("rfc2136")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01Rfc2136"], result)

    @builtins.property
    def route53(self) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01Route53"]:
        '''Use the AWS Route53 API to manage DNS01 challenge records.

        :schema: ClusterIssuerSpecAcmeSolversDns01#route53
        '''
        result = self._values.get("route53")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01Route53"], result)

    @builtins.property
    def webhook(self) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01Webhook"]:
        '''Configure an external webhook based DNS01 challenge solver to manage DNS01 challenge records.

        :schema: ClusterIssuerSpecAcmeSolversDns01#webhook
        '''
        result = self._values.get("webhook")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01Webhook"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01AcmeDns",
    jsii_struct_bases=[],
    name_mapping={"account_secret_ref": "accountSecretRef", "host": "host"},
)
class ClusterIssuerSpecAcmeSolversDns01AcmeDns:
    def __init__(
        self,
        *,
        account_secret_ref: typing.Union["ClusterIssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef", typing.Dict[builtins.str, typing.Any]],
        host: builtins.str,
    ) -> None:
        '''Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage DNS01 challenge records.

        :param account_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param host: 

        :schema: ClusterIssuerSpecAcmeSolversDns01AcmeDns
        '''
        if isinstance(account_secret_ref, dict):
            account_secret_ref = ClusterIssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef(**account_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0d637f7d5025dd316376b0849a5b1572a04a70e733195375657333551accdfd0)
            check_type(argname="argument account_secret_ref", value=account_secret_ref, expected_type=type_hints["account_secret_ref"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "account_secret_ref": account_secret_ref,
            "host": host,
        }

    @builtins.property
    def account_secret_ref(
        self,
    ) -> "ClusterIssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterIssuerSpecAcmeSolversDns01AcmeDns#accountSecretRef
        '''
        result = self._values.get("account_secret_ref")
        assert result is not None, "Required property 'account_secret_ref' is missing"
        return typing.cast("ClusterIssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef", result)

    @builtins.property
    def host(self) -> builtins.str:
        '''
        :schema: ClusterIssuerSpecAcmeSolversDns01AcmeDns#host
        '''
        result = self._values.get("host")
        assert result is not None, "Required property 'host' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01AcmeDns(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a451a0f4e97d245fa4bc818bce8fdcacf04d9ed81975e051d9ea5e5122808b8)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01Akamai",
    jsii_struct_bases=[],
    name_mapping={
        "access_token_secret_ref": "accessTokenSecretRef",
        "client_secret_secret_ref": "clientSecretSecretRef",
        "client_token_secret_ref": "clientTokenSecretRef",
        "service_consumer_domain": "serviceConsumerDomain",
    },
)
class ClusterIssuerSpecAcmeSolversDns01Akamai:
    def __init__(
        self,
        *,
        access_token_secret_ref: typing.Union["ClusterIssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef", typing.Dict[builtins.str, typing.Any]],
        client_secret_secret_ref: typing.Union["ClusterIssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef", typing.Dict[builtins.str, typing.Any]],
        client_token_secret_ref: typing.Union["ClusterIssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef", typing.Dict[builtins.str, typing.Any]],
        service_consumer_domain: builtins.str,
    ) -> None:
        '''Use the Akamai DNS zone management API to manage DNS01 challenge records.

        :param access_token_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param client_secret_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param client_token_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param service_consumer_domain: 

        :schema: ClusterIssuerSpecAcmeSolversDns01Akamai
        '''
        if isinstance(access_token_secret_ref, dict):
            access_token_secret_ref = ClusterIssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef(**access_token_secret_ref)
        if isinstance(client_secret_secret_ref, dict):
            client_secret_secret_ref = ClusterIssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef(**client_secret_secret_ref)
        if isinstance(client_token_secret_ref, dict):
            client_token_secret_ref = ClusterIssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef(**client_token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73aff73e5f7753dc89b3dffede8dee52fdb8ef5985cec4685d968bf538f0f25c)
            check_type(argname="argument access_token_secret_ref", value=access_token_secret_ref, expected_type=type_hints["access_token_secret_ref"])
            check_type(argname="argument client_secret_secret_ref", value=client_secret_secret_ref, expected_type=type_hints["client_secret_secret_ref"])
            check_type(argname="argument client_token_secret_ref", value=client_token_secret_ref, expected_type=type_hints["client_token_secret_ref"])
            check_type(argname="argument service_consumer_domain", value=service_consumer_domain, expected_type=type_hints["service_consumer_domain"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "access_token_secret_ref": access_token_secret_ref,
            "client_secret_secret_ref": client_secret_secret_ref,
            "client_token_secret_ref": client_token_secret_ref,
            "service_consumer_domain": service_consumer_domain,
        }

    @builtins.property
    def access_token_secret_ref(
        self,
    ) -> "ClusterIssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterIssuerSpecAcmeSolversDns01Akamai#accessTokenSecretRef
        '''
        result = self._values.get("access_token_secret_ref")
        assert result is not None, "Required property 'access_token_secret_ref' is missing"
        return typing.cast("ClusterIssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef", result)

    @builtins.property
    def client_secret_secret_ref(
        self,
    ) -> "ClusterIssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterIssuerSpecAcmeSolversDns01Akamai#clientSecretSecretRef
        '''
        result = self._values.get("client_secret_secret_ref")
        assert result is not None, "Required property 'client_secret_secret_ref' is missing"
        return typing.cast("ClusterIssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef", result)

    @builtins.property
    def client_token_secret_ref(
        self,
    ) -> "ClusterIssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterIssuerSpecAcmeSolversDns01Akamai#clientTokenSecretRef
        '''
        result = self._values.get("client_token_secret_ref")
        assert result is not None, "Required property 'client_token_secret_ref' is missing"
        return typing.cast("ClusterIssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef", result)

    @builtins.property
    def service_consumer_domain(self) -> builtins.str:
        '''
        :schema: ClusterIssuerSpecAcmeSolversDns01Akamai#serviceConsumerDomain
        '''
        result = self._values.get("service_consumer_domain")
        assert result is not None, "Required property 'service_consumer_domain' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01Akamai(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e9b3a0c78a6697d24b27eebb4bfc51b1c082d0f75586f04a4bfaacf0990a4c9)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c9449b86bfadea928ab7383791d045c4381eba25b621d3c52276ae599c04aec)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__10d17f7555b9e576a8009d2d295feca0686c198e5817fbf9f1fef93dfce63500)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01AzureDns",
    jsii_struct_bases=[],
    name_mapping={
        "resource_group_name": "resourceGroupName",
        "subscription_id": "subscriptionId",
        "client_id": "clientId",
        "client_secret_secret_ref": "clientSecretSecretRef",
        "environment": "environment",
        "hosted_zone_name": "hostedZoneName",
        "managed_identity": "managedIdentity",
        "tenant_id": "tenantId",
    },
)
class ClusterIssuerSpecAcmeSolversDns01AzureDns:
    def __init__(
        self,
        *,
        resource_group_name: builtins.str,
        subscription_id: builtins.str,
        client_id: typing.Optional[builtins.str] = None,
        client_secret_secret_ref: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        environment: typing.Optional["ClusterIssuerSpecAcmeSolversDns01AzureDnsEnvironment"] = None,
        hosted_zone_name: typing.Optional[builtins.str] = None,
        managed_identity: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01AzureDnsManagedIdentity", typing.Dict[builtins.str, typing.Any]]] = None,
        tenant_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Use the Microsoft Azure DNS API to manage DNS01 challenge records.

        :param resource_group_name: resource group the DNS zone is located in.
        :param subscription_id: ID of the Azure subscription.
        :param client_id: Auth: Azure Service Principal: The ClientID of the Azure Service Principal used to authenticate with Azure DNS. If set, ClientSecret and TenantID must also be set.
        :param client_secret_secret_ref: Auth: Azure Service Principal: A reference to a Secret containing the password associated with the Service Principal. If set, ClientID and TenantID must also be set.
        :param environment: name of the Azure environment (default AzurePublicCloud).
        :param hosted_zone_name: name of the DNS zone that should be used.
        :param managed_identity: Auth: Azure Workload Identity or Azure Managed Service Identity: Settings to enable Azure Workload Identity or Azure Managed Service Identity If set, ClientID, ClientSecret and TenantID must not be set.
        :param tenant_id: Auth: Azure Service Principal: The TenantID of the Azure Service Principal used to authenticate with Azure DNS. If set, ClientID and ClientSecret must also be set.

        :schema: ClusterIssuerSpecAcmeSolversDns01AzureDns
        '''
        if isinstance(client_secret_secret_ref, dict):
            client_secret_secret_ref = ClusterIssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef(**client_secret_secret_ref)
        if isinstance(managed_identity, dict):
            managed_identity = ClusterIssuerSpecAcmeSolversDns01AzureDnsManagedIdentity(**managed_identity)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__726c86548a8d5db296cbacbcaa585df8262700a8dc958218a21e291dab7039a3)
            check_type(argname="argument resource_group_name", value=resource_group_name, expected_type=type_hints["resource_group_name"])
            check_type(argname="argument subscription_id", value=subscription_id, expected_type=type_hints["subscription_id"])
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret_secret_ref", value=client_secret_secret_ref, expected_type=type_hints["client_secret_secret_ref"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument hosted_zone_name", value=hosted_zone_name, expected_type=type_hints["hosted_zone_name"])
            check_type(argname="argument managed_identity", value=managed_identity, expected_type=type_hints["managed_identity"])
            check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "resource_group_name": resource_group_name,
            "subscription_id": subscription_id,
        }
        if client_id is not None:
            self._values["client_id"] = client_id
        if client_secret_secret_ref is not None:
            self._values["client_secret_secret_ref"] = client_secret_secret_ref
        if environment is not None:
            self._values["environment"] = environment
        if hosted_zone_name is not None:
            self._values["hosted_zone_name"] = hosted_zone_name
        if managed_identity is not None:
            self._values["managed_identity"] = managed_identity
        if tenant_id is not None:
            self._values["tenant_id"] = tenant_id

    @builtins.property
    def resource_group_name(self) -> builtins.str:
        '''resource group the DNS zone is located in.

        :schema: ClusterIssuerSpecAcmeSolversDns01AzureDns#resourceGroupName
        '''
        result = self._values.get("resource_group_name")
        assert result is not None, "Required property 'resource_group_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def subscription_id(self) -> builtins.str:
        '''ID of the Azure subscription.

        :schema: ClusterIssuerSpecAcmeSolversDns01AzureDns#subscriptionID
        '''
        result = self._values.get("subscription_id")
        assert result is not None, "Required property 'subscription_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def client_id(self) -> typing.Optional[builtins.str]:
        '''Auth: Azure Service Principal: The ClientID of the Azure Service Principal used to authenticate with Azure DNS.

        If set, ClientSecret and TenantID must also be set.

        :schema: ClusterIssuerSpecAcmeSolversDns01AzureDns#clientID
        '''
        result = self._values.get("client_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def client_secret_secret_ref(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef"]:
        '''Auth: Azure Service Principal: A reference to a Secret containing the password associated with the Service Principal.

        If set, ClientID and TenantID must also be set.

        :schema: ClusterIssuerSpecAcmeSolversDns01AzureDns#clientSecretSecretRef
        '''
        result = self._values.get("client_secret_secret_ref")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef"], result)

    @builtins.property
    def environment(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01AzureDnsEnvironment"]:
        '''name of the Azure environment (default AzurePublicCloud).

        :schema: ClusterIssuerSpecAcmeSolversDns01AzureDns#environment
        '''
        result = self._values.get("environment")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01AzureDnsEnvironment"], result)

    @builtins.property
    def hosted_zone_name(self) -> typing.Optional[builtins.str]:
        '''name of the DNS zone that should be used.

        :schema: ClusterIssuerSpecAcmeSolversDns01AzureDns#hostedZoneName
        '''
        result = self._values.get("hosted_zone_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def managed_identity(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01AzureDnsManagedIdentity"]:
        '''Auth: Azure Workload Identity or Azure Managed Service Identity: Settings to enable Azure Workload Identity or Azure Managed Service Identity If set, ClientID, ClientSecret and TenantID must not be set.

        :schema: ClusterIssuerSpecAcmeSolversDns01AzureDns#managedIdentity
        '''
        result = self._values.get("managed_identity")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01AzureDnsManagedIdentity"], result)

    @builtins.property
    def tenant_id(self) -> typing.Optional[builtins.str]:
        '''Auth: Azure Service Principal: The TenantID of the Azure Service Principal used to authenticate with Azure DNS.

        If set, ClientID and ClientSecret must also be set.

        :schema: ClusterIssuerSpecAcmeSolversDns01AzureDns#tenantID
        '''
        result = self._values.get("tenant_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01AzureDns(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Auth: Azure Service Principal: A reference to a Secret containing the password associated with the Service Principal.

        If set, ClientID and TenantID must also be set.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__115eee6232fb1e4bf25695990ca5974657f931b9f001cf8b0187af597e2d1480)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01AzureDnsEnvironment"
)
class ClusterIssuerSpecAcmeSolversDns01AzureDnsEnvironment(enum.Enum):
    '''name of the Azure environment (default AzurePublicCloud).

    :schema: ClusterIssuerSpecAcmeSolversDns01AzureDnsEnvironment
    '''

    AZURE_PUBLIC_CLOUD = "AZURE_PUBLIC_CLOUD"
    '''AzurePublicCloud.'''
    AZURE_CHINA_CLOUD = "AZURE_CHINA_CLOUD"
    '''AzureChinaCloud.'''
    AZURE_GERMAN_CLOUD = "AZURE_GERMAN_CLOUD"
    '''AzureGermanCloud.'''
    AZURE_US_GOVERNMENT_CLOUD = "AZURE_US_GOVERNMENT_CLOUD"
    '''AzureUSGovernmentCloud.'''


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01AzureDnsManagedIdentity",
    jsii_struct_bases=[],
    name_mapping={
        "client_id": "clientId",
        "resource_id": "resourceId",
        "tenant_id": "tenantId",
    },
)
class ClusterIssuerSpecAcmeSolversDns01AzureDnsManagedIdentity:
    def __init__(
        self,
        *,
        client_id: typing.Optional[builtins.str] = None,
        resource_id: typing.Optional[builtins.str] = None,
        tenant_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Auth: Azure Workload Identity or Azure Managed Service Identity: Settings to enable Azure Workload Identity or Azure Managed Service Identity If set, ClientID, ClientSecret and TenantID must not be set.

        :param client_id: client ID of the managed identity, can not be used at the same time as resourceID.
        :param resource_id: resource ID of the managed identity, can not be used at the same time as clientID Cannot be used for Azure Managed Service Identity.
        :param tenant_id: tenant ID of the managed identity, can not be used at the same time as resourceID.

        :schema: ClusterIssuerSpecAcmeSolversDns01AzureDnsManagedIdentity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__94962ddf89582cc70f23e6fcaa0372658001cb835efa234108d72136614ccaed)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
            check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_id is not None:
            self._values["client_id"] = client_id
        if resource_id is not None:
            self._values["resource_id"] = resource_id
        if tenant_id is not None:
            self._values["tenant_id"] = tenant_id

    @builtins.property
    def client_id(self) -> typing.Optional[builtins.str]:
        '''client ID of the managed identity, can not be used at the same time as resourceID.

        :schema: ClusterIssuerSpecAcmeSolversDns01AzureDnsManagedIdentity#clientID
        '''
        result = self._values.get("client_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def resource_id(self) -> typing.Optional[builtins.str]:
        '''resource ID of the managed identity, can not be used at the same time as clientID Cannot be used for Azure Managed Service Identity.

        :schema: ClusterIssuerSpecAcmeSolversDns01AzureDnsManagedIdentity#resourceID
        '''
        result = self._values.get("resource_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tenant_id(self) -> typing.Optional[builtins.str]:
        '''tenant ID of the managed identity, can not be used at the same time as resourceID.

        :schema: ClusterIssuerSpecAcmeSolversDns01AzureDnsManagedIdentity#tenantID
        '''
        result = self._values.get("tenant_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01AzureDnsManagedIdentity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01CloudDns",
    jsii_struct_bases=[],
    name_mapping={
        "project": "project",
        "hosted_zone_name": "hostedZoneName",
        "service_account_secret_ref": "serviceAccountSecretRef",
    },
)
class ClusterIssuerSpecAcmeSolversDns01CloudDns:
    def __init__(
        self,
        *,
        project: builtins.str,
        hosted_zone_name: typing.Optional[builtins.str] = None,
        service_account_secret_ref: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Use the Google Cloud DNS API to manage DNS01 challenge records.

        :param project: 
        :param hosted_zone_name: HostedZoneName is an optional field that tells cert-manager in which Cloud DNS zone the challenge record has to be created. If left empty cert-manager will automatically choose a zone.
        :param service_account_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: ClusterIssuerSpecAcmeSolversDns01CloudDns
        '''
        if isinstance(service_account_secret_ref, dict):
            service_account_secret_ref = ClusterIssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef(**service_account_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a06967cfc9512cd69a94046eed190fb959155888c55cf2473c5642aebbc1a2b8)
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
            check_type(argname="argument hosted_zone_name", value=hosted_zone_name, expected_type=type_hints["hosted_zone_name"])
            check_type(argname="argument service_account_secret_ref", value=service_account_secret_ref, expected_type=type_hints["service_account_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "project": project,
        }
        if hosted_zone_name is not None:
            self._values["hosted_zone_name"] = hosted_zone_name
        if service_account_secret_ref is not None:
            self._values["service_account_secret_ref"] = service_account_secret_ref

    @builtins.property
    def project(self) -> builtins.str:
        '''
        :schema: ClusterIssuerSpecAcmeSolversDns01CloudDns#project
        '''
        result = self._values.get("project")
        assert result is not None, "Required property 'project' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def hosted_zone_name(self) -> typing.Optional[builtins.str]:
        '''HostedZoneName is an optional field that tells cert-manager in which Cloud DNS zone the challenge record has to be created.

        If left empty cert-manager will automatically choose a zone.

        :schema: ClusterIssuerSpecAcmeSolversDns01CloudDns#hostedZoneName
        '''
        result = self._values.get("hosted_zone_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_account_secret_ref(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterIssuerSpecAcmeSolversDns01CloudDns#serviceAccountSecretRef
        '''
        result = self._values.get("service_account_secret_ref")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01CloudDns(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8924894c731b8b98b6dba249316da66bf98a0be9b2fbc9e74f3ba37d597845da)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01Cloudflare",
    jsii_struct_bases=[],
    name_mapping={
        "api_key_secret_ref": "apiKeySecretRef",
        "api_token_secret_ref": "apiTokenSecretRef",
        "email": "email",
    },
)
class ClusterIssuerSpecAcmeSolversDns01Cloudflare:
    def __init__(
        self,
        *,
        api_key_secret_ref: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        api_token_secret_ref: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        email: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Use the Cloudflare API to manage DNS01 challenge records.

        :param api_key_secret_ref: API key to use to authenticate with Cloudflare. Note: using an API token to authenticate is now the recommended method as it allows greater control of permissions.
        :param api_token_secret_ref: API token used to authenticate with Cloudflare.
        :param email: Email of the account, only required when using API key based authentication.

        :schema: ClusterIssuerSpecAcmeSolversDns01Cloudflare
        '''
        if isinstance(api_key_secret_ref, dict):
            api_key_secret_ref = ClusterIssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef(**api_key_secret_ref)
        if isinstance(api_token_secret_ref, dict):
            api_token_secret_ref = ClusterIssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef(**api_token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aa898215d4c5b25a121bb5205eea5f61c2ea7b2fd097cff6c34937aa949eca04)
            check_type(argname="argument api_key_secret_ref", value=api_key_secret_ref, expected_type=type_hints["api_key_secret_ref"])
            check_type(argname="argument api_token_secret_ref", value=api_token_secret_ref, expected_type=type_hints["api_token_secret_ref"])
            check_type(argname="argument email", value=email, expected_type=type_hints["email"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if api_key_secret_ref is not None:
            self._values["api_key_secret_ref"] = api_key_secret_ref
        if api_token_secret_ref is not None:
            self._values["api_token_secret_ref"] = api_token_secret_ref
        if email is not None:
            self._values["email"] = email

    @builtins.property
    def api_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef"]:
        '''API key to use to authenticate with Cloudflare.

        Note: using an API token to authenticate is now the recommended method
        as it allows greater control of permissions.

        :schema: ClusterIssuerSpecAcmeSolversDns01Cloudflare#apiKeySecretRef
        '''
        result = self._values.get("api_key_secret_ref")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef"], result)

    @builtins.property
    def api_token_secret_ref(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef"]:
        '''API token used to authenticate with Cloudflare.

        :schema: ClusterIssuerSpecAcmeSolversDns01Cloudflare#apiTokenSecretRef
        '''
        result = self._values.get("api_token_secret_ref")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef"], result)

    @builtins.property
    def email(self) -> typing.Optional[builtins.str]:
        '''Email of the account, only required when using API key based authentication.

        :schema: ClusterIssuerSpecAcmeSolversDns01Cloudflare#email
        '''
        result = self._values.get("email")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01Cloudflare(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''API key to use to authenticate with Cloudflare.

        Note: using an API token to authenticate is now the recommended method
        as it allows greater control of permissions.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3f46b2ef766268f591a1866a4ebf73925a168a4519dbfbc4cb0fbcbc1722bb40)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''API token used to authenticate with Cloudflare.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e47a19162e21ce9038753737b126298a8a0b85334c0be78de794e8861a7b895)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01CnameStrategy")
class ClusterIssuerSpecAcmeSolversDns01CnameStrategy(enum.Enum):
    '''CNAMEStrategy configures how the DNS01 provider should handle CNAME records when found in DNS zones.

    :schema: ClusterIssuerSpecAcmeSolversDns01CnameStrategy
    '''

    NONE = "NONE"
    '''None.'''
    FOLLOW = "FOLLOW"
    '''Follow.'''


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01Digitalocean",
    jsii_struct_bases=[],
    name_mapping={"token_secret_ref": "tokenSecretRef"},
)
class ClusterIssuerSpecAcmeSolversDns01Digitalocean:
    def __init__(
        self,
        *,
        token_secret_ref: typing.Union["ClusterIssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Use the DigitalOcean DNS API to manage DNS01 challenge records.

        :param token_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: ClusterIssuerSpecAcmeSolversDns01Digitalocean
        '''
        if isinstance(token_secret_ref, dict):
            token_secret_ref = ClusterIssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef(**token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eaf214b6c82213ce7f12909fad81501029c7b7d4ec0b9b97439777458d79dc26)
            check_type(argname="argument token_secret_ref", value=token_secret_ref, expected_type=type_hints["token_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "token_secret_ref": token_secret_ref,
        }

    @builtins.property
    def token_secret_ref(
        self,
    ) -> "ClusterIssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterIssuerSpecAcmeSolversDns01Digitalocean#tokenSecretRef
        '''
        result = self._values.get("token_secret_ref")
        assert result is not None, "Required property 'token_secret_ref' is missing"
        return typing.cast("ClusterIssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01Digitalocean(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce4d45e749f2d41ccaa09e09fa5c55539e75c1842b4749a73bc4f050a70f6928)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01Rfc2136",
    jsii_struct_bases=[],
    name_mapping={
        "nameserver": "nameserver",
        "tsig_algorithm": "tsigAlgorithm",
        "tsig_key_name": "tsigKeyName",
        "tsig_secret_secret_ref": "tsigSecretSecretRef",
    },
)
class ClusterIssuerSpecAcmeSolversDns01Rfc2136:
    def __init__(
        self,
        *,
        nameserver: builtins.str,
        tsig_algorithm: typing.Optional[builtins.str] = None,
        tsig_key_name: typing.Optional[builtins.str] = None,
        tsig_secret_secret_ref: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/) to manage DNS01 challenge records.

        :param nameserver: The IP address or hostname of an authoritative DNS server supporting RFC2136 in the form host:port. If the host is an IPv6 address it must be enclosed in square brackets (e.g [2001:db8::1]) ; port is optional. This field is required.
        :param tsig_algorithm: The TSIG Algorithm configured in the DNS supporting RFC2136. Used only when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined. Supported values are (case-insensitive): ``HMACMD5`` (default), ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
        :param tsig_key_name: The TSIG Key name configured in the DNS. If ``tsigSecretSecretRef`` is defined, this field is required.
        :param tsig_secret_secret_ref: The name of the secret containing the TSIG value. If ``tsigKeyName`` is defined, this field is required.

        :schema: ClusterIssuerSpecAcmeSolversDns01Rfc2136
        '''
        if isinstance(tsig_secret_secret_ref, dict):
            tsig_secret_secret_ref = ClusterIssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef(**tsig_secret_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b002872d6a7a301b7e43c38e303b1a62feb22f38bb20d143771af205e5c698a)
            check_type(argname="argument nameserver", value=nameserver, expected_type=type_hints["nameserver"])
            check_type(argname="argument tsig_algorithm", value=tsig_algorithm, expected_type=type_hints["tsig_algorithm"])
            check_type(argname="argument tsig_key_name", value=tsig_key_name, expected_type=type_hints["tsig_key_name"])
            check_type(argname="argument tsig_secret_secret_ref", value=tsig_secret_secret_ref, expected_type=type_hints["tsig_secret_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "nameserver": nameserver,
        }
        if tsig_algorithm is not None:
            self._values["tsig_algorithm"] = tsig_algorithm
        if tsig_key_name is not None:
            self._values["tsig_key_name"] = tsig_key_name
        if tsig_secret_secret_ref is not None:
            self._values["tsig_secret_secret_ref"] = tsig_secret_secret_ref

    @builtins.property
    def nameserver(self) -> builtins.str:
        '''The IP address or hostname of an authoritative DNS server supporting RFC2136 in the form host:port.

        If the host is an IPv6 address it must be
        enclosed in square brackets (e.g [2001:db8::1]); port is optional.
        This field is required.

        :schema: ClusterIssuerSpecAcmeSolversDns01Rfc2136#nameserver
        '''
        result = self._values.get("nameserver")
        assert result is not None, "Required property 'nameserver' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tsig_algorithm(self) -> typing.Optional[builtins.str]:
        '''The TSIG Algorithm configured in the DNS supporting RFC2136.

        Used only
        when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined.
        Supported values are (case-insensitive): ``HMACMD5`` (default),
        ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.

        :schema: ClusterIssuerSpecAcmeSolversDns01Rfc2136#tsigAlgorithm
        '''
        result = self._values.get("tsig_algorithm")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tsig_key_name(self) -> typing.Optional[builtins.str]:
        '''The TSIG Key name configured in the DNS.

        If ``tsigSecretSecretRef`` is defined, this field is required.

        :schema: ClusterIssuerSpecAcmeSolversDns01Rfc2136#tsigKeyName
        '''
        result = self._values.get("tsig_key_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tsig_secret_secret_ref(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef"]:
        '''The name of the secret containing the TSIG value.

        If ``tsigKeyName`` is defined, this field is required.

        :schema: ClusterIssuerSpecAcmeSolversDns01Rfc2136#tsigSecretSecretRef
        '''
        result = self._values.get("tsig_secret_secret_ref")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01Rfc2136(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The name of the secret containing the TSIG value.

        If ``tsigKeyName`` is defined, this field is required.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c2eb933161206126e0e029871bfd1f7979f513e14673ca763c3c1f3e00142977)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01Route53",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id": "accessKeyId",
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "auth": "auth",
        "hosted_zone_id": "hostedZoneId",
        "region": "region",
        "role": "role",
        "secret_access_key_secret_ref": "secretAccessKeySecretRef",
    },
)
class ClusterIssuerSpecAcmeSolversDns01Route53:
    def __init__(
        self,
        *,
        access_key_id: typing.Optional[builtins.str] = None,
        access_key_id_secret_ref: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        auth: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01Route53Auth", typing.Dict[builtins.str, typing.Any]]] = None,
        hosted_zone_id: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        secret_access_key_secret_ref: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Use the AWS Route53 API to manage DNS01 challenge records.

        :param access_key_id: The AccessKeyID is used for authentication. Cannot be set when SecretAccessKeyID is set. If neither the Access Key nor Key ID are set, we fall-back to using env vars, shared credentials file or AWS Instance metadata, see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
        :param access_key_id_secret_ref: The SecretAccessKey is used for authentication. If set, pull the AWS access key ID from a key within a Kubernetes Secret. Cannot be set when AccessKeyID is set. If neither the Access Key nor Key ID are set, we fall-back to using env vars, shared credentials file or AWS Instance metadata, see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
        :param auth: Auth configures how cert-manager authenticates.
        :param hosted_zone_id: If set, the provider will manage only this zone in Route53 and will not do a lookup using the route53:ListHostedZonesByName api call.
        :param region: Override the AWS region. Route53 is a global service and does not have regional endpoints but the region specified here (or via environment variables) is used as a hint to help compute the correct AWS credential scope and partition when it connects to Route53. See: - `Amazon Route 53 endpoints and quotas <https://docs.aws.amazon.com/general/latest/gr/r53.html>`_ - `Global services <https://docs.aws.amazon.com/whitepapers/latest/aws-fault-isolation-boundaries/global-services.html>`_ If you omit this region field, cert-manager will use the region from AWS_REGION and AWS_DEFAULT_REGION environment variables, if they are set in the cert-manager controller Pod. The ``region`` field is not needed if you use `IAM Roles for Service Accounts (IRSA) <https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html>`_. Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by: `Amazon EKS Pod Identity Webhook <https://github.com/aws/amazon-eks-pod-identity-webhook>`_. In this case this ``region`` field value is ignored. The ``region`` field is not needed if you use `EKS Pod Identities <https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html>`_. Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by: `Amazon EKS Pod Identity Agent <https://github.com/aws/eks-pod-identity-agent>`_, In this case this ``region`` field value is ignored.
        :param role: Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata.
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication. If neither the Access Key nor Key ID are set, we fall-back to using env vars, shared credentials file or AWS Instance metadata, see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = ClusterIssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(auth, dict):
            auth = ClusterIssuerSpecAcmeSolversDns01Route53Auth(**auth)
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = ClusterIssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e396d25f4ccc9637d1aba8a68be65d4313753e7ebdfdf61b81189f29cee89e4)
            check_type(argname="argument access_key_id", value=access_key_id, expected_type=type_hints["access_key_id"])
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument hosted_zone_id", value=hosted_zone_id, expected_type=type_hints["hosted_zone_id"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_key_id is not None:
            self._values["access_key_id"] = access_key_id
        if access_key_id_secret_ref is not None:
            self._values["access_key_id_secret_ref"] = access_key_id_secret_ref
        if auth is not None:
            self._values["auth"] = auth
        if hosted_zone_id is not None:
            self._values["hosted_zone_id"] = hosted_zone_id
        if region is not None:
            self._values["region"] = region
        if role is not None:
            self._values["role"] = role
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref

    @builtins.property
    def access_key_id(self) -> typing.Optional[builtins.str]:
        '''The AccessKeyID is used for authentication.

        Cannot be set when SecretAccessKeyID is set.
        If neither the Access Key nor Key ID are set, we fall-back to using env
        vars, shared credentials file or AWS Instance metadata,
        see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53#accessKeyID
        '''
        result = self._values.get("access_key_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef"]:
        '''The SecretAccessKey is used for authentication.

        If set, pull the AWS
        access key ID from a key within a Kubernetes Secret.
        Cannot be set when AccessKeyID is set.
        If neither the Access Key nor Key ID are set, we fall-back to using env
        vars, shared credentials file or AWS Instance metadata,
        see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef"], result)

    @builtins.property
    def auth(self) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01Route53Auth"]:
        '''Auth configures how cert-manager authenticates.

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01Route53Auth"], result)

    @builtins.property
    def hosted_zone_id(self) -> typing.Optional[builtins.str]:
        '''If set, the provider will manage only this zone in Route53 and will not do a lookup using the route53:ListHostedZonesByName api call.

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53#hostedZoneID
        '''
        result = self._values.get("hosted_zone_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''Override the AWS region.

        Route53 is a global service and does not have regional endpoints but the
        region specified here (or via environment variables) is used as a hint to
        help compute the correct AWS credential scope and partition when it
        connects to Route53. See:

        - `Amazon Route 53 endpoints and quotas <https://docs.aws.amazon.com/general/latest/gr/r53.html>`_
        - `Global services <https://docs.aws.amazon.com/whitepapers/latest/aws-fault-isolation-boundaries/global-services.html>`_

        If you omit this region field, cert-manager will use the region from
        AWS_REGION and AWS_DEFAULT_REGION environment variables, if they are set
        in the cert-manager controller Pod.

        The ``region`` field is not needed if you use `IAM Roles for Service Accounts (IRSA) <https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html>`_.
        Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by:
        `Amazon EKS Pod Identity Webhook <https://github.com/aws/amazon-eks-pod-identity-webhook>`_.
        In this case this ``region`` field value is ignored.

        The ``region`` field is not needed if you use `EKS Pod Identities <https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html>`_.
        Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by:
        `Amazon EKS Pod Identity Agent <https://github.com/aws/eks-pod-identity-agent>`_,
        In this case this ``region`` field value is ignored.

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53#region
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata.

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        If neither the Access Key nor Key ID are set, we fall-back to using env
        vars, shared credentials file or AWS Instance metadata,
        see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01Route53(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        If set, pull the AWS
        access key ID from a key within a Kubernetes Secret.
        Cannot be set when AccessKeyID is set.
        If neither the Access Key nor Key ID are set, we fall-back to using env
        vars, shared credentials file or AWS Instance metadata,
        see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3bbd8a7a4c2caed529e0b14309985b9d6f65054ad2c8cafa9bec9c93120528f0)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01Route53Auth",
    jsii_struct_bases=[],
    name_mapping={"kubernetes": "kubernetes"},
)
class ClusterIssuerSpecAcmeSolversDns01Route53Auth:
    def __init__(
        self,
        *,
        kubernetes: typing.Union["ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetes", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how cert-manager authenticates.

        :param kubernetes: Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity by passing a bound ServiceAccount token.

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53Auth
        '''
        if isinstance(kubernetes, dict):
            kubernetes = ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetes(**kubernetes)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__182f7e38cdaa741af9edef7a4fff3e98e7f5e04f5a9e6cd310703c3923c9b655)
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "kubernetes": kubernetes,
        }

    @builtins.property
    def kubernetes(self) -> "ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetes":
        '''Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity by passing a bound ServiceAccount token.

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53Auth#kubernetes
        '''
        result = self._values.get("kubernetes")
        assert result is not None, "Required property 'kubernetes' is missing"
        return typing.cast("ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetes", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01Route53Auth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetes",
    jsii_struct_bases=[],
    name_mapping={"service_account_ref": "serviceAccountRef"},
)
class ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetes:
    def __init__(
        self,
        *,
        service_account_ref: typing.Union["ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity by passing a bound ServiceAccount token.

        :param service_account_ref: A reference to a service account that will be used to request a bound token (also known as "projected token"). To use this field, you must configure an RBAC rule to let cert-manager request a token.

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetes
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0eb5a6c0f8248c867bbf5d8b1e6492aac10c7101018bf4fb8ca302bde1e93ebd)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "service_account_ref": service_account_ref,
        }

    @builtins.property
    def service_account_ref(
        self,
    ) -> "ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef":
        '''A reference to a service account that will be used to request a bound token (also known as "projected token").

        To use this field, you must
        configure an RBAC rule to let cert-manager request a token.

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetes#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences"},
)
class ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A reference to a service account that will be used to request a bound token (also known as "projected token").

        To use this field, you must
        configure an RBAC rule to let cert-manager request a token.

        :param name: Name of the ServiceAccount used to request a token.
        :param audiences: TokenAudiences is an optional list of audiences to include in the token passed to AWS. The default token consisting of the issuer's namespace and name is always included. If unset the audience defaults to ``sts.amazonaws.com``.

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1fff29f97a478a785ada627e37581c3215798c74d9225250412b704b47748adc)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the ServiceAccount used to request a token.

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''TokenAudiences is an optional list of audiences to include in the token passed to AWS.

        The default token consisting of the issuer's namespace
        and name is always included.
        If unset the audience defaults to ``sts.amazonaws.com``.

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        If neither the Access Key nor Key ID are set, we fall-back to using env
        vars, shared credentials file or AWS Instance metadata,
        see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a38f57416ef270f5a78042177e2b680c3eb55f68ed309827126e486b54b77032)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversDns01Webhook",
    jsii_struct_bases=[],
    name_mapping={
        "group_name": "groupName",
        "solver_name": "solverName",
        "config": "config",
    },
)
class ClusterIssuerSpecAcmeSolversDns01Webhook:
    def __init__(
        self,
        *,
        group_name: builtins.str,
        solver_name: builtins.str,
        config: typing.Any = None,
    ) -> None:
        '''Configure an external webhook based DNS01 challenge solver to manage DNS01 challenge records.

        :param group_name: The API group name that should be used when POSTing ChallengePayload resources to the webhook apiserver. This should be the same as the GroupName specified in the webhook provider implementation.
        :param solver_name: The name of the solver to use, as defined in the webhook provider implementation. This will typically be the name of the provider, e.g. 'cloudflare'.
        :param config: Additional configuration that should be passed to the webhook apiserver when challenges are processed. This can contain arbitrary JSON data. Secret values should not be specified in this stanza. If secret values are needed (e.g. credentials for a DNS service), you should use a SecretKeySelector to reference a Secret resource. For details on the schema of this field, consult the webhook provider implementation's documentation.

        :schema: ClusterIssuerSpecAcmeSolversDns01Webhook
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f6b9f64d76edfd1157da00efbca252358d53658a0f70cf2da43b5b73a428e516)
            check_type(argname="argument group_name", value=group_name, expected_type=type_hints["group_name"])
            check_type(argname="argument solver_name", value=solver_name, expected_type=type_hints["solver_name"])
            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "group_name": group_name,
            "solver_name": solver_name,
        }
        if config is not None:
            self._values["config"] = config

    @builtins.property
    def group_name(self) -> builtins.str:
        '''The API group name that should be used when POSTing ChallengePayload resources to the webhook apiserver.

        This should be the same as the GroupName specified in the webhook
        provider implementation.

        :schema: ClusterIssuerSpecAcmeSolversDns01Webhook#groupName
        '''
        result = self._values.get("group_name")
        assert result is not None, "Required property 'group_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def solver_name(self) -> builtins.str:
        '''The name of the solver to use, as defined in the webhook provider implementation.

        This will typically be the name of the provider, e.g. 'cloudflare'.

        :schema: ClusterIssuerSpecAcmeSolversDns01Webhook#solverName
        '''
        result = self._values.get("solver_name")
        assert result is not None, "Required property 'solver_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def config(self) -> typing.Any:
        '''Additional configuration that should be passed to the webhook apiserver when challenges are processed.

        This can contain arbitrary JSON data.
        Secret values should not be specified in this stanza.
        If secret values are needed (e.g. credentials for a DNS service), you
        should use a SecretKeySelector to reference a Secret resource.
        For details on the schema of this field, consult the webhook provider
        implementation's documentation.

        :schema: ClusterIssuerSpecAcmeSolversDns01Webhook#config
        '''
        result = self._values.get("config")
        return typing.cast(typing.Any, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversDns01Webhook(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01",
    jsii_struct_bases=[],
    name_mapping={"gateway_http_route": "gatewayHttpRoute", "ingress": "ingress"},
)
class ClusterIssuerSpecAcmeSolversHttp01:
    def __init__(
        self,
        *,
        gateway_http_route: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoute", typing.Dict[builtins.str, typing.Any]]] = None,
        ingress: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01Ingress", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Configures cert-manager to attempt to complete authorizations by performing the HTTP01 challenge flow.

        It is not possible to obtain certificates for wildcard domain names
        (e.g. ``*.example.com``) using the HTTP01 challenge mechanism.

        :param gateway_http_route: The Gateway API is a sig-network community API that models service networking in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will create HTTPRoutes with the specified labels in the same namespace as the challenge. This solver is experimental, and fields / behaviour may change in the future.
        :param ingress: The ingress based HTTP01 challenge solver will solve challenges by creating or modifying Ingress resources in order to route requests for '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are provisioned by cert-manager for each Challenge to be completed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01
        '''
        if isinstance(gateway_http_route, dict):
            gateway_http_route = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoute(**gateway_http_route)
        if isinstance(ingress, dict):
            ingress = ClusterIssuerSpecAcmeSolversHttp01Ingress(**ingress)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45fed7313bfd75672214658f3692015852cdd4f5812fa9ab5aaab7ce3ac6abce)
            check_type(argname="argument gateway_http_route", value=gateway_http_route, expected_type=type_hints["gateway_http_route"])
            check_type(argname="argument ingress", value=ingress, expected_type=type_hints["ingress"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if gateway_http_route is not None:
            self._values["gateway_http_route"] = gateway_http_route
        if ingress is not None:
            self._values["ingress"] = ingress

    @builtins.property
    def gateway_http_route(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoute"]:
        '''The Gateway API is a sig-network community API that models service networking in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will create HTTPRoutes with the specified labels in the same namespace as the challenge. This solver is experimental, and fields / behaviour may change in the future.

        :schema: ClusterIssuerSpecAcmeSolversHttp01#gatewayHTTPRoute
        '''
        result = self._values.get("gateway_http_route")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoute"], result)

    @builtins.property
    def ingress(self) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01Ingress"]:
        '''The ingress based HTTP01 challenge solver will solve challenges by creating or modifying Ingress resources in order to route requests for '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are provisioned by cert-manager for each Challenge to be completed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01#ingress
        '''
        result = self._values.get("ingress")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01Ingress"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoute",
    jsii_struct_bases=[],
    name_mapping={
        "labels": "labels",
        "parent_refs": "parentRefs",
        "pod_template": "podTemplate",
        "service_type": "serviceType",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoute:
    def __init__(
        self,
        *,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        parent_refs: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs", typing.Dict[builtins.str, typing.Any]]]] = None,
        pod_template: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate", typing.Dict[builtins.str, typing.Any]]] = None,
        service_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Gateway API is a sig-network community API that models service networking in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will create HTTPRoutes with the specified labels in the same namespace as the challenge. This solver is experimental, and fields / behaviour may change in the future.

        :param labels: Custom labels that will be applied to HTTPRoutes created by cert-manager while solving HTTP-01 challenges.
        :param parent_refs: When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute. cert-manager needs to know which parentRefs should be used when creating the HTTPRoute. Usually, the parentRef references a Gateway. See: https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
        :param pod_template: Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges.
        :param service_type: Optional service type for Kubernetes solver service. Supported values are NodePort or ClusterIP. If unset, defaults to NodePort.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoute
        '''
        if isinstance(pod_template, dict):
            pod_template = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate(**pod_template)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__88659644f46c5f99a1c86919d81467cec4faee2f8df7f02554b2ca5af8999052)
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument parent_refs", value=parent_refs, expected_type=type_hints["parent_refs"])
            check_type(argname="argument pod_template", value=pod_template, expected_type=type_hints["pod_template"])
            check_type(argname="argument service_type", value=service_type, expected_type=type_hints["service_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if labels is not None:
            self._values["labels"] = labels
        if parent_refs is not None:
            self._values["parent_refs"] = parent_refs
        if pod_template is not None:
            self._values["pod_template"] = pod_template
        if service_type is not None:
            self._values["service_type"] = service_type

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Custom labels that will be applied to HTTPRoutes created by cert-manager while solving HTTP-01 challenges.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoute#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def parent_refs(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs"]]:
        '''When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.

        cert-manager needs to know which parentRefs should be used when creating
        the HTTPRoute. Usually, the parentRef references a Gateway. See:
        https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoute#parentRefs
        '''
        result = self._values.get("parent_refs")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs"]], result)

    @builtins.property
    def pod_template(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate"]:
        '''Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoute#podTemplate
        '''
        result = self._values.get("pod_template")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate"], result)

    @builtins.property
    def service_type(self) -> typing.Optional[builtins.str]:
        '''Optional service type for Kubernetes solver service.

        Supported values
        are NodePort or ClusterIP. If unset, defaults to NodePort.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoute#serviceType
        '''
        result = self._values.get("service_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "group": "group",
        "kind": "kind",
        "namespace": "namespace",
        "port": "port",
        "section_name": "sectionName",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs:
    def __init__(
        self,
        *,
        name: builtins.str,
        group: typing.Optional[builtins.str] = None,
        kind: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
        port: typing.Optional[jsii.Number] = None,
        section_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route).

        There are two kinds of parent resources
        with "Core" support:

        - Gateway (Gateway conformance profile)
        - Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.

        :param name: Name is the name of the referent. Support: Core
        :param group: Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string). Support: Core
        :param kind: Kind is kind of the referent. There are two kinds of parent resources with "Core" support: - Gateway (Gateway conformance profile) - Service (Mesh conformance profile, ClusterIP Services only) Support for other resources is Implementation-Specific.
        :param namespace: Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route. Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference. `gateway:experimental:description <gateway:experimental:description>`_ ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service. ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route. </gateway:experimental:description> Support: Core
        :param port: Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource. When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set ``Port`` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values. `gateway:experimental:description <gateway:experimental:description>`_ When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values. </gateway:experimental:description> Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted. For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. Support: Extended
        :param section_name: SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following: - Gateway: Listener name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. - Service: Port name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted. When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. Support: Core

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c9d8743f5ea47696322c701c19e75d9eb96649c4b152798d5876ebe2ab9304b)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument group", value=group, expected_type=type_hints["group"])
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument section_name", value=section_name, expected_type=type_hints["section_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if group is not None:
            self._values["group"] = group
        if kind is not None:
            self._values["kind"] = kind
        if namespace is not None:
            self._values["namespace"] = namespace
        if port is not None:
            self._values["port"] = port
        if section_name is not None:
            self._values["section_name"] = section_name

    @builtins.property
    def name(self) -> builtins.str:
        '''Name is the name of the referent.

        Support: Core

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group(self) -> typing.Optional[builtins.str]:
        '''Group is the group of the referent.

        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#group
        '''
        result = self._values.get("group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        '''Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        - Gateway (Gateway conformance profile)
        - Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.

        `gateway:experimental:description <gateway:experimental:description>`_
        ParentRefs from a Route to a Service in the same namespace are "producer"
        routes, which apply default routing rules to inbound connections from
        any namespace to the Service.

        ParentRefs from a Route to a Service in a different namespace are
        "consumer" routes, and these routing rules are only applied to outbound
        connections originating from the same namespace as the Route, for which
        the intended destination of the connections are a Service targeted as a
        ParentRef of the Route.
        </gateway:experimental:description>

        Support: Core

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set ``Port`` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.

        `gateway:experimental:description <gateway:experimental:description>`_
        When the parent resource is a Service, this targets a specific port in the
        Service spec. When both Port (experimental) and SectionName are specified,
        the name and port of the selected port must match both specified values.
        </gateway:experimental:description>

        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#port
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def section_name(self) -> typing.Optional[builtins.str]:
        '''SectionName is the name of a section within the target resource.

        In the
        following resources, SectionName is interpreted as the following:

        - Gateway: Listener name. When both Port (experimental) and SectionName
          are specified, the name and port of the selected listener must match
          both specified values.
        - Service: Port name. When both Port (experimental) and SectionName
          are specified, the name and port of the selected listener must match
          both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#sectionName
        '''
        result = self._values.get("section_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata", typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges.

        :param metadata: ObjectMeta overrides for the pod used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
        :param spec: PodSpec defines overrides for the HTTP01 challenge solver pod. Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields. All other fields will be ignored.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate
        '''
        if isinstance(metadata, dict):
            metadata = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata(**metadata)
        if isinstance(spec, dict):
            spec = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec(**spec)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__783efb24173c98d4a014f307762e83928681e3b20be92bb381513457cbcc1be4)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata"]:
        '''ObjectMeta overrides for the pod used to solve HTTP01 challenges.

        Only the 'labels' and 'annotations' fields may be set.
        If labels or annotations overlap with in-built values, the values here
        will override the in-built values.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata"], result)

    @builtins.property
    def spec(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec"]:
        '''PodSpec defines overrides for the HTTP01 challenge solver pod.

        Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
        All other fields will be ignored.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={"annotations": "annotations", "labels": "labels"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''ObjectMeta overrides for the pod used to solve HTTP01 challenges.

        Only the 'labels' and 'annotations' fields may be set.
        If labels or annotations overlap with in-built values, the values here
        will override the in-built values.

        :param annotations: Annotations that should be added to the created ACME HTTP01 solver pods.
        :param labels: Labels that should be added to the created ACME HTTP01 solver pods.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee6b216e647b6e2352c04231149010c88246ae5229a99ad4c070ed0cca605199)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Annotations that should be added to the created ACME HTTP01 solver pods.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Labels that should be added to the created ACME HTTP01 solver pods.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec",
    jsii_struct_bases=[],
    name_mapping={
        "affinity": "affinity",
        "image_pull_secrets": "imagePullSecrets",
        "node_selector": "nodeSelector",
        "priority_class_name": "priorityClassName",
        "security_context": "securityContext",
        "service_account_name": "serviceAccountName",
        "tolerations": "tolerations",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec:
    def __init__(
        self,
        *,
        affinity: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
        image_pull_secrets: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets", typing.Dict[builtins.str, typing.Any]]]] = None,
        node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        priority_class_name: typing.Optional[builtins.str] = None,
        security_context: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        tolerations: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''PodSpec defines overrides for the HTTP01 challenge solver pod.

        Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
        All other fields will be ignored.

        :param affinity: If specified, the pod's scheduling constraints.
        :param image_pull_secrets: If specified, the pod's imagePullSecrets.
        :param node_selector: NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
        :param priority_class_name: If specified, the pod's priorityClassName.
        :param security_context: If specified, the pod's security context.
        :param service_account_name: If specified, the pod's service account.
        :param tolerations: If specified, the pod's tolerations.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec
        '''
        if isinstance(affinity, dict):
            affinity = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity(**affinity)
        if isinstance(security_context, dict):
            security_context = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext(**security_context)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35961b9eb8906b2d2c4ea7f28774136be7b2cacdd96d517659d6f88f94f499dc)
            check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
            check_type(argname="argument image_pull_secrets", value=image_pull_secrets, expected_type=type_hints["image_pull_secrets"])
            check_type(argname="argument node_selector", value=node_selector, expected_type=type_hints["node_selector"])
            check_type(argname="argument priority_class_name", value=priority_class_name, expected_type=type_hints["priority_class_name"])
            check_type(argname="argument security_context", value=security_context, expected_type=type_hints["security_context"])
            check_type(argname="argument service_account_name", value=service_account_name, expected_type=type_hints["service_account_name"])
            check_type(argname="argument tolerations", value=tolerations, expected_type=type_hints["tolerations"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if affinity is not None:
            self._values["affinity"] = affinity
        if image_pull_secrets is not None:
            self._values["image_pull_secrets"] = image_pull_secrets
        if node_selector is not None:
            self._values["node_selector"] = node_selector
        if priority_class_name is not None:
            self._values["priority_class_name"] = priority_class_name
        if security_context is not None:
            self._values["security_context"] = security_context
        if service_account_name is not None:
            self._values["service_account_name"] = service_account_name
        if tolerations is not None:
            self._values["tolerations"] = tolerations

    @builtins.property
    def affinity(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity"]:
        '''If specified, the pod's scheduling constraints.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#affinity
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity"], result)

    @builtins.property
    def image_pull_secrets(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets"]]:
        '''If specified, the pod's imagePullSecrets.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#imagePullSecrets
        '''
        result = self._values.get("image_pull_secrets")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets"]], result)

    @builtins.property
    def node_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''NodeSelector is a selector which must be true for the pod to fit on a node.

        Selector which must match a node's labels for the pod to be scheduled on that node.
        More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#nodeSelector
        '''
        result = self._values.get("node_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def priority_class_name(self) -> typing.Optional[builtins.str]:
        '''If specified, the pod's priorityClassName.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#priorityClassName
        '''
        result = self._values.get("priority_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_context(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext"]:
        '''If specified, the pod's security context.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#securityContext
        '''
        result = self._values.get("security_context")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext"], result)

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        '''If specified, the pod's service account.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#serviceAccountName
        '''
        result = self._values.get("service_account_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tolerations(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations"]]:
        '''If specified, the pod's tolerations.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#tolerations
        '''
        result = self._values.get("tolerations")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "node_affinity": "nodeAffinity",
        "pod_affinity": "podAffinity",
        "pod_anti_affinity": "podAntiAffinity",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity:
    def __init__(
        self,
        *,
        node_affinity: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_affinity: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_anti_affinity: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''If specified, the pod's scheduling constraints.

        :param node_affinity: Describes node affinity scheduling rules for the pod.
        :param pod_affinity: Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
        :param pod_anti_affinity: Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity
        '''
        if isinstance(node_affinity, dict):
            node_affinity = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity(**node_affinity)
        if isinstance(pod_affinity, dict):
            pod_affinity = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity(**pod_affinity)
        if isinstance(pod_anti_affinity, dict):
            pod_anti_affinity = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity(**pod_anti_affinity)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2476f746dd48b774e046e65665b5e02cef90642293423f8f87b9be5a5a26d7c4)
            check_type(argname="argument node_affinity", value=node_affinity, expected_type=type_hints["node_affinity"])
            check_type(argname="argument pod_affinity", value=pod_affinity, expected_type=type_hints["pod_affinity"])
            check_type(argname="argument pod_anti_affinity", value=pod_anti_affinity, expected_type=type_hints["pod_anti_affinity"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if node_affinity is not None:
            self._values["node_affinity"] = node_affinity
        if pod_affinity is not None:
            self._values["pod_affinity"] = pod_affinity
        if pod_anti_affinity is not None:
            self._values["pod_anti_affinity"] = pod_anti_affinity

    @builtins.property
    def node_affinity(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity"]:
        '''Describes node affinity scheduling rules for the pod.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity#nodeAffinity
        '''
        result = self._values.get("node_affinity")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity"], result)

    @builtins.property
    def pod_affinity(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity"]:
        '''Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity#podAffinity
        '''
        result = self._values.get("pod_affinity")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity"], result)

    @builtins.property
    def pod_anti_affinity(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity"]:
        '''Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity#podAntiAffinity
        '''
        result = self._values.get("pod_anti_affinity")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Describes node affinity scheduling rules for the pod.

        :param preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
        :param required_during_scheduling_ignored_during_execution: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity
        '''
        if isinstance(required_during_scheduling_ignored_during_execution, dict):
            required_during_scheduling_ignored_during_execution = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(**required_during_scheduling_ignored_during_execution)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b8171c6611daff19eed0db6a67f8778ba0074152778ba32486e9060d5bf0e16)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.

        The node that is
        most preferred is the one with the greatest sum of weights, i.e.
        for each node that meets all of the scheduling requirements (resource
        request, requiredDuringScheduling affinity expressions, etc.),
        compute a sum by iterating through the elements of this field and adding
        "weight" to the sum if the node matches the corresponding matchExpressions; the
        node(s) with the highest sum are the most preferred.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"]:
        '''If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the affinity requirements specified by this field cease to be met
        at some point during pod execution (e.g. due to an update), the system
        may or may not try to eventually evict the pod from its node.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"preference": "preference", "weight": "weight"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        preference: typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", typing.Dict[builtins.str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).

        :param preference: A node selector term, associated with the corresponding weight.
        :param weight: Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(preference, dict):
            preference = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(**preference)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6af9ba061560234cdcd1c125df303afea6d38f9c2643f257327c43ecac7ba526)
            check_type(argname="argument preference", value=preference, expected_type=type_hints["preference"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "preference": preference,
            "weight": weight,
        }

    @builtins.property
    def preference(
        self,
    ) -> "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference":
        '''A node selector term, associated with the corresponding weight.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
        '''
        result = self._values.get("preference")
        assert result is not None, "Required property 'preference' is missing"
        return typing.cast("ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''A node selector term, associated with the corresponding weight.

        :param match_expressions: A list of node selector requirements by node's labels.
        :param match_fields: A list of node selector requirements by node's fields.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86c6a1dede316b93ef56bb1badc005559bbe998a647fe3b3f1f893976154c9cd)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]]:
        '''A list of node selector requirements by node's labels.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]]:
        '''A list of node selector requirements by node's fields.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__92e96d8751817bf072f93ec506de98d281952674f234caaa21a19210b1908fb3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''The label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''Represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. If the operator is Gt or Lt, the values
        array must have a single element, which will be interpreted as an integer.
        This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3f67e8864cd715cfff154c89d57b17a87f3fed27aa9add0fe7ace8a9760f7055)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''The label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''Represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. If the operator is Gt or Lt, the values
        array must have a single element, which will be interpreted as an integer.
        This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"node_selector_terms": "nodeSelectorTerms"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        node_selector_terms: typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms", typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the affinity requirements specified by this field cease to be met
        at some point during pod execution (e.g. due to an update), the system
        may or may not try to eventually evict the pod from its node.

        :param node_selector_terms: Required. A list of node selector terms. The terms are ORed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fcd1fe9417206b4422fe213aa77dd0f46ff2beb1d6f7f5f73564fa14f58ff409)
            check_type(argname="argument node_selector_terms", value=node_selector_terms, expected_type=type_hints["node_selector_terms"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "node_selector_terms": node_selector_terms,
        }

    @builtins.property
    def node_selector_terms(
        self,
    ) -> typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"]:
        '''Required.

        A list of node selector terms. The terms are ORed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
        '''
        result = self._values.get("node_selector_terms")
        assert result is not None, "Required property 'node_selector_terms' is missing"
        return typing.cast(typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''A null or empty node selector term matches no objects.

        The requirements of
        them are ANDed.
        The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.

        :param match_expressions: A list of node selector requirements by node's labels.
        :param match_fields: A list of node selector requirements by node's fields.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a52c270195aa28aaeb4678cc56e569c8780ae0d99ffe522f96fe5baa6f0d9775)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]]:
        '''A list of node selector requirements by node's labels.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]]:
        '''A list of node selector requirements by node's fields.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0c1294338dc92d4289f22c102929658e57501ff1da1bc5197a31cf499216728)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''The label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''Represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. If the operator is Gt or Lt, the values
        array must have a single element, which will be interpreted as an integer.
        This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9970b49239e88a60482e980a8cd26a57412afb88dd327877b8043b100ec1cef3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''The label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''Represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. If the operator is Gt or Lt, the values
        array must have a single element, which will be interpreted as an integer.
        This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).

        :param preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        :param required_during_scheduling_ignored_during_execution: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__adbd9d53aa830a7b9fbe8efce27a6d826e7827bfe37e6cd80c396d4037cc53b4)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.

        The node that is
        most preferred is the one with the greatest sum of weights, i.e.
        for each node that meets all of the scheduling requirements (resource
        request, requiredDuringScheduling affinity expressions, etc.),
        compute a sum by iterating through the elements of this field and adding
        "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
        node(s) with the highest sum are the most preferred.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the affinity requirements specified by this field cease to be met
        at some point during pod execution (e.g. due to a pod label update), the
        system may or may not try to eventually evict the pod from its node.
        When there are multiple elements, the lists of nodes corresponding to each
        podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[builtins.str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s).

        :param pod_affinity_term: Required. A pod affinity term, associated with the corresponding weight.
        :param weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7168c3a1cbd26e28570cd65cfce1cbc18a89c06d510b851e1a4ff768be57091)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''Required.

        A pod affinity term, associated with the corresponding weight.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "match_label_keys": "matchLabelKeys",
        "mismatch_label_keys": "mismatchLabelKeys",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Required.

        A pod affinity term, associated with the corresponding weight.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
        :param match_label_keys: MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param mismatch_label_keys: MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
        :param namespace_selector: A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__978f5cd61681eeaf17538f83d1ac222b3b828048d9c3b12ebe8d54ac69703e35)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument match_label_keys", value=match_label_keys, expected_type=type_hints["match_label_keys"])
            check_type(argname="argument mismatch_label_keys", value=mismatch_label_keys, expected_type=type_hints["mismatch_label_keys"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if match_label_keys is not None:
            self._values["match_label_keys"] = match_label_keys
        if mismatch_label_keys is not None:
            self._values["mismatch_label_keys"] = mismatch_label_keys
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def match_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both matchLabelKeys and labelSelector.
        Also, matchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
        '''
        result = self._values.get("match_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def mismatch_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
        Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
        '''
        result = self._values.get("mismatch_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field
        and the ones selected by namespaceSelector.
        null or empty namespaces list and null namespaceSelector means "this pod's namespace".

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"]:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc78dc74fd53a58831cc40070fe22834ba8ac994719faddfcb938e93820b545d)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20b0a3b4f6ff147a4fef103ea677aaa44ba007fb2c4f3e6d4ffc77214fd708c8)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7ffd280994dbef38c5a78183776be2782c9f3235702a2ea447424df82d3d229)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eec9ff9904833d57461a79a3048d9e475d53da194932f47a1ec30b6580dc4662)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "match_label_keys": "matchLabelKeys",
        "mismatch_label_keys": "mismatchLabelKeys",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key  matches that of any node on which a pod of the set of pods is running.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
        :param match_label_keys: MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param mismatch_label_keys: MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
        :param namespace_selector: A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b958e73a151d8663f58e65f4a1a85188031259055252bf85d42652ec424e304c)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument match_label_keys", value=match_label_keys, expected_type=type_hints["match_label_keys"])
            check_type(argname="argument mismatch_label_keys", value=mismatch_label_keys, expected_type=type_hints["mismatch_label_keys"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if match_label_keys is not None:
            self._values["match_label_keys"] = match_label_keys
        if mismatch_label_keys is not None:
            self._values["mismatch_label_keys"] = mismatch_label_keys
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def match_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both matchLabelKeys and labelSelector.
        Also, matchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
        '''
        result = self._values.get("match_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def mismatch_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
        Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
        '''
        result = self._values.get("mismatch_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field
        and the ones selected by namespaceSelector.
        null or empty namespaces list and null namespaceSelector means "this pod's namespace".

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"]:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff56d2e90ef2477a07cd8e189c6106fd966cc625b905245f658d1d59ac0843fa)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f6a39fbc397d8c9cfe4424570ce05458917b87b5ee8ecdc49c2cafb54f465b0)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5bf574661c7b55c2f0b2c69b96050bd01206493dc9d2a7529d729a4e681c32a1)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fdefe5a9c76dfa76dcebc24be03c293868e02cbb0daf0ad04cd54eb5333d07ae)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).

        :param preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        :param required_during_scheduling_ignored_during_execution: If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b0c80fecb5420c9672db1b2dcdd247fad8af66d44f8da024706faadf0200a72f)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.

        The node that is
        most preferred is the one with the greatest sum of weights, i.e.
        for each node that meets all of the scheduling requirements (resource
        request, requiredDuringScheduling anti-affinity expressions, etc.),
        compute a sum by iterating through the elements of this field and adding
        "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
        node(s) with the highest sum are the most preferred.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the anti-affinity requirements specified by this field cease to be met
        at some point during pod execution (e.g. due to a pod label update), the
        system may or may not try to eventually evict the pod from its node.
        When there are multiple elements, the lists of nodes corresponding to each
        podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[builtins.str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s).

        :param pod_affinity_term: Required. A pod affinity term, associated with the corresponding weight.
        :param weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__53a2997a359adbfe6602666a4c623602d8c436799d0cf02377f6050e0f3f0cd1)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''Required.

        A pod affinity term, associated with the corresponding weight.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "match_label_keys": "matchLabelKeys",
        "mismatch_label_keys": "mismatchLabelKeys",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Required.

        A pod affinity term, associated with the corresponding weight.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
        :param match_label_keys: MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param mismatch_label_keys: MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
        :param namespace_selector: A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a653e9d14401afd5215ec04827cd64b465b488875c87e7df8cd8fe989983b34)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument match_label_keys", value=match_label_keys, expected_type=type_hints["match_label_keys"])
            check_type(argname="argument mismatch_label_keys", value=mismatch_label_keys, expected_type=type_hints["mismatch_label_keys"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if match_label_keys is not None:
            self._values["match_label_keys"] = match_label_keys
        if mismatch_label_keys is not None:
            self._values["mismatch_label_keys"] = mismatch_label_keys
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def match_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both matchLabelKeys and labelSelector.
        Also, matchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
        '''
        result = self._values.get("match_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def mismatch_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
        Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
        '''
        result = self._values.get("mismatch_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field
        and the ones selected by namespaceSelector.
        null or empty namespaces list and null namespaceSelector means "this pod's namespace".

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"]:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ef82c8f1d943a9b522fde523ba68265235c3c38f74f933357f70752c898c2ae)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d390a6fe0a058186061a85f48a8747c7b1e897889205a325dd80fc1cfeca711)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a5de2d23344e620e526ad113aa2e91d78ff6342b785c039cc7ecbd6cee3f20d)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b44468eb27560277471aef7958fd02e3f8bb43fa66cd088ea4d54f7a2405741)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "match_label_keys": "matchLabelKeys",
        "mismatch_label_keys": "mismatchLabelKeys",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key  matches that of any node on which a pod of the set of pods is running.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
        :param match_label_keys: MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param mismatch_label_keys: MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
        :param namespace_selector: A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ef05fd52779302a037edd766860d2ada54606d5480e30dc14a2d608309784ae)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument match_label_keys", value=match_label_keys, expected_type=type_hints["match_label_keys"])
            check_type(argname="argument mismatch_label_keys", value=mismatch_label_keys, expected_type=type_hints["mismatch_label_keys"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if match_label_keys is not None:
            self._values["match_label_keys"] = match_label_keys
        if mismatch_label_keys is not None:
            self._values["mismatch_label_keys"] = mismatch_label_keys
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def match_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both matchLabelKeys and labelSelector.
        Also, matchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
        '''
        result = self._values.get("match_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def mismatch_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
        Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
        '''
        result = self._values.get("mismatch_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field
        and the ones selected by namespaceSelector.
        null or empty namespaces list and null namespaceSelector means "this pod's namespace".

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"]:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__922a4bda926ac2288c8a665d1de6b49c45cd6b49fd5cee91415d620291446ce5)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3624b8580e43c267f0ca660a8384c3a3b1b431f5e57316c4b3e7ae29d226a4b8)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08de91c5d00c89cba34c53ca1c21fccd969a8a66c1787d0ce4689d8482a8577b)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b470fd0f4e5b7a22a2711d813fbc59824ad95ab81226d8982371341f141ad063)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.

        :param name: Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4d881ebf21caad87893689c0f054678a07e63b52512b7665af1255c35c91a55)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the referent.

        This field is effectively required, but due to backwards compatibility is
        allowed to be empty. Instances of this type with an empty value here are
        almost certainly wrong.
        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "fs_group": "fsGroup",
        "fs_group_change_policy": "fsGroupChangePolicy",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "supplemental_groups": "supplementalGroups",
        "sysctls": "sysctls",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext:
    def __init__(
        self,
        *,
        fs_group: typing.Optional[jsii.Number] = None,
        fs_group_change_policy: typing.Optional[builtins.str] = None,
        run_as_group: typing.Optional[jsii.Number] = None,
        run_as_non_root: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
        seccomp_profile: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile", typing.Dict[builtins.str, typing.Any]]] = None,
        se_linux_options: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions", typing.Dict[builtins.str, typing.Any]]] = None,
        supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
        sysctls: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''If specified, the pod's security context.

        :param fs_group: A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
        :param fs_group_change_policy: fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
        :param run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
        :param run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows. Default: user specified in image metadata if unspecified.
        :param seccomp_profile: The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        :param se_linux_options: The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
        :param supplemental_groups: A list of groups applied to the first process run in each container, in addition to the container's primary GID, the fsGroup (if specified), and group memberships defined in the container image for the uid of the container process. If unspecified, no additional groups are added to any container. Note that group memberships defined in the container image for the uid of the container process are still effective, even if they are not included in this list. Note that this field cannot be set when spec.os.name is windows.
        :param sysctls: Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext
        '''
        if isinstance(seccomp_profile, dict):
            seccomp_profile = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile(**seccomp_profile)
        if isinstance(se_linux_options, dict):
            se_linux_options = ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions(**se_linux_options)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__debea53128a69da47218cb1df33d84cd46e8b37ce5a2b5087cb56576aa478fdb)
            check_type(argname="argument fs_group", value=fs_group, expected_type=type_hints["fs_group"])
            check_type(argname="argument fs_group_change_policy", value=fs_group_change_policy, expected_type=type_hints["fs_group_change_policy"])
            check_type(argname="argument run_as_group", value=run_as_group, expected_type=type_hints["run_as_group"])
            check_type(argname="argument run_as_non_root", value=run_as_non_root, expected_type=type_hints["run_as_non_root"])
            check_type(argname="argument run_as_user", value=run_as_user, expected_type=type_hints["run_as_user"])
            check_type(argname="argument seccomp_profile", value=seccomp_profile, expected_type=type_hints["seccomp_profile"])
            check_type(argname="argument se_linux_options", value=se_linux_options, expected_type=type_hints["se_linux_options"])
            check_type(argname="argument supplemental_groups", value=supplemental_groups, expected_type=type_hints["supplemental_groups"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if fs_group is not None:
            self._values["fs_group"] = fs_group
        if fs_group_change_policy is not None:
            self._values["fs_group_change_policy"] = fs_group_change_policy
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if supplemental_groups is not None:
            self._values["supplemental_groups"] = supplemental_groups
        if sysctls is not None:
            self._values["sysctls"] = sysctls

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''A special supplemental group that applies to all containers in a pod.

        Some volume types allow the Kubelet to change the ownership of that volume
        to be owned by the pod:

        1. The owning GID will be the FSGroup
        2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
        3. The permission bits are OR'd with rw-rw----

        If unset, the Kubelet will not modify the ownership and permissions of any volume.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#fsGroup
        '''
        result = self._values.get("fs_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_group_change_policy(self) -> typing.Optional[builtins.str]:
        '''fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod.

        This field will only apply to
        volume types which support fsGroup based ownership(and permissions).
        It will have no effect on ephemeral volume types such as: secret, configmaps
        and emptydir.
        Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#fsGroupChangePolicy
        '''
        result = self._values.get("fs_group_change_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[jsii.Number]:
        '''The GID to run the entrypoint of the container process.

        Uses runtime default if unset.
        May also be set in SecurityContext.  If set in both SecurityContext and
        PodSecurityContext, the value specified in SecurityContext takes precedence
        for that container.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#runAsGroup
        '''
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def run_as_non_root(self) -> typing.Optional[builtins.bool]:
        '''Indicates that the container must run as a non-root user.

        If true, the Kubelet will validate the image at runtime to ensure that it
        does not run as UID 0 (root) and fail to start the container if it does.
        If unset or false, no such validation will be performed.
        May also be set in SecurityContext.  If set in both SecurityContext and
        PodSecurityContext, the value specified in SecurityContext takes precedence.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#runAsNonRoot
        '''
        result = self._values.get("run_as_non_root")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''The UID to run the entrypoint of the container process.

        Defaults to user specified in image metadata if unspecified.
        May also be set in SecurityContext.  If set in both SecurityContext and
        PodSecurityContext, the value specified in SecurityContext takes precedence
        for that container.
        Note that this field cannot be set when spec.os.name is windows.

        :default: user specified in image metadata if unspecified.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#runAsUser
        '''
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile"]:
        '''The seccomp options to use by the containers in this pod.

        Note that this field cannot be set when spec.os.name is windows.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#seccompProfile
        '''
        result = self._values.get("seccomp_profile")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile"], result)

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions"]:
        '''The SELinux context to be applied to all containers.

        If unspecified, the container runtime will allocate a random SELinux context for each
        container.  May also be set in SecurityContext.  If set in
        both SecurityContext and PodSecurityContext, the value specified in SecurityContext
        takes precedence for that container.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#seLinuxOptions
        '''
        result = self._values.get("se_linux_options")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions"], result)

    @builtins.property
    def supplemental_groups(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''A list of groups applied to the first process run in each container, in addition to the container's primary GID, the fsGroup (if specified), and group memberships defined in the container image for the uid of the container process.

        If unspecified,
        no additional groups are added to any container. Note that group memberships
        defined in the container image for the uid of the container process are still effective,
        even if they are not included in this list.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#supplementalGroups
        '''
        result = self._values.get("supplemental_groups")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def sysctls(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls"]]:
        '''Sysctls hold a list of namespaced sysctls used for the pod.

        Pods with unsupported
        sysctls (by the container runtime) might fail to launch.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#sysctls
        '''
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SELinux context to be applied to all containers.

        If unspecified, the container runtime will allocate a random SELinux context for each
        container.  May also be set in SecurityContext.  If set in
        both SecurityContext and PodSecurityContext, the value specified in SecurityContext
        takes precedence for that container.
        Note that this field cannot be set when spec.os.name is windows.

        :param level: Level is SELinux level label that applies to the container.
        :param role: Role is a SELinux role label that applies to the container.
        :param type: Type is a SELinux type label that applies to the container.
        :param user: User is a SELinux user label that applies to the container.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af86ab2d62edef9e01107cf38b3f976db64ac316fdcfb5b201f4a2883b0a7fd3)
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        '''Level is SELinux level label that applies to the container.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions#level
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a SELinux role label that applies to the container.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''Type is a SELinux type label that applies to the container.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''User is a SELinux user label that applies to the container.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "localhost_profile": "localhostProfile"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        type: builtins.str,
        localhost_profile: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The seccomp options to use by the containers in this pod.

        Note that this field cannot be set when spec.os.name is windows.

        :param type: type indicates which kind of seccomp profile will be applied. Valid options are:. Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
        :param localhost_profile: localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any other type.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9017b2de35bded1cf84d1b3c5303254f546be827c465e49d160d21c625c671a3)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument localhost_profile", value=localhost_profile, expected_type=type_hints["localhost_profile"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "type": type,
        }
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile

    @builtins.property
    def type(self) -> builtins.str:
        '''type indicates which kind of seccomp profile will be applied. Valid options are:.

        Localhost - a profile defined in a file on the node should be used.
        RuntimeDefault - the container runtime default profile should be used.
        Unconfined - no profile should be applied.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        '''localhostProfile indicates a profile defined in a file on the node should be used.

        The profile must be preconfigured on the node to work.
        Must be a descending path, relative to the kubelet's configured seccomp profile location.
        Must be set if type is "Localhost". Must NOT be set for any other type.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile#localhostProfile
        '''
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''Sysctl defines a kernel parameter to be set.

        :param name: Name of a property to set.
        :param value: Value of a property to set.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__148191a61f7c4554990dcae07ef979e9810dd461f608dce33254640d25475b49)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of a property to set.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''Value of a property to set.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations",
    jsii_struct_bases=[],
    name_mapping={
        "effect": "effect",
        "key": "key",
        "operator": "operator",
        "toleration_seconds": "tolerationSeconds",
        "value": "value",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations:
    def __init__(
        self,
        *,
        effect: typing.Optional[builtins.str] = None,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        toleration_seconds: typing.Optional[jsii.Number] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator .

        :param effect: Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        :param key: Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        :param operator: Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category. Default: Equal.
        :param toleration_seconds: TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        :param value: Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f52d399b815cad81d8dbe3175983c4bd6d8183282a32c799f0ec22a7fc01ce8a)
            check_type(argname="argument effect", value=effect, expected_type=type_hints["effect"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument toleration_seconds", value=toleration_seconds, expected_type=type_hints["toleration_seconds"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if effect is not None:
            self._values["effect"] = effect
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if toleration_seconds is not None:
            self._values["toleration_seconds"] = toleration_seconds
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def effect(self) -> typing.Optional[builtins.str]:
        '''Effect indicates the taint effect to match.

        Empty means match all taint effects.
        When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations#effect
        '''
        result = self._values.get("effect")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''Key is the taint key that the toleration applies to.

        Empty means match all taint keys.
        If the key is empty, operator must be Exists; this combination means to match all values and all keys.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''Operator represents a key's relationship to the value.

        Valid operators are Exists and Equal. Defaults to Equal.
        Exists is equivalent to wildcard for value, so that a pod can
        tolerate all taints of a particular category.

        :default: Equal.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations#operator
        '''
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def toleration_seconds(self) -> typing.Optional[jsii.Number]:
        '''TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.

        By default,
        it is not set, which means tolerate the taint forever (do not evict). Zero and
        negative values will be treated as 0 (evict immediately) by the system.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations#tolerationSeconds
        '''
        result = self._values.get("toleration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value is the taint value the toleration matches to.

        If the operator is Exists, the value should be empty, otherwise just a regular string.

        :schema: ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01Ingress",
    jsii_struct_bases=[],
    name_mapping={
        "class_": "class",
        "ingress_class_name": "ingressClassName",
        "ingress_template": "ingressTemplate",
        "name": "name",
        "pod_template": "podTemplate",
        "service_type": "serviceType",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01Ingress:
    def __init__(
        self,
        *,
        class_: typing.Optional[builtins.str] = None,
        ingress_class_name: typing.Optional[builtins.str] = None,
        ingress_template: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplate", typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        pod_template: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplate", typing.Dict[builtins.str, typing.Any]]] = None,
        service_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The ingress based HTTP01 challenge solver will solve challenges by creating or modifying Ingress resources in order to route requests for '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are provisioned by cert-manager for each Challenge to be completed.

        :param class_: This field configures the annotation ``kubernetes.io/ingress.class`` when creating Ingress resources to solve ACME challenges that use this challenge solver. Only one of ``class``, ``name`` or ``ingressClassName`` may be specified.
        :param ingress_class_name: This field configures the field ``ingressClassName`` on the created Ingress resources used to solve ACME challenges that use this challenge solver. This is the recommended way of configuring the ingress class. Only one of ``class``, ``name`` or ``ingressClassName`` may be specified.
        :param ingress_template: Optional ingress template used to configure the ACME challenge solver ingress used for HTTP01 challenges.
        :param name: The name of the ingress resource that should have ACME challenge solving routes inserted into it in order to solve HTTP01 challenges. This is typically used in conjunction with ingress controllers like ingress-gce, which maintains a 1:1 mapping between external IPs and ingress resources. Only one of ``class``, ``name`` or ``ingressClassName`` may be specified.
        :param pod_template: Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges.
        :param service_type: Optional service type for Kubernetes solver service. Supported values are NodePort or ClusterIP. If unset, defaults to NodePort.

        :schema: ClusterIssuerSpecAcmeSolversHttp01Ingress
        '''
        if isinstance(ingress_template, dict):
            ingress_template = ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplate(**ingress_template)
        if isinstance(pod_template, dict):
            pod_template = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplate(**pod_template)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a720dde644fba8c669808252bfdddf246b1094bdd471540372e5a5a294889f03)
            check_type(argname="argument class_", value=class_, expected_type=type_hints["class_"])
            check_type(argname="argument ingress_class_name", value=ingress_class_name, expected_type=type_hints["ingress_class_name"])
            check_type(argname="argument ingress_template", value=ingress_template, expected_type=type_hints["ingress_template"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument pod_template", value=pod_template, expected_type=type_hints["pod_template"])
            check_type(argname="argument service_type", value=service_type, expected_type=type_hints["service_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if class_ is not None:
            self._values["class_"] = class_
        if ingress_class_name is not None:
            self._values["ingress_class_name"] = ingress_class_name
        if ingress_template is not None:
            self._values["ingress_template"] = ingress_template
        if name is not None:
            self._values["name"] = name
        if pod_template is not None:
            self._values["pod_template"] = pod_template
        if service_type is not None:
            self._values["service_type"] = service_type

    @builtins.property
    def class_(self) -> typing.Optional[builtins.str]:
        '''This field configures the annotation ``kubernetes.io/ingress.class`` when creating Ingress resources to solve ACME challenges that use this challenge solver. Only one of ``class``, ``name`` or ``ingressClassName`` may be specified.

        :schema: ClusterIssuerSpecAcmeSolversHttp01Ingress#class
        '''
        result = self._values.get("class_")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ingress_class_name(self) -> typing.Optional[builtins.str]:
        '''This field configures the field ``ingressClassName`` on the created Ingress resources used to solve ACME challenges that use this challenge solver.

        This is the recommended way of configuring the ingress class. Only one of
        ``class``, ``name`` or ``ingressClassName`` may be specified.

        :schema: ClusterIssuerSpecAcmeSolversHttp01Ingress#ingressClassName
        '''
        result = self._values.get("ingress_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ingress_template(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplate"]:
        '''Optional ingress template used to configure the ACME challenge solver ingress used for HTTP01 challenges.

        :schema: ClusterIssuerSpecAcmeSolversHttp01Ingress#ingressTemplate
        '''
        result = self._values.get("ingress_template")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplate"], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the ingress resource that should have ACME challenge solving routes inserted into it in order to solve HTTP01 challenges.

        This is typically used in conjunction with ingress controllers like
        ingress-gce, which maintains a 1:1 mapping between external IPs and
        ingress resources. Only one of ``class``, ``name`` or ``ingressClassName`` may
        be specified.

        :schema: ClusterIssuerSpecAcmeSolversHttp01Ingress#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pod_template(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplate"]:
        '''Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges.

        :schema: ClusterIssuerSpecAcmeSolversHttp01Ingress#podTemplate
        '''
        result = self._values.get("pod_template")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplate"], result)

    @builtins.property
    def service_type(self) -> typing.Optional[builtins.str]:
        '''Optional service type for Kubernetes solver service.

        Supported values
        are NodePort or ClusterIP. If unset, defaults to NodePort.

        :schema: ClusterIssuerSpecAcmeSolversHttp01Ingress#serviceType
        '''
        result = self._values.get("service_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01Ingress(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplate",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplate:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Optional ingress template used to configure the ACME challenge solver ingress used for HTTP01 challenges.

        :param metadata: ObjectMeta overrides for the ingress used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplate
        '''
        if isinstance(metadata, dict):
            metadata = ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata(**metadata)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c63fcac5c407168aabeae72c1a52b078dc5b17ff09dfedd6221987d352fe6b18)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata"]:
        '''ObjectMeta overrides for the ingress used to solve HTTP01 challenges.

        Only the 'labels' and 'annotations' fields may be set.
        If labels or annotations overlap with in-built values, the values here
        will override the in-built values.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={"annotations": "annotations", "labels": "labels"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''ObjectMeta overrides for the ingress used to solve HTTP01 challenges.

        Only the 'labels' and 'annotations' fields may be set.
        If labels or annotations overlap with in-built values, the values here
        will override the in-built values.

        :param annotations: Annotations that should be added to the created ACME HTTP01 solver ingress.
        :param labels: Labels that should be added to the created ACME HTTP01 solver ingress.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__507f575ac6ba37a1d3398c82a410ebbda5d3ea99a8da7b15d8627c913c9e7f0c)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Annotations that should be added to the created ACME HTTP01 solver ingress.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Labels that should be added to the created ACME HTTP01 solver ingress.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplate",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplate:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata", typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges.

        :param metadata: ObjectMeta overrides for the pod used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
        :param spec: PodSpec defines overrides for the HTTP01 challenge solver pod. Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields. All other fields will be ignored.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplate
        '''
        if isinstance(metadata, dict):
            metadata = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata(**metadata)
        if isinstance(spec, dict):
            spec = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpec(**spec)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d90302ec2794d87360f5d2508bcfdbdf7f220da08fe703d46d79b5c9b8dfb1a4)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata"]:
        '''ObjectMeta overrides for the pod used to solve HTTP01 challenges.

        Only the 'labels' and 'annotations' fields may be set.
        If labels or annotations overlap with in-built values, the values here
        will override the in-built values.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata"], result)

    @builtins.property
    def spec(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpec"]:
        '''PodSpec defines overrides for the HTTP01 challenge solver pod.

        Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
        All other fields will be ignored.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplate#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={"annotations": "annotations", "labels": "labels"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''ObjectMeta overrides for the pod used to solve HTTP01 challenges.

        Only the 'labels' and 'annotations' fields may be set.
        If labels or annotations overlap with in-built values, the values here
        will override the in-built values.

        :param annotations: Annotations that should be added to the created ACME HTTP01 solver pods.
        :param labels: Labels that should be added to the created ACME HTTP01 solver pods.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3541848f3d4ba60cfd964fe9b510eb398fe1b307ad60a6bd049af5dfcaa41a96)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Annotations that should be added to the created ACME HTTP01 solver pods.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Labels that should be added to the created ACME HTTP01 solver pods.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpec",
    jsii_struct_bases=[],
    name_mapping={
        "affinity": "affinity",
        "image_pull_secrets": "imagePullSecrets",
        "node_selector": "nodeSelector",
        "priority_class_name": "priorityClassName",
        "security_context": "securityContext",
        "service_account_name": "serviceAccountName",
        "tolerations": "tolerations",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpec:
    def __init__(
        self,
        *,
        affinity: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
        image_pull_secrets: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets", typing.Dict[builtins.str, typing.Any]]]] = None,
        node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        priority_class_name: typing.Optional[builtins.str] = None,
        security_context: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        tolerations: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''PodSpec defines overrides for the HTTP01 challenge solver pod.

        Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
        All other fields will be ignored.

        :param affinity: If specified, the pod's scheduling constraints.
        :param image_pull_secrets: If specified, the pod's imagePullSecrets.
        :param node_selector: NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
        :param priority_class_name: If specified, the pod's priorityClassName.
        :param security_context: If specified, the pod's security context.
        :param service_account_name: If specified, the pod's service account.
        :param tolerations: If specified, the pod's tolerations.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpec
        '''
        if isinstance(affinity, dict):
            affinity = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity(**affinity)
        if isinstance(security_context, dict):
            security_context = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext(**security_context)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4082788f85069495db77b430f60b9d3e1dbf86e381483a94cfe1baf2026fe9eb)
            check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
            check_type(argname="argument image_pull_secrets", value=image_pull_secrets, expected_type=type_hints["image_pull_secrets"])
            check_type(argname="argument node_selector", value=node_selector, expected_type=type_hints["node_selector"])
            check_type(argname="argument priority_class_name", value=priority_class_name, expected_type=type_hints["priority_class_name"])
            check_type(argname="argument security_context", value=security_context, expected_type=type_hints["security_context"])
            check_type(argname="argument service_account_name", value=service_account_name, expected_type=type_hints["service_account_name"])
            check_type(argname="argument tolerations", value=tolerations, expected_type=type_hints["tolerations"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if affinity is not None:
            self._values["affinity"] = affinity
        if image_pull_secrets is not None:
            self._values["image_pull_secrets"] = image_pull_secrets
        if node_selector is not None:
            self._values["node_selector"] = node_selector
        if priority_class_name is not None:
            self._values["priority_class_name"] = priority_class_name
        if security_context is not None:
            self._values["security_context"] = security_context
        if service_account_name is not None:
            self._values["service_account_name"] = service_account_name
        if tolerations is not None:
            self._values["tolerations"] = tolerations

    @builtins.property
    def affinity(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity"]:
        '''If specified, the pod's scheduling constraints.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#affinity
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity"], result)

    @builtins.property
    def image_pull_secrets(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets"]]:
        '''If specified, the pod's imagePullSecrets.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#imagePullSecrets
        '''
        result = self._values.get("image_pull_secrets")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets"]], result)

    @builtins.property
    def node_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''NodeSelector is a selector which must be true for the pod to fit on a node.

        Selector which must match a node's labels for the pod to be scheduled on that node.
        More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#nodeSelector
        '''
        result = self._values.get("node_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def priority_class_name(self) -> typing.Optional[builtins.str]:
        '''If specified, the pod's priorityClassName.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#priorityClassName
        '''
        result = self._values.get("priority_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_context(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext"]:
        '''If specified, the pod's security context.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#securityContext
        '''
        result = self._values.get("security_context")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext"], result)

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        '''If specified, the pod's service account.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#serviceAccountName
        '''
        result = self._values.get("service_account_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tolerations(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations"]]:
        '''If specified, the pod's tolerations.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#tolerations
        '''
        result = self._values.get("tolerations")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "node_affinity": "nodeAffinity",
        "pod_affinity": "podAffinity",
        "pod_anti_affinity": "podAntiAffinity",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity:
    def __init__(
        self,
        *,
        node_affinity: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_affinity: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_anti_affinity: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''If specified, the pod's scheduling constraints.

        :param node_affinity: Describes node affinity scheduling rules for the pod.
        :param pod_affinity: Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
        :param pod_anti_affinity: Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity
        '''
        if isinstance(node_affinity, dict):
            node_affinity = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity(**node_affinity)
        if isinstance(pod_affinity, dict):
            pod_affinity = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity(**pod_affinity)
        if isinstance(pod_anti_affinity, dict):
            pod_anti_affinity = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity(**pod_anti_affinity)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a2aaf1a37a5bb08e5aea04b27b2325d057eeff195984cc4f8b610da647f3cb6)
            check_type(argname="argument node_affinity", value=node_affinity, expected_type=type_hints["node_affinity"])
            check_type(argname="argument pod_affinity", value=pod_affinity, expected_type=type_hints["pod_affinity"])
            check_type(argname="argument pod_anti_affinity", value=pod_anti_affinity, expected_type=type_hints["pod_anti_affinity"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if node_affinity is not None:
            self._values["node_affinity"] = node_affinity
        if pod_affinity is not None:
            self._values["pod_affinity"] = pod_affinity
        if pod_anti_affinity is not None:
            self._values["pod_anti_affinity"] = pod_anti_affinity

    @builtins.property
    def node_affinity(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity"]:
        '''Describes node affinity scheduling rules for the pod.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity#nodeAffinity
        '''
        result = self._values.get("node_affinity")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity"], result)

    @builtins.property
    def pod_affinity(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity"]:
        '''Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity#podAffinity
        '''
        result = self._values.get("pod_affinity")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity"], result)

    @builtins.property
    def pod_anti_affinity(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity"]:
        '''Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity#podAntiAffinity
        '''
        result = self._values.get("pod_anti_affinity")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Describes node affinity scheduling rules for the pod.

        :param preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
        :param required_during_scheduling_ignored_during_execution: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity
        '''
        if isinstance(required_during_scheduling_ignored_during_execution, dict):
            required_during_scheduling_ignored_during_execution = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(**required_during_scheduling_ignored_during_execution)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de3b6cdecbd7ff31a805ddbf09ac1f0a78e29d5d13f884a97d9559784d9322b7)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.

        The node that is
        most preferred is the one with the greatest sum of weights, i.e.
        for each node that meets all of the scheduling requirements (resource
        request, requiredDuringScheduling affinity expressions, etc.),
        compute a sum by iterating through the elements of this field and adding
        "weight" to the sum if the node matches the corresponding matchExpressions; the
        node(s) with the highest sum are the most preferred.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"]:
        '''If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the affinity requirements specified by this field cease to be met
        at some point during pod execution (e.g. due to an update), the system
        may or may not try to eventually evict the pod from its node.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"preference": "preference", "weight": "weight"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        preference: typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", typing.Dict[builtins.str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).

        :param preference: A node selector term, associated with the corresponding weight.
        :param weight: Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(preference, dict):
            preference = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(**preference)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c4b9a725821038131fc840c0f515c0c06d807317bfea79009457d6f879f9917)
            check_type(argname="argument preference", value=preference, expected_type=type_hints["preference"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "preference": preference,
            "weight": weight,
        }

    @builtins.property
    def preference(
        self,
    ) -> "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference":
        '''A node selector term, associated with the corresponding weight.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
        '''
        result = self._values.get("preference")
        assert result is not None, "Required property 'preference' is missing"
        return typing.cast("ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''A node selector term, associated with the corresponding weight.

        :param match_expressions: A list of node selector requirements by node's labels.
        :param match_fields: A list of node selector requirements by node's fields.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e8ab675b045fcce43974cf0b13aaca07a8cc0e59d3ad444131dca6290dc433a4)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]]:
        '''A list of node selector requirements by node's labels.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]]:
        '''A list of node selector requirements by node's fields.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__90aba9d4794e2c06ea1672b07d00ada32e49cf685153ff7effd35a9f8165dd59)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''The label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''Represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. If the operator is Gt or Lt, the values
        array must have a single element, which will be interpreted as an integer.
        This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd86516d5340b0d5eaf8dc0d3f0ef77bdc81fedcb143be0067a32d3e06d261ee)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''The label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''Represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. If the operator is Gt or Lt, the values
        array must have a single element, which will be interpreted as an integer.
        This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"node_selector_terms": "nodeSelectorTerms"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        node_selector_terms: typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms", typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the affinity requirements specified by this field cease to be met
        at some point during pod execution (e.g. due to an update), the system
        may or may not try to eventually evict the pod from its node.

        :param node_selector_terms: Required. A list of node selector terms. The terms are ORed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b7897a3e72bba9f371616afc9be2c4cc6eaf7f3822ffe976730db1dda9b3d34b)
            check_type(argname="argument node_selector_terms", value=node_selector_terms, expected_type=type_hints["node_selector_terms"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "node_selector_terms": node_selector_terms,
        }

    @builtins.property
    def node_selector_terms(
        self,
    ) -> typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"]:
        '''Required.

        A list of node selector terms. The terms are ORed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
        '''
        result = self._values.get("node_selector_terms")
        assert result is not None, "Required property 'node_selector_terms' is missing"
        return typing.cast(typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''A null or empty node selector term matches no objects.

        The requirements of
        them are ANDed.
        The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.

        :param match_expressions: A list of node selector requirements by node's labels.
        :param match_fields: A list of node selector requirements by node's fields.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c39be703080f8b3c9aa6769cda1c13621e6a6bada7cec7c49a1f0f9e71f1c71)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]]:
        '''A list of node selector requirements by node's labels.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]]:
        '''A list of node selector requirements by node's fields.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7c1f05a20f8d0cda4a85f74170f5268b0ae9cdfea1b5730cdd2a2adc0a79d0e4)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''The label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''Represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. If the operator is Gt or Lt, the values
        array must have a single element, which will be interpreted as an integer.
        This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9781e3bdc4b9e774cb47302c2f3f501df617e4e9874dd80857d6e3918e25210)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''The label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''Represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. If the operator is Gt or Lt, the values
        array must have a single element, which will be interpreted as an integer.
        This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).

        :param preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        :param required_during_scheduling_ignored_during_execution: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d62c1e77f851045817786d440dc82b46b009f14ee02d0f01f216a77433037444)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.

        The node that is
        most preferred is the one with the greatest sum of weights, i.e.
        for each node that meets all of the scheduling requirements (resource
        request, requiredDuringScheduling affinity expressions, etc.),
        compute a sum by iterating through the elements of this field and adding
        "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
        node(s) with the highest sum are the most preferred.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the affinity requirements specified by this field cease to be met
        at some point during pod execution (e.g. due to a pod label update), the
        system may or may not try to eventually evict the pod from its node.
        When there are multiple elements, the lists of nodes corresponding to each
        podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[builtins.str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s).

        :param pod_affinity_term: Required. A pod affinity term, associated with the corresponding weight.
        :param weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__baec54efda724a7864b1f53a11538e8e16c1d27722bed5c970fc9329b5ca94f8)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''Required.

        A pod affinity term, associated with the corresponding weight.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "match_label_keys": "matchLabelKeys",
        "mismatch_label_keys": "mismatchLabelKeys",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Required.

        A pod affinity term, associated with the corresponding weight.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
        :param match_label_keys: MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param mismatch_label_keys: MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
        :param namespace_selector: A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c443e39a0ee5185fa8c2b58f988c0d9495fd49d0b5719b913e3b2ff9f4fa597b)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument match_label_keys", value=match_label_keys, expected_type=type_hints["match_label_keys"])
            check_type(argname="argument mismatch_label_keys", value=mismatch_label_keys, expected_type=type_hints["mismatch_label_keys"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if match_label_keys is not None:
            self._values["match_label_keys"] = match_label_keys
        if mismatch_label_keys is not None:
            self._values["mismatch_label_keys"] = mismatch_label_keys
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def match_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both matchLabelKeys and labelSelector.
        Also, matchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
        '''
        result = self._values.get("match_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def mismatch_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
        Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
        '''
        result = self._values.get("mismatch_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field
        and the ones selected by namespaceSelector.
        null or empty namespaces list and null namespaceSelector means "this pod's namespace".

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"]:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7590226e56e087ad8b333afc50eee96594768d8dc71d20bc02a1d2e6b56c1b4a)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d7106b63193204178633e1c79e70330d5f44f34dbfb73cb47fc6524d976b9db)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2aa0a6444a0153bef2e9873fb7a3aa7d9477833bc8834494d924f3576b6be75b)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ad9287c3b4a95fbd7a5c9c49cca49b8998e904aa7c1f2062d2b257626754d393)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "match_label_keys": "matchLabelKeys",
        "mismatch_label_keys": "mismatchLabelKeys",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key  matches that of any node on which a pod of the set of pods is running.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
        :param match_label_keys: MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param mismatch_label_keys: MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
        :param namespace_selector: A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__15330d752d39dc7168fb6668f6dc7efe43ae89cded48a41a660180f7e9e313db)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument match_label_keys", value=match_label_keys, expected_type=type_hints["match_label_keys"])
            check_type(argname="argument mismatch_label_keys", value=mismatch_label_keys, expected_type=type_hints["mismatch_label_keys"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if match_label_keys is not None:
            self._values["match_label_keys"] = match_label_keys
        if mismatch_label_keys is not None:
            self._values["mismatch_label_keys"] = mismatch_label_keys
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def match_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both matchLabelKeys and labelSelector.
        Also, matchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
        '''
        result = self._values.get("match_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def mismatch_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
        Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
        '''
        result = self._values.get("mismatch_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field
        and the ones selected by namespaceSelector.
        null or empty namespaces list and null namespaceSelector means "this pod's namespace".

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"]:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83f71e848ec163a209589fdc4a742c3880d1bf5d805ead5eaa9baa8c80428fc4)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8d17819cd2fa1c2e9cdac972bc34323e28d9fd699e084243b456e0aa163f267)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9466cfe9b51274395b80f88d30f8f4749bf3b4d22faa47d63b3e7beb9e0b7c8e)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__782786e8e2318891f61eac5ecbfb5c9a671b77b6b497fdb0456760353f8f73ab)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).

        :param preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        :param required_during_scheduling_ignored_during_execution: If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17d6a184cf4954ddb83b6eef8e524250ef279231baffdd3fee910b27f79115d6)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.

        The node that is
        most preferred is the one with the greatest sum of weights, i.e.
        for each node that meets all of the scheduling requirements (resource
        request, requiredDuringScheduling anti-affinity expressions, etc.),
        compute a sum by iterating through the elements of this field and adding
        "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
        node(s) with the highest sum are the most preferred.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the anti-affinity requirements specified by this field cease to be met
        at some point during pod execution (e.g. due to a pod label update), the
        system may or may not try to eventually evict the pod from its node.
        When there are multiple elements, the lists of nodes corresponding to each
        podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[builtins.str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s).

        :param pod_affinity_term: Required. A pod affinity term, associated with the corresponding weight.
        :param weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6eaefd0094fce1fd892af2ef8e1e98566ce3c5409ced57cdbe2894e135dd51f1)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''Required.

        A pod affinity term, associated with the corresponding weight.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "match_label_keys": "matchLabelKeys",
        "mismatch_label_keys": "mismatchLabelKeys",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Required.

        A pod affinity term, associated with the corresponding weight.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
        :param match_label_keys: MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param mismatch_label_keys: MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
        :param namespace_selector: A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__225dd50b57808ae80182044235c9daf23d6adca99fd986cce600e8c795004e24)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument match_label_keys", value=match_label_keys, expected_type=type_hints["match_label_keys"])
            check_type(argname="argument mismatch_label_keys", value=mismatch_label_keys, expected_type=type_hints["mismatch_label_keys"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if match_label_keys is not None:
            self._values["match_label_keys"] = match_label_keys
        if mismatch_label_keys is not None:
            self._values["mismatch_label_keys"] = mismatch_label_keys
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def match_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both matchLabelKeys and labelSelector.
        Also, matchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
        '''
        result = self._values.get("match_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def mismatch_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
        Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
        '''
        result = self._values.get("mismatch_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field
        and the ones selected by namespaceSelector.
        null or empty namespaces list and null namespaceSelector means "this pod's namespace".

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"]:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__011346a5dc8fa9c9d96eafbb4188de1f9c13f02b671b0a1dcac2d395e97e46aa)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8663aede452db48324b0bada63b5a395703f7eba782cb78945f95b31df8f3625)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a5e232294189661f38770ae7309891a436526ada2baac324a9f26747cd085d1a)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23cbef0f7e129b1edf245ca9e65f86288a29675718d84ae2144411a71fa18047)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "match_label_keys": "matchLabelKeys",
        "mismatch_label_keys": "mismatchLabelKeys",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key  matches that of any node on which a pod of the set of pods is running.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
        :param match_label_keys: MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param mismatch_label_keys: MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
        :param namespace_selector: A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e9216e2c43794490561b9a32b84439ef41d6e3d6e3b6dc5d78ca0a597d389b7)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument match_label_keys", value=match_label_keys, expected_type=type_hints["match_label_keys"])
            check_type(argname="argument mismatch_label_keys", value=mismatch_label_keys, expected_type=type_hints["mismatch_label_keys"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if match_label_keys is not None:
            self._values["match_label_keys"] = match_label_keys
        if mismatch_label_keys is not None:
            self._values["mismatch_label_keys"] = mismatch_label_keys
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def match_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both matchLabelKeys and labelSelector.
        Also, matchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
        '''
        result = self._values.get("match_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def mismatch_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
        Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
        '''
        result = self._values.get("mismatch_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field
        and the ones selected by namespaceSelector.
        null or empty namespaces list and null namespaceSelector means "this pod's namespace".

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"]:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e4c9785d8a6cd06c780e1a81e13ec13678fb25a443967198e39ef9916b63c59)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__104a293a48255adddcbccdddb08e2b794e3e018f832c5d2d9d8e59d6bf36aba9)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e1ab19a77ea7f3551b883e2df8275f26fd318f38ce8aabd8dcf3ad0fc484b2ee)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a17bf8f376c721c1add602f012d4fcba9d221d6c4c12b620e1f51ef889c9cfac)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.

        :param name: Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f6075c7872d9ff59615dd53aa961d600e79e7c3dcc8e73f89e8fee208d78d77)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the referent.

        This field is effectively required, but due to backwards compatibility is
        allowed to be empty. Instances of this type with an empty value here are
        almost certainly wrong.
        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "fs_group": "fsGroup",
        "fs_group_change_policy": "fsGroupChangePolicy",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "supplemental_groups": "supplementalGroups",
        "sysctls": "sysctls",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext:
    def __init__(
        self,
        *,
        fs_group: typing.Optional[jsii.Number] = None,
        fs_group_change_policy: typing.Optional[builtins.str] = None,
        run_as_group: typing.Optional[jsii.Number] = None,
        run_as_non_root: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
        seccomp_profile: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile", typing.Dict[builtins.str, typing.Any]]] = None,
        se_linux_options: typing.Optional[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions", typing.Dict[builtins.str, typing.Any]]] = None,
        supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
        sysctls: typing.Optional[typing.Sequence[typing.Union["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''If specified, the pod's security context.

        :param fs_group: A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
        :param fs_group_change_policy: fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
        :param run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
        :param run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows. Default: user specified in image metadata if unspecified.
        :param seccomp_profile: The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        :param se_linux_options: The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
        :param supplemental_groups: A list of groups applied to the first process run in each container, in addition to the container's primary GID, the fsGroup (if specified), and group memberships defined in the container image for the uid of the container process. If unspecified, no additional groups are added to any container. Note that group memberships defined in the container image for the uid of the container process are still effective, even if they are not included in this list. Note that this field cannot be set when spec.os.name is windows.
        :param sysctls: Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext
        '''
        if isinstance(seccomp_profile, dict):
            seccomp_profile = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile(**seccomp_profile)
        if isinstance(se_linux_options, dict):
            se_linux_options = ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions(**se_linux_options)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ffb1afb4835a5efd059bc76baeb9bc02e4bae8ca502e02946bc91211902a5da)
            check_type(argname="argument fs_group", value=fs_group, expected_type=type_hints["fs_group"])
            check_type(argname="argument fs_group_change_policy", value=fs_group_change_policy, expected_type=type_hints["fs_group_change_policy"])
            check_type(argname="argument run_as_group", value=run_as_group, expected_type=type_hints["run_as_group"])
            check_type(argname="argument run_as_non_root", value=run_as_non_root, expected_type=type_hints["run_as_non_root"])
            check_type(argname="argument run_as_user", value=run_as_user, expected_type=type_hints["run_as_user"])
            check_type(argname="argument seccomp_profile", value=seccomp_profile, expected_type=type_hints["seccomp_profile"])
            check_type(argname="argument se_linux_options", value=se_linux_options, expected_type=type_hints["se_linux_options"])
            check_type(argname="argument supplemental_groups", value=supplemental_groups, expected_type=type_hints["supplemental_groups"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if fs_group is not None:
            self._values["fs_group"] = fs_group
        if fs_group_change_policy is not None:
            self._values["fs_group_change_policy"] = fs_group_change_policy
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if supplemental_groups is not None:
            self._values["supplemental_groups"] = supplemental_groups
        if sysctls is not None:
            self._values["sysctls"] = sysctls

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''A special supplemental group that applies to all containers in a pod.

        Some volume types allow the Kubelet to change the ownership of that volume
        to be owned by the pod:

        1. The owning GID will be the FSGroup
        2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
        3. The permission bits are OR'd with rw-rw----

        If unset, the Kubelet will not modify the ownership and permissions of any volume.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#fsGroup
        '''
        result = self._values.get("fs_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_group_change_policy(self) -> typing.Optional[builtins.str]:
        '''fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod.

        This field will only apply to
        volume types which support fsGroup based ownership(and permissions).
        It will have no effect on ephemeral volume types such as: secret, configmaps
        and emptydir.
        Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#fsGroupChangePolicy
        '''
        result = self._values.get("fs_group_change_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[jsii.Number]:
        '''The GID to run the entrypoint of the container process.

        Uses runtime default if unset.
        May also be set in SecurityContext.  If set in both SecurityContext and
        PodSecurityContext, the value specified in SecurityContext takes precedence
        for that container.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#runAsGroup
        '''
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def run_as_non_root(self) -> typing.Optional[builtins.bool]:
        '''Indicates that the container must run as a non-root user.

        If true, the Kubelet will validate the image at runtime to ensure that it
        does not run as UID 0 (root) and fail to start the container if it does.
        If unset or false, no such validation will be performed.
        May also be set in SecurityContext.  If set in both SecurityContext and
        PodSecurityContext, the value specified in SecurityContext takes precedence.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#runAsNonRoot
        '''
        result = self._values.get("run_as_non_root")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''The UID to run the entrypoint of the container process.

        Defaults to user specified in image metadata if unspecified.
        May also be set in SecurityContext.  If set in both SecurityContext and
        PodSecurityContext, the value specified in SecurityContext takes precedence
        for that container.
        Note that this field cannot be set when spec.os.name is windows.

        :default: user specified in image metadata if unspecified.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#runAsUser
        '''
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile"]:
        '''The seccomp options to use by the containers in this pod.

        Note that this field cannot be set when spec.os.name is windows.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#seccompProfile
        '''
        result = self._values.get("seccomp_profile")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile"], result)

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions"]:
        '''The SELinux context to be applied to all containers.

        If unspecified, the container runtime will allocate a random SELinux context for each
        container.  May also be set in SecurityContext.  If set in
        both SecurityContext and PodSecurityContext, the value specified in SecurityContext
        takes precedence for that container.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#seLinuxOptions
        '''
        result = self._values.get("se_linux_options")
        return typing.cast(typing.Optional["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions"], result)

    @builtins.property
    def supplemental_groups(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''A list of groups applied to the first process run in each container, in addition to the container's primary GID, the fsGroup (if specified), and group memberships defined in the container image for the uid of the container process.

        If unspecified,
        no additional groups are added to any container. Note that group memberships
        defined in the container image for the uid of the container process are still effective,
        even if they are not included in this list.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#supplementalGroups
        '''
        result = self._values.get("supplemental_groups")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def sysctls(
        self,
    ) -> typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls"]]:
        '''Sysctls hold a list of namespaced sysctls used for the pod.

        Pods with unsupported
        sysctls (by the container runtime) might fail to launch.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#sysctls
        '''
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[typing.List["ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SELinux context to be applied to all containers.

        If unspecified, the container runtime will allocate a random SELinux context for each
        container.  May also be set in SecurityContext.  If set in
        both SecurityContext and PodSecurityContext, the value specified in SecurityContext
        takes precedence for that container.
        Note that this field cannot be set when spec.os.name is windows.

        :param level: Level is SELinux level label that applies to the container.
        :param role: Role is a SELinux role label that applies to the container.
        :param type: Type is a SELinux type label that applies to the container.
        :param user: User is a SELinux user label that applies to the container.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f61841e474a9b9b68e1ae3ea6c4920f8a8ba29f9281f5da5ab213bfe93bacbf9)
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        '''Level is SELinux level label that applies to the container.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions#level
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a SELinux role label that applies to the container.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''Type is a SELinux type label that applies to the container.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''User is a SELinux user label that applies to the container.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "localhost_profile": "localhostProfile"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        type: builtins.str,
        localhost_profile: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The seccomp options to use by the containers in this pod.

        Note that this field cannot be set when spec.os.name is windows.

        :param type: type indicates which kind of seccomp profile will be applied. Valid options are:. Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
        :param localhost_profile: localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any other type.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71fff328e189b6924e9815d9573b6e0c1b18d1553df2750dac7280a7ed43b052)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument localhost_profile", value=localhost_profile, expected_type=type_hints["localhost_profile"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "type": type,
        }
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile

    @builtins.property
    def type(self) -> builtins.str:
        '''type indicates which kind of seccomp profile will be applied. Valid options are:.

        Localhost - a profile defined in a file on the node should be used.
        RuntimeDefault - the container runtime default profile should be used.
        Unconfined - no profile should be applied.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        '''localhostProfile indicates a profile defined in a file on the node should be used.

        The profile must be preconfigured on the node to work.
        Must be a descending path, relative to the kubelet's configured seccomp profile location.
        Must be set if type is "Localhost". Must NOT be set for any other type.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile#localhostProfile
        '''
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''Sysctl defines a kernel parameter to be set.

        :param name: Name of a property to set.
        :param value: Value of a property to set.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2d921a119757411f575bee6ab134367ae51e2feda9914f5469a296a169f8dae)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of a property to set.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''Value of a property to set.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations",
    jsii_struct_bases=[],
    name_mapping={
        "effect": "effect",
        "key": "key",
        "operator": "operator",
        "toleration_seconds": "tolerationSeconds",
        "value": "value",
    },
)
class ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations:
    def __init__(
        self,
        *,
        effect: typing.Optional[builtins.str] = None,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        toleration_seconds: typing.Optional[jsii.Number] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator .

        :param effect: Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        :param key: Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        :param operator: Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category. Default: Equal.
        :param toleration_seconds: TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        :param value: Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4831c350ffe6e8a16e9604d414cc2ffd01407b72140ef576e027ec6e3acaff38)
            check_type(argname="argument effect", value=effect, expected_type=type_hints["effect"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument toleration_seconds", value=toleration_seconds, expected_type=type_hints["toleration_seconds"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if effect is not None:
            self._values["effect"] = effect
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if toleration_seconds is not None:
            self._values["toleration_seconds"] = toleration_seconds
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def effect(self) -> typing.Optional[builtins.str]:
        '''Effect indicates the taint effect to match.

        Empty means match all taint effects.
        When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations#effect
        '''
        result = self._values.get("effect")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''Key is the taint key that the toleration applies to.

        Empty means match all taint keys.
        If the key is empty, operator must be Exists; this combination means to match all values and all keys.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''Operator represents a key's relationship to the value.

        Valid operators are Exists and Equal. Defaults to Equal.
        Exists is equivalent to wildcard for value, so that a pod can
        tolerate all taints of a particular category.

        :default: Equal.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations#operator
        '''
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def toleration_seconds(self) -> typing.Optional[jsii.Number]:
        '''TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.

        By default,
        it is not set, which means tolerate the taint forever (do not evict). Zero and
        negative values will be treated as 0 (evict immediately) by the system.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations#tolerationSeconds
        '''
        result = self._values.get("toleration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value is the taint value the toleration matches to.

        If the operator is Exists, the value should be empty, otherwise just a regular string.

        :schema: ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecAcmeSolversSelector",
    jsii_struct_bases=[],
    name_mapping={
        "dns_names": "dnsNames",
        "dns_zones": "dnsZones",
        "match_labels": "matchLabels",
    },
)
class ClusterIssuerSpecAcmeSolversSelector:
    def __init__(
        self,
        *,
        dns_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        dns_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Selector selects a set of DNSNames on the Certificate resource that should be solved using this challenge solver.

        If not specified, the solver will be treated as the 'default' solver
        with the lowest priority, i.e. if any other solver has a more specific
        match, it will be used instead.

        :param dns_names: List of DNSNames that this solver will be used to solve. If specified and a match is found, a dnsNames selector will take precedence over a dnsZones selector. If multiple solvers match with the same dnsNames value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected.
        :param dns_zones: List of DNSZones that this solver will be used to solve. The most specific DNS zone match specified here will take precedence over other DNS zone matches, so a solver specifying sys.example.com will be selected over one specifying example.com for the domain www.sys.example.com. If multiple solvers match with the same dnsZones value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected.
        :param match_labels: A label selector that is used to refine the set of certificate's that this challenge solver will apply to.

        :schema: ClusterIssuerSpecAcmeSolversSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc111234004d232ec242a505a4bed40066566c41c934f43c0684db4f29472731)
            check_type(argname="argument dns_names", value=dns_names, expected_type=type_hints["dns_names"])
            check_type(argname="argument dns_zones", value=dns_zones, expected_type=type_hints["dns_zones"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dns_names is not None:
            self._values["dns_names"] = dns_names
        if dns_zones is not None:
            self._values["dns_zones"] = dns_zones
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def dns_names(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of DNSNames that this solver will be used to solve.

        If specified and a match is found, a dnsNames selector will take
        precedence over a dnsZones selector.
        If multiple solvers match with the same dnsNames value, the solver
        with the most matching labels in matchLabels will be selected.
        If neither has more matches, the solver defined earlier in the list
        will be selected.

        :schema: ClusterIssuerSpecAcmeSolversSelector#dnsNames
        '''
        result = self._values.get("dns_names")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def dns_zones(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of DNSZones that this solver will be used to solve.

        The most specific DNS zone match specified here will take precedence
        over other DNS zone matches, so a solver specifying sys.example.com
        will be selected over one specifying example.com for the domain
        www.sys.example.com.
        If multiple solvers match with the same dnsZones value, the solver
        with the most matching labels in matchLabels will be selected.
        If neither has more matches, the solver defined earlier in the list
        will be selected.

        :schema: ClusterIssuerSpecAcmeSolversSelector#dnsZones
        '''
        result = self._values.get("dns_zones")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A label selector that is used to refine the set of certificate's that this challenge solver will apply to.

        :schema: ClusterIssuerSpecAcmeSolversSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecAcmeSolversSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecCa",
    jsii_struct_bases=[],
    name_mapping={
        "secret_name": "secretName",
        "crl_distribution_points": "crlDistributionPoints",
        "issuing_certificate_ur_ls": "issuingCertificateUrLs",
        "ocsp_servers": "ocspServers",
    },
)
class ClusterIssuerSpecCa:
    def __init__(
        self,
        *,
        secret_name: builtins.str,
        crl_distribution_points: typing.Optional[typing.Sequence[builtins.str]] = None,
        issuing_certificate_ur_ls: typing.Optional[typing.Sequence[builtins.str]] = None,
        ocsp_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''CA configures this issuer to sign certificates using a signing CA keypair stored in a Secret resource.

        This is used to build internal PKIs that are managed by cert-manager.

        :param secret_name: SecretName is the name of the secret used to sign Certificates issued by this Issuer.
        :param crl_distribution_points: The CRL distribution points is an X.509 v3 certificate extension which identifies the location of the CRL from which the revocation of this certificate can be checked. If not set, certificates will be issued without distribution points set.
        :param issuing_certificate_ur_ls: IssuingCertificateURLs is a list of URLs which this issuer should embed into certificates it creates. See https://www.rfc-editor.org/rfc/rfc5280#section-4.2.2.1 for more details. As an example, such a URL might be "http://ca.domain.com/ca.crt".
        :param ocsp_servers: The OCSP server list is an X.509 v3 extension that defines a list of URLs of OCSP responders. The OCSP responders can be queried for the revocation status of an issued certificate. If not set, the certificate will be issued with no OCSP servers set. For example, an OCSP server URL could be "http://ocsp.int-x3.letsencrypt.org".

        :schema: ClusterIssuerSpecCa
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9af815cd0fdbf0b2662c9025f1e4f18b62f8e94c19f4803d506aacfff4d104fe)
            check_type(argname="argument secret_name", value=secret_name, expected_type=type_hints["secret_name"])
            check_type(argname="argument crl_distribution_points", value=crl_distribution_points, expected_type=type_hints["crl_distribution_points"])
            check_type(argname="argument issuing_certificate_ur_ls", value=issuing_certificate_ur_ls, expected_type=type_hints["issuing_certificate_ur_ls"])
            check_type(argname="argument ocsp_servers", value=ocsp_servers, expected_type=type_hints["ocsp_servers"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_name": secret_name,
        }
        if crl_distribution_points is not None:
            self._values["crl_distribution_points"] = crl_distribution_points
        if issuing_certificate_ur_ls is not None:
            self._values["issuing_certificate_ur_ls"] = issuing_certificate_ur_ls
        if ocsp_servers is not None:
            self._values["ocsp_servers"] = ocsp_servers

    @builtins.property
    def secret_name(self) -> builtins.str:
        '''SecretName is the name of the secret used to sign Certificates issued by this Issuer.

        :schema: ClusterIssuerSpecCa#secretName
        '''
        result = self._values.get("secret_name")
        assert result is not None, "Required property 'secret_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def crl_distribution_points(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The CRL distribution points is an X.509 v3 certificate extension which identifies the location of the CRL from which the revocation of this certificate can be checked. If not set, certificates will be issued without distribution points set.

        :schema: ClusterIssuerSpecCa#crlDistributionPoints
        '''
        result = self._values.get("crl_distribution_points")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def issuing_certificate_ur_ls(self) -> typing.Optional[typing.List[builtins.str]]:
        '''IssuingCertificateURLs is a list of URLs which this issuer should embed into certificates it creates.

        See https://www.rfc-editor.org/rfc/rfc5280#section-4.2.2.1 for more details.
        As an example, such a URL might be "http://ca.domain.com/ca.crt".

        :schema: ClusterIssuerSpecCa#issuingCertificateURLs
        '''
        result = self._values.get("issuing_certificate_ur_ls")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def ocsp_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The OCSP server list is an X.509 v3 extension that defines a list of URLs of OCSP responders. The OCSP responders can be queried for the revocation status of an issued certificate. If not set, the certificate will be issued with no OCSP servers set. For example, an OCSP server URL could be "http://ocsp.int-x3.letsencrypt.org".

        :schema: ClusterIssuerSpecCa#ocspServers
        '''
        result = self._values.get("ocsp_servers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecCa(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecSelfSigned",
    jsii_struct_bases=[],
    name_mapping={"crl_distribution_points": "crlDistributionPoints"},
)
class ClusterIssuerSpecSelfSigned:
    def __init__(
        self,
        *,
        crl_distribution_points: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''SelfSigned configures this issuer to 'self sign' certificates using the private key used to create the CertificateRequest object.

        :param crl_distribution_points: The CRL distribution points is an X.509 v3 certificate extension which identifies the location of the CRL from which the revocation of this certificate can be checked. If not set certificate will be issued without CDP. Values are strings.

        :schema: ClusterIssuerSpecSelfSigned
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0bccffbd8bfe34f0b9b1ada81ac7f8da01d1a247d899de15f51ab5d57f71e63)
            check_type(argname="argument crl_distribution_points", value=crl_distribution_points, expected_type=type_hints["crl_distribution_points"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if crl_distribution_points is not None:
            self._values["crl_distribution_points"] = crl_distribution_points

    @builtins.property
    def crl_distribution_points(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The CRL distribution points is an X.509 v3 certificate extension which identifies the location of the CRL from which the revocation of this certificate can be checked. If not set certificate will be issued without CDP. Values are strings.

        :schema: ClusterIssuerSpecSelfSigned#crlDistributionPoints
        '''
        result = self._values.get("crl_distribution_points")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecSelfSigned(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVault",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "path": "path",
        "server": "server",
        "ca_bundle": "caBundle",
        "ca_bundle_secret_ref": "caBundleSecretRef",
        "client_cert_secret_ref": "clientCertSecretRef",
        "client_key_secret_ref": "clientKeySecretRef",
        "namespace": "namespace",
    },
)
class ClusterIssuerSpecVault:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterIssuerSpecVaultAuth", typing.Dict[builtins.str, typing.Any]],
        path: builtins.str,
        server: builtins.str,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_bundle_secret_ref: typing.Optional[typing.Union["ClusterIssuerSpecVaultCaBundleSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        client_cert_secret_ref: typing.Optional[typing.Union["ClusterIssuerSpecVaultClientCertSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        client_key_secret_ref: typing.Optional[typing.Union["ClusterIssuerSpecVaultClientKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Vault configures this issuer to sign certificates using a HashiCorp Vault PKI backend.

        :param auth: Auth configures how cert-manager authenticates with the Vault server.
        :param path: Path is the mount path of the Vault PKI backend's ``sign`` endpoint, e.g: "my_pki_mount/sign/my-role-name".
        :param server: Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
        :param ca_bundle: Base64-encoded bundle of PEM CAs which will be used to validate the certificate chain presented by Vault. Only used if using HTTPS to connect to Vault and ignored for HTTP connections. Mutually exclusive with CABundleSecretRef. If neither CABundle nor CABundleSecretRef are defined, the certificate bundle in the cert-manager controller container is used to validate the TLS connection.
        :param ca_bundle_secret_ref: Reference to a Secret containing a bundle of PEM-encoded CAs to use when verifying the certificate chain presented by Vault when using HTTPS. Mutually exclusive with CABundle. If neither CABundle nor CABundleSecretRef are defined, the certificate bundle in the cert-manager controller container is used to validate the TLS connection. If no key for the Secret is specified, cert-manager will default to 'ca.crt'.
        :param client_cert_secret_ref: Reference to a Secret containing a PEM-encoded Client Certificate to use when the Vault server requires mTLS.
        :param client_key_secret_ref: Reference to a Secret containing a PEM-encoded Client Private Key to use when the Vault server requires mTLS.
        :param namespace: Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1" More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces

        :schema: ClusterIssuerSpecVault
        '''
        if isinstance(auth, dict):
            auth = ClusterIssuerSpecVaultAuth(**auth)
        if isinstance(ca_bundle_secret_ref, dict):
            ca_bundle_secret_ref = ClusterIssuerSpecVaultCaBundleSecretRef(**ca_bundle_secret_ref)
        if isinstance(client_cert_secret_ref, dict):
            client_cert_secret_ref = ClusterIssuerSpecVaultClientCertSecretRef(**client_cert_secret_ref)
        if isinstance(client_key_secret_ref, dict):
            client_key_secret_ref = ClusterIssuerSpecVaultClientKeySecretRef(**client_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a84f5ea59776c4b649dbea8f3ffd041fdda50f45b0bfeb7043c1c2852b6f21d)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_bundle_secret_ref", value=ca_bundle_secret_ref, expected_type=type_hints["ca_bundle_secret_ref"])
            check_type(argname="argument client_cert_secret_ref", value=client_cert_secret_ref, expected_type=type_hints["client_cert_secret_ref"])
            check_type(argname="argument client_key_secret_ref", value=client_key_secret_ref, expected_type=type_hints["client_key_secret_ref"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "path": path,
            "server": server,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_bundle_secret_ref is not None:
            self._values["ca_bundle_secret_ref"] = ca_bundle_secret_ref
        if client_cert_secret_ref is not None:
            self._values["client_cert_secret_ref"] = client_cert_secret_ref
        if client_key_secret_ref is not None:
            self._values["client_key_secret_ref"] = client_key_secret_ref
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def auth(self) -> "ClusterIssuerSpecVaultAuth":
        '''Auth configures how cert-manager authenticates with the Vault server.

        :schema: ClusterIssuerSpecVault#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterIssuerSpecVaultAuth", result)

    @builtins.property
    def path(self) -> builtins.str:
        '''Path is the mount path of the Vault PKI backend's ``sign`` endpoint, e.g: "my_pki_mount/sign/my-role-name".

        :schema: ClusterIssuerSpecVault#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def server(self) -> builtins.str:
        '''Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".

        :schema: ClusterIssuerSpecVault#server
        '''
        result = self._values.get("server")
        assert result is not None, "Required property 'server' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''Base64-encoded bundle of PEM CAs which will be used to validate the certificate chain presented by Vault.

        Only used if using HTTPS to connect to Vault and
        ignored for HTTP connections.
        Mutually exclusive with CABundleSecretRef.
        If neither CABundle nor CABundleSecretRef are defined, the certificate bundle in
        the cert-manager controller container is used to validate the TLS connection.

        :schema: ClusterIssuerSpecVault#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_bundle_secret_ref(
        self,
    ) -> typing.Optional["ClusterIssuerSpecVaultCaBundleSecretRef"]:
        '''Reference to a Secret containing a bundle of PEM-encoded CAs to use when verifying the certificate chain presented by Vault when using HTTPS.

        Mutually exclusive with CABundle.
        If neither CABundle nor CABundleSecretRef are defined, the certificate bundle in
        the cert-manager controller container is used to validate the TLS connection.
        If no key for the Secret is specified, cert-manager will default to 'ca.crt'.

        :schema: ClusterIssuerSpecVault#caBundleSecretRef
        '''
        result = self._values.get("ca_bundle_secret_ref")
        return typing.cast(typing.Optional["ClusterIssuerSpecVaultCaBundleSecretRef"], result)

    @builtins.property
    def client_cert_secret_ref(
        self,
    ) -> typing.Optional["ClusterIssuerSpecVaultClientCertSecretRef"]:
        '''Reference to a Secret containing a PEM-encoded Client Certificate to use when the Vault server requires mTLS.

        :schema: ClusterIssuerSpecVault#clientCertSecretRef
        '''
        result = self._values.get("client_cert_secret_ref")
        return typing.cast(typing.Optional["ClusterIssuerSpecVaultClientCertSecretRef"], result)

    @builtins.property
    def client_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterIssuerSpecVaultClientKeySecretRef"]:
        '''Reference to a Secret containing a PEM-encoded Client Private Key to use when the Vault server requires mTLS.

        :schema: ClusterIssuerSpecVault#clientKeySecretRef
        '''
        result = self._values.get("client_key_secret_ref")
        return typing.cast(typing.Optional["ClusterIssuerSpecVaultClientKeySecretRef"], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Name of the vault namespace.

        Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1"
        More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces

        :schema: ClusterIssuerSpecVault#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVault(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVaultAuth",
    jsii_struct_bases=[],
    name_mapping={
        "app_role": "appRole",
        "client_certificate": "clientCertificate",
        "kubernetes": "kubernetes",
        "token_secret_ref": "tokenSecretRef",
    },
)
class ClusterIssuerSpecVaultAuth:
    def __init__(
        self,
        *,
        app_role: typing.Optional[typing.Union["ClusterIssuerSpecVaultAuthAppRole", typing.Dict[builtins.str, typing.Any]]] = None,
        client_certificate: typing.Optional[typing.Union["ClusterIssuerSpecVaultAuthClientCertificate", typing.Dict[builtins.str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["ClusterIssuerSpecVaultAuthKubernetes", typing.Dict[builtins.str, typing.Any]]] = None,
        token_secret_ref: typing.Optional[typing.Union["ClusterIssuerSpecVaultAuthTokenSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how cert-manager authenticates with the Vault server.

        :param app_role: AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
        :param client_certificate: ClientCertificate authenticates with Vault by presenting a client certificate during the request's TLS handshake. Works only when using HTTPS protocol.
        :param kubernetes: Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
        :param token_secret_ref: TokenSecretRef authenticates with Vault by presenting a token.

        :schema: ClusterIssuerSpecVaultAuth
        '''
        if isinstance(app_role, dict):
            app_role = ClusterIssuerSpecVaultAuthAppRole(**app_role)
        if isinstance(client_certificate, dict):
            client_certificate = ClusterIssuerSpecVaultAuthClientCertificate(**client_certificate)
        if isinstance(kubernetes, dict):
            kubernetes = ClusterIssuerSpecVaultAuthKubernetes(**kubernetes)
        if isinstance(token_secret_ref, dict):
            token_secret_ref = ClusterIssuerSpecVaultAuthTokenSecretRef(**token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fffec414792bfc20839a29402537ecbb3ad8dac2e8bb27b8640dba9c0e39e41b)
            check_type(argname="argument app_role", value=app_role, expected_type=type_hints["app_role"])
            check_type(argname="argument client_certificate", value=client_certificate, expected_type=type_hints["client_certificate"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument token_secret_ref", value=token_secret_ref, expected_type=type_hints["token_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if app_role is not None:
            self._values["app_role"] = app_role
        if client_certificate is not None:
            self._values["client_certificate"] = client_certificate
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if token_secret_ref is not None:
            self._values["token_secret_ref"] = token_secret_ref

    @builtins.property
    def app_role(self) -> typing.Optional["ClusterIssuerSpecVaultAuthAppRole"]:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :schema: ClusterIssuerSpecVaultAuth#appRole
        '''
        result = self._values.get("app_role")
        return typing.cast(typing.Optional["ClusterIssuerSpecVaultAuthAppRole"], result)

    @builtins.property
    def client_certificate(
        self,
    ) -> typing.Optional["ClusterIssuerSpecVaultAuthClientCertificate"]:
        '''ClientCertificate authenticates with Vault by presenting a client certificate during the request's TLS handshake.

        Works only when using HTTPS protocol.

        :schema: ClusterIssuerSpecVaultAuth#clientCertificate
        '''
        result = self._values.get("client_certificate")
        return typing.cast(typing.Optional["ClusterIssuerSpecVaultAuthClientCertificate"], result)

    @builtins.property
    def kubernetes(self) -> typing.Optional["ClusterIssuerSpecVaultAuthKubernetes"]:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :schema: ClusterIssuerSpecVaultAuth#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["ClusterIssuerSpecVaultAuthKubernetes"], result)

    @builtins.property
    def token_secret_ref(
        self,
    ) -> typing.Optional["ClusterIssuerSpecVaultAuthTokenSecretRef"]:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :schema: ClusterIssuerSpecVaultAuth#tokenSecretRef
        '''
        result = self._values.get("token_secret_ref")
        return typing.cast(typing.Optional["ClusterIssuerSpecVaultAuthTokenSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVaultAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVaultAuthAppRole",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "role_id": "roleId", "secret_ref": "secretRef"},
)
class ClusterIssuerSpecVaultAuthAppRole:
    def __init__(
        self,
        *,
        path: builtins.str,
        role_id: builtins.str,
        secret_ref: typing.Union["ClusterIssuerSpecVaultAuthAppRoleSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :param path: Path where the App Role authentication backend is mounted in Vault, e.g: "approle".
        :param role_id: RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
        :param secret_ref: Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.

        :schema: ClusterIssuerSpecVaultAuthAppRole
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterIssuerSpecVaultAuthAppRoleSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__10962d9ccc2d2117c8284e8f86a6932786f05248ee0ef02e872460ebb0e2766a)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument role_id", value=role_id, expected_type=type_hints["role_id"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
            "role_id": role_id,
            "secret_ref": secret_ref,
        }

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the App Role authentication backend is mounted in Vault, e.g: "approle".

        :schema: ClusterIssuerSpecVaultAuthAppRole#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_id(self) -> builtins.str:
        '''RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.

        :schema: ClusterIssuerSpecVaultAuthAppRole#roleId
        '''
        result = self._values.get("role_id")
        assert result is not None, "Required property 'role_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(self) -> "ClusterIssuerSpecVaultAuthAppRoleSecretRef":
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret
        resource is used as the app role secret.

        :schema: ClusterIssuerSpecVaultAuthAppRole#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterIssuerSpecVaultAuthAppRoleSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVaultAuthAppRole(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVaultAuthAppRoleSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecVaultAuthAppRoleSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret
        resource is used as the app role secret.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecVaultAuthAppRoleSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f61a7726d72737ec3407c077887e2d42c296773c312ae875e20c46fea5c183c)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecVaultAuthAppRoleSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecVaultAuthAppRoleSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVaultAuthAppRoleSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVaultAuthClientCertificate",
    jsii_struct_bases=[],
    name_mapping={
        "mount_path": "mountPath",
        "name": "name",
        "secret_name": "secretName",
    },
)
class ClusterIssuerSpecVaultAuthClientCertificate:
    def __init__(
        self,
        *,
        mount_path: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        secret_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientCertificate authenticates with Vault by presenting a client certificate during the request's TLS handshake.

        Works only when using HTTPS protocol.

        :param mount_path: The Vault mountPath here is the mount path to use when authenticating with Vault. For example, setting a value to ``/v1/auth/foo``, will use the path ``/v1/auth/foo/login`` to authenticate with Vault. If unspecified, the default value "/v1/auth/cert" will be used.
        :param name: Name of the certificate role to authenticate against. If not set, matching any certificate role, if available.
        :param secret_name: Reference to Kubernetes Secret of type "kubernetes.io/tls" (hence containing tls.crt and tls.key) used to authenticate to Vault using TLS client authentication.

        :schema: ClusterIssuerSpecVaultAuthClientCertificate
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b5d7bf92617a8272153fd0f7e09828f982d88f1edb5ccb7443b7e3c61ee9242)
            check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument secret_name", value=secret_name, expected_type=type_hints["secret_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if mount_path is not None:
            self._values["mount_path"] = mount_path
        if name is not None:
            self._values["name"] = name
        if secret_name is not None:
            self._values["secret_name"] = secret_name

    @builtins.property
    def mount_path(self) -> typing.Optional[builtins.str]:
        '''The Vault mountPath here is the mount path to use when authenticating with Vault.

        For example, setting a value to ``/v1/auth/foo``, will use the path
        ``/v1/auth/foo/login`` to authenticate with Vault. If unspecified, the
        default value "/v1/auth/cert" will be used.

        :schema: ClusterIssuerSpecVaultAuthClientCertificate#mountPath
        '''
        result = self._values.get("mount_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the certificate role to authenticate against.

        If not set, matching any certificate role, if available.

        :schema: ClusterIssuerSpecVaultAuthClientCertificate#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_name(self) -> typing.Optional[builtins.str]:
        '''Reference to Kubernetes Secret of type "kubernetes.io/tls" (hence containing tls.crt and tls.key) used to authenticate to Vault using TLS client authentication.

        :schema: ClusterIssuerSpecVaultAuthClientCertificate#secretName
        '''
        result = self._values.get("secret_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVaultAuthClientCertificate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVaultAuthKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "role": "role",
        "mount_path": "mountPath",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class ClusterIssuerSpecVaultAuthKubernetes:
    def __init__(
        self,
        *,
        role: builtins.str,
        mount_path: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["ClusterIssuerSpecVaultAuthKubernetesSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["ClusterIssuerSpecVaultAuthKubernetesServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :param role: A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
        :param mount_path: The Vault mountPath here is the mount path to use when authenticating with Vault. For example, setting a value to ``/v1/auth/foo``, will use the path ``/v1/auth/foo/login`` to authenticate with Vault. If unspecified, the default value "/v1/auth/kubernetes" will be used.
        :param secret_ref: The required Secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. Use of 'ambient credentials' is not supported.
        :param service_account_ref: A reference to a service account that will be used to request a bound token (also known as "projected token"). Compared to using "secretRef", using this field means that you don't rely on statically bound tokens. To use this field, you must configure an RBAC rule to let cert-manager request a token.

        :schema: ClusterIssuerSpecVaultAuthKubernetes
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterIssuerSpecVaultAuthKubernetesSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterIssuerSpecVaultAuthKubernetesServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b057a2f4f871c50be59887dce41fa0081c910021592c34995715cfc8a2ebba54)
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "role": role,
        }
        if mount_path is not None:
            self._values["mount_path"] = mount_path
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def role(self) -> builtins.str:
        '''A required field containing the Vault Role to assume.

        A Role binds a
        Kubernetes ServiceAccount with a set of Vault policies.

        :schema: ClusterIssuerSpecVaultAuthKubernetes#role
        '''
        result = self._values.get("role")
        assert result is not None, "Required property 'role' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mount_path(self) -> typing.Optional[builtins.str]:
        '''The Vault mountPath here is the mount path to use when authenticating with Vault.

        For example, setting a value to ``/v1/auth/foo``, will use the path
        ``/v1/auth/foo/login`` to authenticate with Vault. If unspecified, the
        default value "/v1/auth/kubernetes" will be used.

        :schema: ClusterIssuerSpecVaultAuthKubernetes#mountPath
        '''
        result = self._values.get("mount_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterIssuerSpecVaultAuthKubernetesSecretRef"]:
        '''The required Secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        Use of 'ambient credentials' is not
        supported.

        :schema: ClusterIssuerSpecVaultAuthKubernetes#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterIssuerSpecVaultAuthKubernetesSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterIssuerSpecVaultAuthKubernetesServiceAccountRef"]:
        '''A reference to a service account that will be used to request a bound token (also known as "projected token").

        Compared to using "secretRef",
        using this field means that you don't rely on statically bound tokens. To
        use this field, you must configure an RBAC rule to let cert-manager
        request a token.

        :schema: ClusterIssuerSpecVaultAuthKubernetes#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterIssuerSpecVaultAuthKubernetesServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVaultAuthKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVaultAuthKubernetesSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecVaultAuthKubernetesSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The required Secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        Use of 'ambient credentials' is not
        supported.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecVaultAuthKubernetesSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b7e8911fbe05841c91efed37cf0283688f60653b757f587aff54ad069bfa7fa)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecVaultAuthKubernetesSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecVaultAuthKubernetesSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVaultAuthKubernetesSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVaultAuthKubernetesServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences"},
)
class ClusterIssuerSpecVaultAuthKubernetesServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A reference to a service account that will be used to request a bound token (also known as "projected token").

        Compared to using "secretRef",
        using this field means that you don't rely on statically bound tokens. To
        use this field, you must configure an RBAC rule to let cert-manager
        request a token.

        :param name: Name of the ServiceAccount used to request a token.
        :param audiences: TokenAudiences is an optional list of extra audiences to include in the token passed to Vault. The default token consisting of the issuer's namespace and name is always included.

        :schema: ClusterIssuerSpecVaultAuthKubernetesServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d61a222bfa7b639938bfda529bac99a51aee0bdf8edbe944502a2ef26d2ebd1)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the ServiceAccount used to request a token.

        :schema: ClusterIssuerSpecVaultAuthKubernetesServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''TokenAudiences is an optional list of extra audiences to include in the token passed to Vault.

        The default token
        consisting of the issuer's namespace and name is always included.

        :schema: ClusterIssuerSpecVaultAuthKubernetesServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVaultAuthKubernetesServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVaultAuthTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecVaultAuthTokenSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecVaultAuthTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4985f2766828e51bd0b0f04d3da7d34a6c26080c8f2ef4056f4b385e3712a400)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecVaultAuthTokenSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecVaultAuthTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVaultAuthTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVaultCaBundleSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecVaultCaBundleSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a Secret containing a bundle of PEM-encoded CAs to use when verifying the certificate chain presented by Vault when using HTTPS.

        Mutually exclusive with CABundle.
        If neither CABundle nor CABundleSecretRef are defined, the certificate bundle in
        the cert-manager controller container is used to validate the TLS connection.
        If no key for the Secret is specified, cert-manager will default to 'ca.crt'.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecVaultCaBundleSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__047a84475c656884a2dae0a4b7f148156de6c86bbd8aa0bd513f4e001abedc15)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecVaultCaBundleSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecVaultCaBundleSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVaultCaBundleSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVaultClientCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecVaultClientCertSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a Secret containing a PEM-encoded Client Certificate to use when the Vault server requires mTLS.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecVaultClientCertSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7b90518096b91a05eaadff4db84596d62a493f61e7b4b9ee2638468a72aa9875)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecVaultClientCertSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecVaultClientCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVaultClientCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVaultClientKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecVaultClientKeySecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a Secret containing a PEM-encoded Client Private Key to use when the Vault server requires mTLS.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecVaultClientKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e1804c48c9d9612d72ef5983ad2e2bbbefc37bdc8ba41e187fd7464a846213c)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecVaultClientKeySecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecVaultClientKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVaultClientKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVenafi",
    jsii_struct_bases=[],
    name_mapping={"zone": "zone", "cloud": "cloud", "tpp": "tpp"},
)
class ClusterIssuerSpecVenafi:
    def __init__(
        self,
        *,
        zone: builtins.str,
        cloud: typing.Optional[typing.Union["ClusterIssuerSpecVenafiCloud", typing.Dict[builtins.str, typing.Any]]] = None,
        tpp: typing.Optional[typing.Union["ClusterIssuerSpecVenafiTpp", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Venafi configures this issuer to sign certificates using a Venafi TPP or Venafi Cloud policy zone.

        :param zone: Zone is the Venafi Policy Zone to use for this issuer. All requests made to the Venafi platform will be restricted by the named zone policy. This field is required.
        :param cloud: Cloud specifies the Venafi cloud configuration settings. Only one of TPP or Cloud may be specified.
        :param tpp: TPP specifies Trust Protection Platform configuration settings. Only one of TPP or Cloud may be specified.

        :schema: ClusterIssuerSpecVenafi
        '''
        if isinstance(cloud, dict):
            cloud = ClusterIssuerSpecVenafiCloud(**cloud)
        if isinstance(tpp, dict):
            tpp = ClusterIssuerSpecVenafiTpp(**tpp)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__876346ead32b143589ade8495ee6c7afaf4b96d31860eb256982004a43ec6866)
            check_type(argname="argument zone", value=zone, expected_type=type_hints["zone"])
            check_type(argname="argument cloud", value=cloud, expected_type=type_hints["cloud"])
            check_type(argname="argument tpp", value=tpp, expected_type=type_hints["tpp"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "zone": zone,
        }
        if cloud is not None:
            self._values["cloud"] = cloud
        if tpp is not None:
            self._values["tpp"] = tpp

    @builtins.property
    def zone(self) -> builtins.str:
        '''Zone is the Venafi Policy Zone to use for this issuer.

        All requests made to the Venafi platform will be restricted by the named
        zone policy.
        This field is required.

        :schema: ClusterIssuerSpecVenafi#zone
        '''
        result = self._values.get("zone")
        assert result is not None, "Required property 'zone' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cloud(self) -> typing.Optional["ClusterIssuerSpecVenafiCloud"]:
        '''Cloud specifies the Venafi cloud configuration settings.

        Only one of TPP or Cloud may be specified.

        :schema: ClusterIssuerSpecVenafi#cloud
        '''
        result = self._values.get("cloud")
        return typing.cast(typing.Optional["ClusterIssuerSpecVenafiCloud"], result)

    @builtins.property
    def tpp(self) -> typing.Optional["ClusterIssuerSpecVenafiTpp"]:
        '''TPP specifies Trust Protection Platform configuration settings.

        Only one of TPP or Cloud may be specified.

        :schema: ClusterIssuerSpecVenafi#tpp
        '''
        result = self._values.get("tpp")
        return typing.cast(typing.Optional["ClusterIssuerSpecVenafiTpp"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVenafi(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVenafiCloud",
    jsii_struct_bases=[],
    name_mapping={"api_token_secret_ref": "apiTokenSecretRef", "url": "url"},
)
class ClusterIssuerSpecVenafiCloud:
    def __init__(
        self,
        *,
        api_token_secret_ref: typing.Union["ClusterIssuerSpecVenafiCloudApiTokenSecretRef", typing.Dict[builtins.str, typing.Any]],
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Cloud specifies the Venafi cloud configuration settings.

        Only one of TPP or Cloud may be specified.

        :param api_token_secret_ref: APITokenSecretRef is a secret key selector for the Venafi Cloud API token.
        :param url: URL is the base URL for Venafi Cloud. Defaults to "https://api.venafi.cloud/v1". Default: https://api.venafi.cloud/v1".

        :schema: ClusterIssuerSpecVenafiCloud
        '''
        if isinstance(api_token_secret_ref, dict):
            api_token_secret_ref = ClusterIssuerSpecVenafiCloudApiTokenSecretRef(**api_token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__199580c7a64bf39b6fa7e0a065a62fd461327e949f005cf1f9d622011f6071af)
            check_type(argname="argument api_token_secret_ref", value=api_token_secret_ref, expected_type=type_hints["api_token_secret_ref"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_token_secret_ref": api_token_secret_ref,
        }
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def api_token_secret_ref(self) -> "ClusterIssuerSpecVenafiCloudApiTokenSecretRef":
        '''APITokenSecretRef is a secret key selector for the Venafi Cloud API token.

        :schema: ClusterIssuerSpecVenafiCloud#apiTokenSecretRef
        '''
        result = self._values.get("api_token_secret_ref")
        assert result is not None, "Required property 'api_token_secret_ref' is missing"
        return typing.cast("ClusterIssuerSpecVenafiCloudApiTokenSecretRef", result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''URL is the base URL for Venafi Cloud.

        Defaults to "https://api.venafi.cloud/v1".

        :default: https://api.venafi.cloud/v1".

        :schema: ClusterIssuerSpecVenafiCloud#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVenafiCloud(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVenafiCloudApiTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecVenafiCloudApiTokenSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''APITokenSecretRef is a secret key selector for the Venafi Cloud API token.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecVenafiCloudApiTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f1ac43ee123aba3d19fa5669836ebbb4e0ecaa342cb2bd7726867e8e9001a126)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecVenafiCloudApiTokenSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecVenafiCloudApiTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVenafiCloudApiTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVenafiTpp",
    jsii_struct_bases=[],
    name_mapping={
        "credentials_ref": "credentialsRef",
        "url": "url",
        "ca_bundle": "caBundle",
        "ca_bundle_secret_ref": "caBundleSecretRef",
    },
)
class ClusterIssuerSpecVenafiTpp:
    def __init__(
        self,
        *,
        credentials_ref: typing.Union["ClusterIssuerSpecVenafiTppCredentialsRef", typing.Dict[builtins.str, typing.Any]],
        url: builtins.str,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_bundle_secret_ref: typing.Optional[typing.Union["ClusterIssuerSpecVenafiTppCaBundleSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''TPP specifies Trust Protection Platform configuration settings.

        Only one of TPP or Cloud may be specified.

        :param credentials_ref: CredentialsRef is a reference to a Secret containing the Venafi TPP API credentials. The secret must contain the key 'access-token' for the Access Token Authentication, or two keys, 'username' and 'password' for the API Keys Authentication.
        :param url: URL is the base URL for the vedsdk endpoint of the Venafi TPP instance, for example: "https://tpp.example.com/vedsdk".
        :param ca_bundle: Base64-encoded bundle of PEM CAs which will be used to validate the certificate chain presented by the TPP server. Only used if using HTTPS; ignored for HTTP. If undefined, the certificate bundle in the cert-manager controller container is used to validate the chain.
        :param ca_bundle_secret_ref: Reference to a Secret containing a base64-encoded bundle of PEM CAs which will be used to validate the certificate chain presented by the TPP server. Only used if using HTTPS; ignored for HTTP. Mutually exclusive with CABundle. If neither CABundle nor CABundleSecretRef is defined, the certificate bundle in the cert-manager controller container is used to validate the TLS connection.

        :schema: ClusterIssuerSpecVenafiTpp
        '''
        if isinstance(credentials_ref, dict):
            credentials_ref = ClusterIssuerSpecVenafiTppCredentialsRef(**credentials_ref)
        if isinstance(ca_bundle_secret_ref, dict):
            ca_bundle_secret_ref = ClusterIssuerSpecVenafiTppCaBundleSecretRef(**ca_bundle_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc6ef1f9e6227b439ca0d1f316d72d2f48e63ae6d665574139243348f0367573)
            check_type(argname="argument credentials_ref", value=credentials_ref, expected_type=type_hints["credentials_ref"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_bundle_secret_ref", value=ca_bundle_secret_ref, expected_type=type_hints["ca_bundle_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "credentials_ref": credentials_ref,
            "url": url,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_bundle_secret_ref is not None:
            self._values["ca_bundle_secret_ref"] = ca_bundle_secret_ref

    @builtins.property
    def credentials_ref(self) -> "ClusterIssuerSpecVenafiTppCredentialsRef":
        '''CredentialsRef is a reference to a Secret containing the Venafi TPP API credentials.

        The secret must contain the key 'access-token' for the Access Token Authentication,
        or two keys, 'username' and 'password' for the API Keys Authentication.

        :schema: ClusterIssuerSpecVenafiTpp#credentialsRef
        '''
        result = self._values.get("credentials_ref")
        assert result is not None, "Required property 'credentials_ref' is missing"
        return typing.cast("ClusterIssuerSpecVenafiTppCredentialsRef", result)

    @builtins.property
    def url(self) -> builtins.str:
        '''URL is the base URL for the vedsdk endpoint of the Venafi TPP instance, for example: "https://tpp.example.com/vedsdk".

        :schema: ClusterIssuerSpecVenafiTpp#url
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''Base64-encoded bundle of PEM CAs which will be used to validate the certificate chain presented by the TPP server.

        Only used if using HTTPS; ignored for HTTP.
        If undefined, the certificate bundle in the cert-manager controller container
        is used to validate the chain.

        :schema: ClusterIssuerSpecVenafiTpp#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_bundle_secret_ref(
        self,
    ) -> typing.Optional["ClusterIssuerSpecVenafiTppCaBundleSecretRef"]:
        '''Reference to a Secret containing a base64-encoded bundle of PEM CAs which will be used to validate the certificate chain presented by the TPP server.

        Only used if using HTTPS; ignored for HTTP. Mutually exclusive with CABundle.
        If neither CABundle nor CABundleSecretRef is defined, the certificate bundle in
        the cert-manager controller container is used to validate the TLS connection.

        :schema: ClusterIssuerSpecVenafiTpp#caBundleSecretRef
        '''
        result = self._values.get("ca_bundle_secret_ref")
        return typing.cast(typing.Optional["ClusterIssuerSpecVenafiTppCaBundleSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVenafiTpp(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVenafiTppCaBundleSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class ClusterIssuerSpecVenafiTppCaBundleSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a Secret containing a base64-encoded bundle of PEM CAs which will be used to validate the certificate chain presented by the TPP server.

        Only used if using HTTPS; ignored for HTTP. Mutually exclusive with CABundle.
        If neither CABundle nor CABundleSecretRef is defined, the certificate bundle in
        the cert-manager controller container is used to validate the TLS connection.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterIssuerSpecVenafiTppCaBundleSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ebed1fb66852c565e0f6540902636134f50a004d172add9c0d1a42aad50c3cd)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecVenafiTppCaBundleSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: ClusterIssuerSpecVenafiTppCaBundleSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVenafiTppCaBundleSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.ClusterIssuerSpecVenafiTppCredentialsRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class ClusterIssuerSpecVenafiTppCredentialsRef:
    def __init__(self, *, name: builtins.str) -> None:
        '''CredentialsRef is a reference to a Secret containing the Venafi TPP API credentials.

        The secret must contain the key 'access-token' for the Access Token Authentication,
        or two keys, 'username' and 'password' for the API Keys Authentication.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecVenafiTppCredentialsRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b85404e9798b694950cabde3354acc96dd7ddbf574c07a4886d3fb307193cb4)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: ClusterIssuerSpecVenafiTppCredentialsRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterIssuerSpecVenafiTppCredentialsRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Issuer(
    _cdk8s_d3d9af27.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="iocert-manager.Issuer",
):
    '''An Issuer represents a certificate issuing authority which can be referenced as part of ``issuerRef`` fields.

    It is scoped to a single namespace and can therefore only be referenced by
    resources within the same namespace.

    :schema: Issuer
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        spec: typing.Union["IssuerSpec", typing.Dict[builtins.str, typing.Any]],
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "Issuer" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param spec: Desired state of the Issuer resource.
        :param metadata: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a9f9f3b75216e6d5d6593b8544c53a9f2cfe18ca5f405a59ae6fec870e49fc21)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = IssuerProps(spec=spec, metadata=metadata)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        spec: typing.Union["IssuerSpec", typing.Dict[builtins.str, typing.Any]],
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "Issuer".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param spec: Desired state of the Issuer resource.
        :param metadata: 
        '''
        props = IssuerProps(spec=spec, metadata=metadata)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> _cdk8s_d3d9af27.GroupVersionKind:
        '''Returns the apiVersion and kind for "Issuer".'''
        return typing.cast(_cdk8s_d3d9af27.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="iocert-manager.IssuerProps",
    jsii_struct_bases=[],
    name_mapping={"spec": "spec", "metadata": "metadata"},
)
class IssuerProps:
    def __init__(
        self,
        *,
        spec: typing.Union["IssuerSpec", typing.Dict[builtins.str, typing.Any]],
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''An Issuer represents a certificate issuing authority which can be referenced as part of ``issuerRef`` fields.

        It is scoped to a single namespace and can therefore only be referenced by
        resources within the same namespace.

        :param spec: Desired state of the Issuer resource.
        :param metadata: 

        :schema: Issuer
        '''
        if isinstance(spec, dict):
            spec = IssuerSpec(**spec)
        if isinstance(metadata, dict):
            metadata = _cdk8s_d3d9af27.ApiObjectMetadata(**metadata)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd822a90321c72917d572dc83c80fe5a543994d1085bd90f367feae334591c12)
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "spec": spec,
        }
        if metadata is not None:
            self._values["metadata"] = metadata

    @builtins.property
    def spec(self) -> "IssuerSpec":
        '''Desired state of the Issuer resource.

        :schema: Issuer#spec
        '''
        result = self._values.get("spec")
        assert result is not None, "Required property 'spec' is missing"
        return typing.cast("IssuerSpec", result)

    @builtins.property
    def metadata(self) -> typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata]:
        '''
        :schema: Issuer#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpec",
    jsii_struct_bases=[],
    name_mapping={
        "acme": "acme",
        "ca": "ca",
        "self_signed": "selfSigned",
        "vault": "vault",
        "venafi": "venafi",
    },
)
class IssuerSpec:
    def __init__(
        self,
        *,
        acme: typing.Optional[typing.Union["IssuerSpecAcme", typing.Dict[builtins.str, typing.Any]]] = None,
        ca: typing.Optional[typing.Union["IssuerSpecCa", typing.Dict[builtins.str, typing.Any]]] = None,
        self_signed: typing.Optional[typing.Union["IssuerSpecSelfSigned", typing.Dict[builtins.str, typing.Any]]] = None,
        vault: typing.Optional[typing.Union["IssuerSpecVault", typing.Dict[builtins.str, typing.Any]]] = None,
        venafi: typing.Optional[typing.Union["IssuerSpecVenafi", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Desired state of the Issuer resource.

        :param acme: ACME configures this issuer to communicate with a RFC8555 (ACME) server to obtain signed x509 certificates.
        :param ca: CA configures this issuer to sign certificates using a signing CA keypair stored in a Secret resource. This is used to build internal PKIs that are managed by cert-manager.
        :param self_signed: SelfSigned configures this issuer to 'self sign' certificates using the private key used to create the CertificateRequest object.
        :param vault: Vault configures this issuer to sign certificates using a HashiCorp Vault PKI backend.
        :param venafi: Venafi configures this issuer to sign certificates using a Venafi TPP or Venafi Cloud policy zone.

        :schema: IssuerSpec
        '''
        if isinstance(acme, dict):
            acme = IssuerSpecAcme(**acme)
        if isinstance(ca, dict):
            ca = IssuerSpecCa(**ca)
        if isinstance(self_signed, dict):
            self_signed = IssuerSpecSelfSigned(**self_signed)
        if isinstance(vault, dict):
            vault = IssuerSpecVault(**vault)
        if isinstance(venafi, dict):
            venafi = IssuerSpecVenafi(**venafi)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5785a20597cfe6a55d2c1c8126933ca1fd315ac00a5069cdab3a42f315aee901)
            check_type(argname="argument acme", value=acme, expected_type=type_hints["acme"])
            check_type(argname="argument ca", value=ca, expected_type=type_hints["ca"])
            check_type(argname="argument self_signed", value=self_signed, expected_type=type_hints["self_signed"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument venafi", value=venafi, expected_type=type_hints["venafi"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if acme is not None:
            self._values["acme"] = acme
        if ca is not None:
            self._values["ca"] = ca
        if self_signed is not None:
            self._values["self_signed"] = self_signed
        if vault is not None:
            self._values["vault"] = vault
        if venafi is not None:
            self._values["venafi"] = venafi

    @builtins.property
    def acme(self) -> typing.Optional["IssuerSpecAcme"]:
        '''ACME configures this issuer to communicate with a RFC8555 (ACME) server to obtain signed x509 certificates.

        :schema: IssuerSpec#acme
        '''
        result = self._values.get("acme")
        return typing.cast(typing.Optional["IssuerSpecAcme"], result)

    @builtins.property
    def ca(self) -> typing.Optional["IssuerSpecCa"]:
        '''CA configures this issuer to sign certificates using a signing CA keypair stored in a Secret resource.

        This is used to build internal PKIs that are managed by cert-manager.

        :schema: IssuerSpec#ca
        '''
        result = self._values.get("ca")
        return typing.cast(typing.Optional["IssuerSpecCa"], result)

    @builtins.property
    def self_signed(self) -> typing.Optional["IssuerSpecSelfSigned"]:
        '''SelfSigned configures this issuer to 'self sign' certificates using the private key used to create the CertificateRequest object.

        :schema: IssuerSpec#selfSigned
        '''
        result = self._values.get("self_signed")
        return typing.cast(typing.Optional["IssuerSpecSelfSigned"], result)

    @builtins.property
    def vault(self) -> typing.Optional["IssuerSpecVault"]:
        '''Vault configures this issuer to sign certificates using a HashiCorp Vault PKI backend.

        :schema: IssuerSpec#vault
        '''
        result = self._values.get("vault")
        return typing.cast(typing.Optional["IssuerSpecVault"], result)

    @builtins.property
    def venafi(self) -> typing.Optional["IssuerSpecVenafi"]:
        '''Venafi configures this issuer to sign certificates using a Venafi TPP or Venafi Cloud policy zone.

        :schema: IssuerSpec#venafi
        '''
        result = self._values.get("venafi")
        return typing.cast(typing.Optional["IssuerSpecVenafi"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcme",
    jsii_struct_bases=[],
    name_mapping={
        "private_key_secret_ref": "privateKeySecretRef",
        "server": "server",
        "ca_bundle": "caBundle",
        "disable_account_key_generation": "disableAccountKeyGeneration",
        "email": "email",
        "enable_duration_feature": "enableDurationFeature",
        "external_account_binding": "externalAccountBinding",
        "preferred_chain": "preferredChain",
        "skip_tls_verify": "skipTlsVerify",
        "solvers": "solvers",
    },
)
class IssuerSpecAcme:
    def __init__(
        self,
        *,
        private_key_secret_ref: typing.Union["IssuerSpecAcmePrivateKeySecretRef", typing.Dict[builtins.str, typing.Any]],
        server: builtins.str,
        ca_bundle: typing.Optional[builtins.str] = None,
        disable_account_key_generation: typing.Optional[builtins.bool] = None,
        email: typing.Optional[builtins.str] = None,
        enable_duration_feature: typing.Optional[builtins.bool] = None,
        external_account_binding: typing.Optional[typing.Union["IssuerSpecAcmeExternalAccountBinding", typing.Dict[builtins.str, typing.Any]]] = None,
        preferred_chain: typing.Optional[builtins.str] = None,
        skip_tls_verify: typing.Optional[builtins.bool] = None,
        solvers: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolvers", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''ACME configures this issuer to communicate with a RFC8555 (ACME) server to obtain signed x509 certificates.

        :param private_key_secret_ref: PrivateKey is the name of a Kubernetes Secret resource that will be used to store the automatically generated ACME account private key. Optionally, a ``key`` may be specified to select a specific entry within the named Secret resource. If ``key`` is not specified, a default of ``tls.key`` will be used.
        :param server: Server is the URL used to access the ACME server's 'directory' endpoint. For example, for Let's Encrypt's staging endpoint, you would use: "https://acme-staging-v02.api.letsencrypt.org/directory". Only ACME v2 endpoints (i.e. RFC 8555) are supported.
        :param ca_bundle: Base64-encoded bundle of PEM CAs which can be used to validate the certificate chain presented by the ACME server. Mutually exclusive with SkipTLSVerify; prefer using CABundle to prevent various kinds of security vulnerabilities. If CABundle and SkipTLSVerify are unset, the system certificate bundle inside the container is used to validate the TLS connection.
        :param disable_account_key_generation: Enables or disables generating a new ACME account key. If true, the Issuer resource will *not* request a new account but will expect the account key to be supplied via an existing secret. If false, the cert-manager system will generate a new ACME account key for the Issuer. Defaults to false. Default: false.
        :param email: Email is the email address to be associated with the ACME account. This field is optional, but it is strongly recommended to be set. It will be used to contact you in case of issues with your account or certificates, including expiry notification emails. This field may be updated after the account is initially registered.
        :param enable_duration_feature: Enables requesting a Not After date on certificates that matches the duration of the certificate. This is not supported by all ACME servers like Let's Encrypt. If set to true when the ACME server does not support it, it will create an error on the Order. Defaults to false. Default: false.
        :param external_account_binding: ExternalAccountBinding is a reference to a CA external account of the ACME server. If set, upon registration cert-manager will attempt to associate the given external account credentials with the registered ACME account.
        :param preferred_chain: PreferredChain is the chain to use if the ACME server outputs multiple. PreferredChain is no guarantee that this one gets delivered by the ACME endpoint. For example, for Let's Encrypt's DST crosssign you would use: "DST Root CA X3" or "ISRG Root X1" for the newer Let's Encrypt root CA. This value picks the first certificate bundle in the combined set of ACME default and alternative chains that has a root-most certificate with this value as its issuer's commonname.
        :param skip_tls_verify: INSECURE: Enables or disables validation of the ACME server TLS certificate. If true, requests to the ACME server will not have the TLS certificate chain validated. Mutually exclusive with CABundle; prefer using CABundle to prevent various kinds of security vulnerabilities. Only enable this option in development environments. If CABundle and SkipTLSVerify are unset, the system certificate bundle inside the container is used to validate the TLS connection. Defaults to false. Default: false.
        :param solvers: Solvers is a list of challenge solvers that will be used to solve ACME challenges for the matching domains. Solver configurations must be provided in order to obtain certificates from an ACME server. For more information, see: https://cert-manager.io/docs/configuration/acme/

        :schema: IssuerSpecAcme
        '''
        if isinstance(private_key_secret_ref, dict):
            private_key_secret_ref = IssuerSpecAcmePrivateKeySecretRef(**private_key_secret_ref)
        if isinstance(external_account_binding, dict):
            external_account_binding = IssuerSpecAcmeExternalAccountBinding(**external_account_binding)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2cb898b7ba7bab90e6034e33ab7cf089f8cd02b46dd1b6e913714a63a5a8a1ad)
            check_type(argname="argument private_key_secret_ref", value=private_key_secret_ref, expected_type=type_hints["private_key_secret_ref"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument disable_account_key_generation", value=disable_account_key_generation, expected_type=type_hints["disable_account_key_generation"])
            check_type(argname="argument email", value=email, expected_type=type_hints["email"])
            check_type(argname="argument enable_duration_feature", value=enable_duration_feature, expected_type=type_hints["enable_duration_feature"])
            check_type(argname="argument external_account_binding", value=external_account_binding, expected_type=type_hints["external_account_binding"])
            check_type(argname="argument preferred_chain", value=preferred_chain, expected_type=type_hints["preferred_chain"])
            check_type(argname="argument skip_tls_verify", value=skip_tls_verify, expected_type=type_hints["skip_tls_verify"])
            check_type(argname="argument solvers", value=solvers, expected_type=type_hints["solvers"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "private_key_secret_ref": private_key_secret_ref,
            "server": server,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if disable_account_key_generation is not None:
            self._values["disable_account_key_generation"] = disable_account_key_generation
        if email is not None:
            self._values["email"] = email
        if enable_duration_feature is not None:
            self._values["enable_duration_feature"] = enable_duration_feature
        if external_account_binding is not None:
            self._values["external_account_binding"] = external_account_binding
        if preferred_chain is not None:
            self._values["preferred_chain"] = preferred_chain
        if skip_tls_verify is not None:
            self._values["skip_tls_verify"] = skip_tls_verify
        if solvers is not None:
            self._values["solvers"] = solvers

    @builtins.property
    def private_key_secret_ref(self) -> "IssuerSpecAcmePrivateKeySecretRef":
        '''PrivateKey is the name of a Kubernetes Secret resource that will be used to store the automatically generated ACME account private key.

        Optionally, a ``key`` may be specified to select a specific entry within
        the named Secret resource.
        If ``key`` is not specified, a default of ``tls.key`` will be used.

        :schema: IssuerSpecAcme#privateKeySecretRef
        '''
        result = self._values.get("private_key_secret_ref")
        assert result is not None, "Required property 'private_key_secret_ref' is missing"
        return typing.cast("IssuerSpecAcmePrivateKeySecretRef", result)

    @builtins.property
    def server(self) -> builtins.str:
        '''Server is the URL used to access the ACME server's 'directory' endpoint.

        For example, for Let's Encrypt's staging endpoint, you would use:
        "https://acme-staging-v02.api.letsencrypt.org/directory".
        Only ACME v2 endpoints (i.e. RFC 8555) are supported.

        :schema: IssuerSpecAcme#server
        '''
        result = self._values.get("server")
        assert result is not None, "Required property 'server' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''Base64-encoded bundle of PEM CAs which can be used to validate the certificate chain presented by the ACME server.

        Mutually exclusive with SkipTLSVerify; prefer using CABundle to prevent various
        kinds of security vulnerabilities.
        If CABundle and SkipTLSVerify are unset, the system certificate bundle inside
        the container is used to validate the TLS connection.

        :schema: IssuerSpecAcme#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def disable_account_key_generation(self) -> typing.Optional[builtins.bool]:
        '''Enables or disables generating a new ACME account key.

        If true, the Issuer resource will *not* request a new account but will expect
        the account key to be supplied via an existing secret.
        If false, the cert-manager system will generate a new ACME account key
        for the Issuer.
        Defaults to false.

        :default: false.

        :schema: IssuerSpecAcme#disableAccountKeyGeneration
        '''
        result = self._values.get("disable_account_key_generation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def email(self) -> typing.Optional[builtins.str]:
        '''Email is the email address to be associated with the ACME account.

        This field is optional, but it is strongly recommended to be set.
        It will be used to contact you in case of issues with your account or
        certificates, including expiry notification emails.
        This field may be updated after the account is initially registered.

        :schema: IssuerSpecAcme#email
        '''
        result = self._values.get("email")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_duration_feature(self) -> typing.Optional[builtins.bool]:
        '''Enables requesting a Not After date on certificates that matches the duration of the certificate.

        This is not supported by all ACME servers
        like Let's Encrypt. If set to true when the ACME server does not support
        it, it will create an error on the Order.
        Defaults to false.

        :default: false.

        :schema: IssuerSpecAcme#enableDurationFeature
        '''
        result = self._values.get("enable_duration_feature")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def external_account_binding(
        self,
    ) -> typing.Optional["IssuerSpecAcmeExternalAccountBinding"]:
        '''ExternalAccountBinding is a reference to a CA external account of the ACME server.

        If set, upon registration cert-manager will attempt to associate the given
        external account credentials with the registered ACME account.

        :schema: IssuerSpecAcme#externalAccountBinding
        '''
        result = self._values.get("external_account_binding")
        return typing.cast(typing.Optional["IssuerSpecAcmeExternalAccountBinding"], result)

    @builtins.property
    def preferred_chain(self) -> typing.Optional[builtins.str]:
        '''PreferredChain is the chain to use if the ACME server outputs multiple.

        PreferredChain is no guarantee that this one gets delivered by the ACME
        endpoint.
        For example, for Let's Encrypt's DST crosssign you would use:
        "DST Root CA X3" or "ISRG Root X1" for the newer Let's Encrypt root CA.
        This value picks the first certificate bundle in the combined set of
        ACME default and alternative chains that has a root-most certificate with
        this value as its issuer's commonname.

        :schema: IssuerSpecAcme#preferredChain
        '''
        result = self._values.get("preferred_chain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def skip_tls_verify(self) -> typing.Optional[builtins.bool]:
        '''INSECURE: Enables or disables validation of the ACME server TLS certificate.

        If true, requests to the ACME server will not have the TLS certificate chain
        validated.
        Mutually exclusive with CABundle; prefer using CABundle to prevent various
        kinds of security vulnerabilities.
        Only enable this option in development environments.
        If CABundle and SkipTLSVerify are unset, the system certificate bundle inside
        the container is used to validate the TLS connection.
        Defaults to false.

        :default: false.

        :schema: IssuerSpecAcme#skipTLSVerify
        '''
        result = self._values.get("skip_tls_verify")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def solvers(self) -> typing.Optional[typing.List["IssuerSpecAcmeSolvers"]]:
        '''Solvers is a list of challenge solvers that will be used to solve ACME challenges for the matching domains.

        Solver configurations must be provided in order to obtain certificates
        from an ACME server.
        For more information, see: https://cert-manager.io/docs/configuration/acme/

        :schema: IssuerSpecAcme#solvers
        '''
        result = self._values.get("solvers")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolvers"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcme(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeExternalAccountBinding",
    jsii_struct_bases=[],
    name_mapping={
        "key_id": "keyId",
        "key_secret_ref": "keySecretRef",
        "key_algorithm": "keyAlgorithm",
    },
)
class IssuerSpecAcmeExternalAccountBinding:
    def __init__(
        self,
        *,
        key_id: builtins.str,
        key_secret_ref: typing.Union["IssuerSpecAcmeExternalAccountBindingKeySecretRef", typing.Dict[builtins.str, typing.Any]],
        key_algorithm: typing.Optional["IssuerSpecAcmeExternalAccountBindingKeyAlgorithm"] = None,
    ) -> None:
        '''ExternalAccountBinding is a reference to a CA external account of the ACME server.

        If set, upon registration cert-manager will attempt to associate the given
        external account credentials with the registered ACME account.

        :param key_id: keyID is the ID of the CA key that the External Account is bound to.
        :param key_secret_ref: keySecretRef is a Secret Key Selector referencing a data item in a Kubernetes Secret which holds the symmetric MAC key of the External Account Binding. The ``key`` is the index string that is paired with the key data in the Secret and should not be confused with the key data itself, or indeed with the External Account Binding keyID above. The secret key stored in the Secret **must** be un-padded, base64 URL encoded data.
        :param key_algorithm: Deprecated: keyAlgorithm field exists for historical compatibility reasons and should not be used. The algorithm is now hardcoded to HS256 in golang/x/crypto/acme.

        :schema: IssuerSpecAcmeExternalAccountBinding
        '''
        if isinstance(key_secret_ref, dict):
            key_secret_ref = IssuerSpecAcmeExternalAccountBindingKeySecretRef(**key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__149f4a3e8a26e291f2acf9648915c32e9ea0694c591c3d982c5ff3759a372ff0)
            check_type(argname="argument key_id", value=key_id, expected_type=type_hints["key_id"])
            check_type(argname="argument key_secret_ref", value=key_secret_ref, expected_type=type_hints["key_secret_ref"])
            check_type(argname="argument key_algorithm", value=key_algorithm, expected_type=type_hints["key_algorithm"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key_id": key_id,
            "key_secret_ref": key_secret_ref,
        }
        if key_algorithm is not None:
            self._values["key_algorithm"] = key_algorithm

    @builtins.property
    def key_id(self) -> builtins.str:
        '''keyID is the ID of the CA key that the External Account is bound to.

        :schema: IssuerSpecAcmeExternalAccountBinding#keyID
        '''
        result = self._values.get("key_id")
        assert result is not None, "Required property 'key_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key_secret_ref(self) -> "IssuerSpecAcmeExternalAccountBindingKeySecretRef":
        '''keySecretRef is a Secret Key Selector referencing a data item in a Kubernetes Secret which holds the symmetric MAC key of the External Account Binding.

        The ``key`` is the index string that is paired with the key data in the
        Secret and should not be confused with the key data itself, or indeed with
        the External Account Binding keyID above.
        The secret key stored in the Secret **must** be un-padded, base64 URL
        encoded data.

        :schema: IssuerSpecAcmeExternalAccountBinding#keySecretRef
        '''
        result = self._values.get("key_secret_ref")
        assert result is not None, "Required property 'key_secret_ref' is missing"
        return typing.cast("IssuerSpecAcmeExternalAccountBindingKeySecretRef", result)

    @builtins.property
    def key_algorithm(
        self,
    ) -> typing.Optional["IssuerSpecAcmeExternalAccountBindingKeyAlgorithm"]:
        '''Deprecated: keyAlgorithm field exists for historical compatibility reasons and should not be used.

        The algorithm is now hardcoded to HS256
        in golang/x/crypto/acme.

        :schema: IssuerSpecAcmeExternalAccountBinding#keyAlgorithm
        '''
        result = self._values.get("key_algorithm")
        return typing.cast(typing.Optional["IssuerSpecAcmeExternalAccountBindingKeyAlgorithm"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeExternalAccountBinding(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="iocert-manager.IssuerSpecAcmeExternalAccountBindingKeyAlgorithm")
class IssuerSpecAcmeExternalAccountBindingKeyAlgorithm(enum.Enum):
    '''Deprecated: keyAlgorithm field exists for historical compatibility reasons and should not be used.

    The algorithm is now hardcoded to HS256
    in golang/x/crypto/acme.

    :schema: IssuerSpecAcmeExternalAccountBindingKeyAlgorithm
    '''

    HS256 = "HS256"
    '''HS256.'''
    HS384 = "HS384"
    '''HS384.'''
    HS512 = "HS512"
    '''HS512.'''


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeExternalAccountBindingKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecAcmeExternalAccountBindingKeySecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''keySecretRef is a Secret Key Selector referencing a data item in a Kubernetes Secret which holds the symmetric MAC key of the External Account Binding.

        The ``key`` is the index string that is paired with the key data in the
        Secret and should not be confused with the key data itself, or indeed with
        the External Account Binding keyID above.
        The secret key stored in the Secret **must** be un-padded, base64 URL
        encoded data.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecAcmeExternalAccountBindingKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7b25a561840cf943a890f1a8ee1e309316c78716150294a1685e80d88392167e)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmeExternalAccountBindingKeySecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecAcmeExternalAccountBindingKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeExternalAccountBindingKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmePrivateKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecAcmePrivateKeySecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''PrivateKey is the name of a Kubernetes Secret resource that will be used to store the automatically generated ACME account private key.

        Optionally, a ``key`` may be specified to select a specific entry within
        the named Secret resource.
        If ``key`` is not specified, a default of ``tls.key`` will be used.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecAcmePrivateKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__21543d785870011596c840834bc59b65f2a5c5540a5d688a20aa70861795e60b)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmePrivateKeySecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecAcmePrivateKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmePrivateKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolvers",
    jsii_struct_bases=[],
    name_mapping={"dns01": "dns01", "http01": "http01", "selector": "selector"},
)
class IssuerSpecAcmeSolvers:
    def __init__(
        self,
        *,
        dns01: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01", typing.Dict[builtins.str, typing.Any]]] = None,
        http01: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01", typing.Dict[builtins.str, typing.Any]]] = None,
        selector: typing.Optional[typing.Union["IssuerSpecAcmeSolversSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''An ACMEChallengeSolver describes how to solve ACME challenges for the issuer it is part of.

        A selector may be provided to use different solving strategies for different DNS names.
        Only one of HTTP01 or DNS01 must be provided.

        :param dns01: Configures cert-manager to attempt to complete authorizations by performing the DNS01 challenge flow.
        :param http01: Configures cert-manager to attempt to complete authorizations by performing the HTTP01 challenge flow. It is not possible to obtain certificates for wildcard domain names (e.g. ``*.example.com``) using the HTTP01 challenge mechanism.
        :param selector: Selector selects a set of DNSNames on the Certificate resource that should be solved using this challenge solver. If not specified, the solver will be treated as the 'default' solver with the lowest priority, i.e. if any other solver has a more specific match, it will be used instead.

        :schema: IssuerSpecAcmeSolvers
        '''
        if isinstance(dns01, dict):
            dns01 = IssuerSpecAcmeSolversDns01(**dns01)
        if isinstance(http01, dict):
            http01 = IssuerSpecAcmeSolversHttp01(**http01)
        if isinstance(selector, dict):
            selector = IssuerSpecAcmeSolversSelector(**selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f0523c38698d0ee5320f4080a0458bd6011f230a35d3a577a4018d9439a4921)
            check_type(argname="argument dns01", value=dns01, expected_type=type_hints["dns01"])
            check_type(argname="argument http01", value=http01, expected_type=type_hints["http01"])
            check_type(argname="argument selector", value=selector, expected_type=type_hints["selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dns01 is not None:
            self._values["dns01"] = dns01
        if http01 is not None:
            self._values["http01"] = http01
        if selector is not None:
            self._values["selector"] = selector

    @builtins.property
    def dns01(self) -> typing.Optional["IssuerSpecAcmeSolversDns01"]:
        '''Configures cert-manager to attempt to complete authorizations by performing the DNS01 challenge flow.

        :schema: IssuerSpecAcmeSolvers#dns01
        '''
        result = self._values.get("dns01")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01"], result)

    @builtins.property
    def http01(self) -> typing.Optional["IssuerSpecAcmeSolversHttp01"]:
        '''Configures cert-manager to attempt to complete authorizations by performing the HTTP01 challenge flow.

        It is not possible to obtain certificates for wildcard domain names
        (e.g. ``*.example.com``) using the HTTP01 challenge mechanism.

        :schema: IssuerSpecAcmeSolvers#http01
        '''
        result = self._values.get("http01")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01"], result)

    @builtins.property
    def selector(self) -> typing.Optional["IssuerSpecAcmeSolversSelector"]:
        '''Selector selects a set of DNSNames on the Certificate resource that should be solved using this challenge solver.

        If not specified, the solver will be treated as the 'default' solver
        with the lowest priority, i.e. if any other solver has a more specific
        match, it will be used instead.

        :schema: IssuerSpecAcmeSolvers#selector
        '''
        result = self._values.get("selector")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolvers(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01",
    jsii_struct_bases=[],
    name_mapping={
        "acme_dns": "acmeDns",
        "akamai": "akamai",
        "azure_dns": "azureDns",
        "cloud_dns": "cloudDns",
        "cloudflare": "cloudflare",
        "cname_strategy": "cnameStrategy",
        "digitalocean": "digitalocean",
        "rfc2136": "rfc2136",
        "route53": "route53",
        "webhook": "webhook",
    },
)
class IssuerSpecAcmeSolversDns01:
    def __init__(
        self,
        *,
        acme_dns: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01AcmeDns", typing.Dict[builtins.str, typing.Any]]] = None,
        akamai: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01Akamai", typing.Dict[builtins.str, typing.Any]]] = None,
        azure_dns: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01AzureDns", typing.Dict[builtins.str, typing.Any]]] = None,
        cloud_dns: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01CloudDns", typing.Dict[builtins.str, typing.Any]]] = None,
        cloudflare: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01Cloudflare", typing.Dict[builtins.str, typing.Any]]] = None,
        cname_strategy: typing.Optional["IssuerSpecAcmeSolversDns01CnameStrategy"] = None,
        digitalocean: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01Digitalocean", typing.Dict[builtins.str, typing.Any]]] = None,
        rfc2136: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01Rfc2136", typing.Dict[builtins.str, typing.Any]]] = None,
        route53: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01Route53", typing.Dict[builtins.str, typing.Any]]] = None,
        webhook: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01Webhook", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Configures cert-manager to attempt to complete authorizations by performing the DNS01 challenge flow.

        :param acme_dns: Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage DNS01 challenge records.
        :param akamai: Use the Akamai DNS zone management API to manage DNS01 challenge records.
        :param azure_dns: Use the Microsoft Azure DNS API to manage DNS01 challenge records.
        :param cloud_dns: Use the Google Cloud DNS API to manage DNS01 challenge records.
        :param cloudflare: Use the Cloudflare API to manage DNS01 challenge records.
        :param cname_strategy: CNAMEStrategy configures how the DNS01 provider should handle CNAME records when found in DNS zones.
        :param digitalocean: Use the DigitalOcean DNS API to manage DNS01 challenge records.
        :param rfc2136: Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/) to manage DNS01 challenge records.
        :param route53: Use the AWS Route53 API to manage DNS01 challenge records.
        :param webhook: Configure an external webhook based DNS01 challenge solver to manage DNS01 challenge records.

        :schema: IssuerSpecAcmeSolversDns01
        '''
        if isinstance(acme_dns, dict):
            acme_dns = IssuerSpecAcmeSolversDns01AcmeDns(**acme_dns)
        if isinstance(akamai, dict):
            akamai = IssuerSpecAcmeSolversDns01Akamai(**akamai)
        if isinstance(azure_dns, dict):
            azure_dns = IssuerSpecAcmeSolversDns01AzureDns(**azure_dns)
        if isinstance(cloud_dns, dict):
            cloud_dns = IssuerSpecAcmeSolversDns01CloudDns(**cloud_dns)
        if isinstance(cloudflare, dict):
            cloudflare = IssuerSpecAcmeSolversDns01Cloudflare(**cloudflare)
        if isinstance(digitalocean, dict):
            digitalocean = IssuerSpecAcmeSolversDns01Digitalocean(**digitalocean)
        if isinstance(rfc2136, dict):
            rfc2136 = IssuerSpecAcmeSolversDns01Rfc2136(**rfc2136)
        if isinstance(route53, dict):
            route53 = IssuerSpecAcmeSolversDns01Route53(**route53)
        if isinstance(webhook, dict):
            webhook = IssuerSpecAcmeSolversDns01Webhook(**webhook)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64ff2487915507a712b7b0f2db7ae7a6199871a213585881524c0e9fca195853)
            check_type(argname="argument acme_dns", value=acme_dns, expected_type=type_hints["acme_dns"])
            check_type(argname="argument akamai", value=akamai, expected_type=type_hints["akamai"])
            check_type(argname="argument azure_dns", value=azure_dns, expected_type=type_hints["azure_dns"])
            check_type(argname="argument cloud_dns", value=cloud_dns, expected_type=type_hints["cloud_dns"])
            check_type(argname="argument cloudflare", value=cloudflare, expected_type=type_hints["cloudflare"])
            check_type(argname="argument cname_strategy", value=cname_strategy, expected_type=type_hints["cname_strategy"])
            check_type(argname="argument digitalocean", value=digitalocean, expected_type=type_hints["digitalocean"])
            check_type(argname="argument rfc2136", value=rfc2136, expected_type=type_hints["rfc2136"])
            check_type(argname="argument route53", value=route53, expected_type=type_hints["route53"])
            check_type(argname="argument webhook", value=webhook, expected_type=type_hints["webhook"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if acme_dns is not None:
            self._values["acme_dns"] = acme_dns
        if akamai is not None:
            self._values["akamai"] = akamai
        if azure_dns is not None:
            self._values["azure_dns"] = azure_dns
        if cloud_dns is not None:
            self._values["cloud_dns"] = cloud_dns
        if cloudflare is not None:
            self._values["cloudflare"] = cloudflare
        if cname_strategy is not None:
            self._values["cname_strategy"] = cname_strategy
        if digitalocean is not None:
            self._values["digitalocean"] = digitalocean
        if rfc2136 is not None:
            self._values["rfc2136"] = rfc2136
        if route53 is not None:
            self._values["route53"] = route53
        if webhook is not None:
            self._values["webhook"] = webhook

    @builtins.property
    def acme_dns(self) -> typing.Optional["IssuerSpecAcmeSolversDns01AcmeDns"]:
        '''Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage DNS01 challenge records.

        :schema: IssuerSpecAcmeSolversDns01#acmeDNS
        '''
        result = self._values.get("acme_dns")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01AcmeDns"], result)

    @builtins.property
    def akamai(self) -> typing.Optional["IssuerSpecAcmeSolversDns01Akamai"]:
        '''Use the Akamai DNS zone management API to manage DNS01 challenge records.

        :schema: IssuerSpecAcmeSolversDns01#akamai
        '''
        result = self._values.get("akamai")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01Akamai"], result)

    @builtins.property
    def azure_dns(self) -> typing.Optional["IssuerSpecAcmeSolversDns01AzureDns"]:
        '''Use the Microsoft Azure DNS API to manage DNS01 challenge records.

        :schema: IssuerSpecAcmeSolversDns01#azureDNS
        '''
        result = self._values.get("azure_dns")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01AzureDns"], result)

    @builtins.property
    def cloud_dns(self) -> typing.Optional["IssuerSpecAcmeSolversDns01CloudDns"]:
        '''Use the Google Cloud DNS API to manage DNS01 challenge records.

        :schema: IssuerSpecAcmeSolversDns01#cloudDNS
        '''
        result = self._values.get("cloud_dns")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01CloudDns"], result)

    @builtins.property
    def cloudflare(self) -> typing.Optional["IssuerSpecAcmeSolversDns01Cloudflare"]:
        '''Use the Cloudflare API to manage DNS01 challenge records.

        :schema: IssuerSpecAcmeSolversDns01#cloudflare
        '''
        result = self._values.get("cloudflare")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01Cloudflare"], result)

    @builtins.property
    def cname_strategy(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversDns01CnameStrategy"]:
        '''CNAMEStrategy configures how the DNS01 provider should handle CNAME records when found in DNS zones.

        :schema: IssuerSpecAcmeSolversDns01#cnameStrategy
        '''
        result = self._values.get("cname_strategy")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01CnameStrategy"], result)

    @builtins.property
    def digitalocean(self) -> typing.Optional["IssuerSpecAcmeSolversDns01Digitalocean"]:
        '''Use the DigitalOcean DNS API to manage DNS01 challenge records.

        :schema: IssuerSpecAcmeSolversDns01#digitalocean
        '''
        result = self._values.get("digitalocean")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01Digitalocean"], result)

    @builtins.property
    def rfc2136(self) -> typing.Optional["IssuerSpecAcmeSolversDns01Rfc2136"]:
        '''Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/) to manage DNS01 challenge records.

        :schema: IssuerSpecAcmeSolversDns01#rfc2136
        '''
        result = self._values.get("rfc2136")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01Rfc2136"], result)

    @builtins.property
    def route53(self) -> typing.Optional["IssuerSpecAcmeSolversDns01Route53"]:
        '''Use the AWS Route53 API to manage DNS01 challenge records.

        :schema: IssuerSpecAcmeSolversDns01#route53
        '''
        result = self._values.get("route53")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01Route53"], result)

    @builtins.property
    def webhook(self) -> typing.Optional["IssuerSpecAcmeSolversDns01Webhook"]:
        '''Configure an external webhook based DNS01 challenge solver to manage DNS01 challenge records.

        :schema: IssuerSpecAcmeSolversDns01#webhook
        '''
        result = self._values.get("webhook")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01Webhook"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01AcmeDns",
    jsii_struct_bases=[],
    name_mapping={"account_secret_ref": "accountSecretRef", "host": "host"},
)
class IssuerSpecAcmeSolversDns01AcmeDns:
    def __init__(
        self,
        *,
        account_secret_ref: typing.Union["IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef", typing.Dict[builtins.str, typing.Any]],
        host: builtins.str,
    ) -> None:
        '''Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage DNS01 challenge records.

        :param account_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param host: 

        :schema: IssuerSpecAcmeSolversDns01AcmeDns
        '''
        if isinstance(account_secret_ref, dict):
            account_secret_ref = IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef(**account_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b8945838123f7229621182c22d672ce571304bf831fc09f71e3f6cf37cdea3b2)
            check_type(argname="argument account_secret_ref", value=account_secret_ref, expected_type=type_hints["account_secret_ref"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "account_secret_ref": account_secret_ref,
            "host": host,
        }

    @builtins.property
    def account_secret_ref(self) -> "IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: IssuerSpecAcmeSolversDns01AcmeDns#accountSecretRef
        '''
        result = self._values.get("account_secret_ref")
        assert result is not None, "Required property 'account_secret_ref' is missing"
        return typing.cast("IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef", result)

    @builtins.property
    def host(self) -> builtins.str:
        '''
        :schema: IssuerSpecAcmeSolversDns01AcmeDns#host
        '''
        result = self._values.get("host")
        assert result is not None, "Required property 'host' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01AcmeDns(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da6821fae3a20e0a9fec8dce2d8b5a50a8c098e10fcf4a2ba714c18aedbe8416)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01Akamai",
    jsii_struct_bases=[],
    name_mapping={
        "access_token_secret_ref": "accessTokenSecretRef",
        "client_secret_secret_ref": "clientSecretSecretRef",
        "client_token_secret_ref": "clientTokenSecretRef",
        "service_consumer_domain": "serviceConsumerDomain",
    },
)
class IssuerSpecAcmeSolversDns01Akamai:
    def __init__(
        self,
        *,
        access_token_secret_ref: typing.Union["IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef", typing.Dict[builtins.str, typing.Any]],
        client_secret_secret_ref: typing.Union["IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef", typing.Dict[builtins.str, typing.Any]],
        client_token_secret_ref: typing.Union["IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef", typing.Dict[builtins.str, typing.Any]],
        service_consumer_domain: builtins.str,
    ) -> None:
        '''Use the Akamai DNS zone management API to manage DNS01 challenge records.

        :param access_token_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param client_secret_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param client_token_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param service_consumer_domain: 

        :schema: IssuerSpecAcmeSolversDns01Akamai
        '''
        if isinstance(access_token_secret_ref, dict):
            access_token_secret_ref = IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef(**access_token_secret_ref)
        if isinstance(client_secret_secret_ref, dict):
            client_secret_secret_ref = IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef(**client_secret_secret_ref)
        if isinstance(client_token_secret_ref, dict):
            client_token_secret_ref = IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef(**client_token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e149e172532ab5c05466e9e94df4608e44ecc867ccc43a8936aba7f66ddbf79)
            check_type(argname="argument access_token_secret_ref", value=access_token_secret_ref, expected_type=type_hints["access_token_secret_ref"])
            check_type(argname="argument client_secret_secret_ref", value=client_secret_secret_ref, expected_type=type_hints["client_secret_secret_ref"])
            check_type(argname="argument client_token_secret_ref", value=client_token_secret_ref, expected_type=type_hints["client_token_secret_ref"])
            check_type(argname="argument service_consumer_domain", value=service_consumer_domain, expected_type=type_hints["service_consumer_domain"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "access_token_secret_ref": access_token_secret_ref,
            "client_secret_secret_ref": client_secret_secret_ref,
            "client_token_secret_ref": client_token_secret_ref,
            "service_consumer_domain": service_consumer_domain,
        }

    @builtins.property
    def access_token_secret_ref(
        self,
    ) -> "IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: IssuerSpecAcmeSolversDns01Akamai#accessTokenSecretRef
        '''
        result = self._values.get("access_token_secret_ref")
        assert result is not None, "Required property 'access_token_secret_ref' is missing"
        return typing.cast("IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef", result)

    @builtins.property
    def client_secret_secret_ref(
        self,
    ) -> "IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: IssuerSpecAcmeSolversDns01Akamai#clientSecretSecretRef
        '''
        result = self._values.get("client_secret_secret_ref")
        assert result is not None, "Required property 'client_secret_secret_ref' is missing"
        return typing.cast("IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef", result)

    @builtins.property
    def client_token_secret_ref(
        self,
    ) -> "IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: IssuerSpecAcmeSolversDns01Akamai#clientTokenSecretRef
        '''
        result = self._values.get("client_token_secret_ref")
        assert result is not None, "Required property 'client_token_secret_ref' is missing"
        return typing.cast("IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef", result)

    @builtins.property
    def service_consumer_domain(self) -> builtins.str:
        '''
        :schema: IssuerSpecAcmeSolversDns01Akamai#serviceConsumerDomain
        '''
        result = self._values.get("service_consumer_domain")
        assert result is not None, "Required property 'service_consumer_domain' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01Akamai(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__81809c1b25e7aa59da1601912118f405118772afc4924f0c03b672ccad6c16f6)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a362917d6882faae29084c4254a90c7baa93f4691e66bbd5bdb51ef7d42ec02e)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da946514a1e11e5595113d94deee291e52e7b1687af9a48ba21065d4e7ebf4d4)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01AzureDns",
    jsii_struct_bases=[],
    name_mapping={
        "resource_group_name": "resourceGroupName",
        "subscription_id": "subscriptionId",
        "client_id": "clientId",
        "client_secret_secret_ref": "clientSecretSecretRef",
        "environment": "environment",
        "hosted_zone_name": "hostedZoneName",
        "managed_identity": "managedIdentity",
        "tenant_id": "tenantId",
    },
)
class IssuerSpecAcmeSolversDns01AzureDns:
    def __init__(
        self,
        *,
        resource_group_name: builtins.str,
        subscription_id: builtins.str,
        client_id: typing.Optional[builtins.str] = None,
        client_secret_secret_ref: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        environment: typing.Optional["IssuerSpecAcmeSolversDns01AzureDnsEnvironment"] = None,
        hosted_zone_name: typing.Optional[builtins.str] = None,
        managed_identity: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity", typing.Dict[builtins.str, typing.Any]]] = None,
        tenant_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Use the Microsoft Azure DNS API to manage DNS01 challenge records.

        :param resource_group_name: resource group the DNS zone is located in.
        :param subscription_id: ID of the Azure subscription.
        :param client_id: Auth: Azure Service Principal: The ClientID of the Azure Service Principal used to authenticate with Azure DNS. If set, ClientSecret and TenantID must also be set.
        :param client_secret_secret_ref: Auth: Azure Service Principal: A reference to a Secret containing the password associated with the Service Principal. If set, ClientID and TenantID must also be set.
        :param environment: name of the Azure environment (default AzurePublicCloud).
        :param hosted_zone_name: name of the DNS zone that should be used.
        :param managed_identity: Auth: Azure Workload Identity or Azure Managed Service Identity: Settings to enable Azure Workload Identity or Azure Managed Service Identity If set, ClientID, ClientSecret and TenantID must not be set.
        :param tenant_id: Auth: Azure Service Principal: The TenantID of the Azure Service Principal used to authenticate with Azure DNS. If set, ClientID and ClientSecret must also be set.

        :schema: IssuerSpecAcmeSolversDns01AzureDns
        '''
        if isinstance(client_secret_secret_ref, dict):
            client_secret_secret_ref = IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef(**client_secret_secret_ref)
        if isinstance(managed_identity, dict):
            managed_identity = IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity(**managed_identity)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bad043d89217aad4f9aad94a72a65b2a8086e2d669074888f55a7c4c25fe62b4)
            check_type(argname="argument resource_group_name", value=resource_group_name, expected_type=type_hints["resource_group_name"])
            check_type(argname="argument subscription_id", value=subscription_id, expected_type=type_hints["subscription_id"])
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret_secret_ref", value=client_secret_secret_ref, expected_type=type_hints["client_secret_secret_ref"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument hosted_zone_name", value=hosted_zone_name, expected_type=type_hints["hosted_zone_name"])
            check_type(argname="argument managed_identity", value=managed_identity, expected_type=type_hints["managed_identity"])
            check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "resource_group_name": resource_group_name,
            "subscription_id": subscription_id,
        }
        if client_id is not None:
            self._values["client_id"] = client_id
        if client_secret_secret_ref is not None:
            self._values["client_secret_secret_ref"] = client_secret_secret_ref
        if environment is not None:
            self._values["environment"] = environment
        if hosted_zone_name is not None:
            self._values["hosted_zone_name"] = hosted_zone_name
        if managed_identity is not None:
            self._values["managed_identity"] = managed_identity
        if tenant_id is not None:
            self._values["tenant_id"] = tenant_id

    @builtins.property
    def resource_group_name(self) -> builtins.str:
        '''resource group the DNS zone is located in.

        :schema: IssuerSpecAcmeSolversDns01AzureDns#resourceGroupName
        '''
        result = self._values.get("resource_group_name")
        assert result is not None, "Required property 'resource_group_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def subscription_id(self) -> builtins.str:
        '''ID of the Azure subscription.

        :schema: IssuerSpecAcmeSolversDns01AzureDns#subscriptionID
        '''
        result = self._values.get("subscription_id")
        assert result is not None, "Required property 'subscription_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def client_id(self) -> typing.Optional[builtins.str]:
        '''Auth: Azure Service Principal: The ClientID of the Azure Service Principal used to authenticate with Azure DNS.

        If set, ClientSecret and TenantID must also be set.

        :schema: IssuerSpecAcmeSolversDns01AzureDns#clientID
        '''
        result = self._values.get("client_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def client_secret_secret_ref(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef"]:
        '''Auth: Azure Service Principal: A reference to a Secret containing the password associated with the Service Principal.

        If set, ClientID and TenantID must also be set.

        :schema: IssuerSpecAcmeSolversDns01AzureDns#clientSecretSecretRef
        '''
        result = self._values.get("client_secret_secret_ref")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef"], result)

    @builtins.property
    def environment(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversDns01AzureDnsEnvironment"]:
        '''name of the Azure environment (default AzurePublicCloud).

        :schema: IssuerSpecAcmeSolversDns01AzureDns#environment
        '''
        result = self._values.get("environment")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01AzureDnsEnvironment"], result)

    @builtins.property
    def hosted_zone_name(self) -> typing.Optional[builtins.str]:
        '''name of the DNS zone that should be used.

        :schema: IssuerSpecAcmeSolversDns01AzureDns#hostedZoneName
        '''
        result = self._values.get("hosted_zone_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def managed_identity(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity"]:
        '''Auth: Azure Workload Identity or Azure Managed Service Identity: Settings to enable Azure Workload Identity or Azure Managed Service Identity If set, ClientID, ClientSecret and TenantID must not be set.

        :schema: IssuerSpecAcmeSolversDns01AzureDns#managedIdentity
        '''
        result = self._values.get("managed_identity")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity"], result)

    @builtins.property
    def tenant_id(self) -> typing.Optional[builtins.str]:
        '''Auth: Azure Service Principal: The TenantID of the Azure Service Principal used to authenticate with Azure DNS.

        If set, ClientID and ClientSecret must also be set.

        :schema: IssuerSpecAcmeSolversDns01AzureDns#tenantID
        '''
        result = self._values.get("tenant_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01AzureDns(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Auth: Azure Service Principal: A reference to a Secret containing the password associated with the Service Principal.

        If set, ClientID and TenantID must also be set.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b23afb300c49b2b2394174efde56547718791d726a7d72202e811211706f4d3)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01AzureDnsEnvironment")
class IssuerSpecAcmeSolversDns01AzureDnsEnvironment(enum.Enum):
    '''name of the Azure environment (default AzurePublicCloud).

    :schema: IssuerSpecAcmeSolversDns01AzureDnsEnvironment
    '''

    AZURE_PUBLIC_CLOUD = "AZURE_PUBLIC_CLOUD"
    '''AzurePublicCloud.'''
    AZURE_CHINA_CLOUD = "AZURE_CHINA_CLOUD"
    '''AzureChinaCloud.'''
    AZURE_GERMAN_CLOUD = "AZURE_GERMAN_CLOUD"
    '''AzureGermanCloud.'''
    AZURE_US_GOVERNMENT_CLOUD = "AZURE_US_GOVERNMENT_CLOUD"
    '''AzureUSGovernmentCloud.'''


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity",
    jsii_struct_bases=[],
    name_mapping={
        "client_id": "clientId",
        "resource_id": "resourceId",
        "tenant_id": "tenantId",
    },
)
class IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity:
    def __init__(
        self,
        *,
        client_id: typing.Optional[builtins.str] = None,
        resource_id: typing.Optional[builtins.str] = None,
        tenant_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Auth: Azure Workload Identity or Azure Managed Service Identity: Settings to enable Azure Workload Identity or Azure Managed Service Identity If set, ClientID, ClientSecret and TenantID must not be set.

        :param client_id: client ID of the managed identity, can not be used at the same time as resourceID.
        :param resource_id: resource ID of the managed identity, can not be used at the same time as clientID Cannot be used for Azure Managed Service Identity.
        :param tenant_id: tenant ID of the managed identity, can not be used at the same time as resourceID.

        :schema: IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab6817c21007661949dd13f6c539c59dad5efa42b009fb693fc5a527fb948cef)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
            check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_id is not None:
            self._values["client_id"] = client_id
        if resource_id is not None:
            self._values["resource_id"] = resource_id
        if tenant_id is not None:
            self._values["tenant_id"] = tenant_id

    @builtins.property
    def client_id(self) -> typing.Optional[builtins.str]:
        '''client ID of the managed identity, can not be used at the same time as resourceID.

        :schema: IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity#clientID
        '''
        result = self._values.get("client_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def resource_id(self) -> typing.Optional[builtins.str]:
        '''resource ID of the managed identity, can not be used at the same time as clientID Cannot be used for Azure Managed Service Identity.

        :schema: IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity#resourceID
        '''
        result = self._values.get("resource_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tenant_id(self) -> typing.Optional[builtins.str]:
        '''tenant ID of the managed identity, can not be used at the same time as resourceID.

        :schema: IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity#tenantID
        '''
        result = self._values.get("tenant_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01CloudDns",
    jsii_struct_bases=[],
    name_mapping={
        "project": "project",
        "hosted_zone_name": "hostedZoneName",
        "service_account_secret_ref": "serviceAccountSecretRef",
    },
)
class IssuerSpecAcmeSolversDns01CloudDns:
    def __init__(
        self,
        *,
        project: builtins.str,
        hosted_zone_name: typing.Optional[builtins.str] = None,
        service_account_secret_ref: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Use the Google Cloud DNS API to manage DNS01 challenge records.

        :param project: 
        :param hosted_zone_name: HostedZoneName is an optional field that tells cert-manager in which Cloud DNS zone the challenge record has to be created. If left empty cert-manager will automatically choose a zone.
        :param service_account_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: IssuerSpecAcmeSolversDns01CloudDns
        '''
        if isinstance(service_account_secret_ref, dict):
            service_account_secret_ref = IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef(**service_account_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eca5bd7a96840d02dbfb643408ada857d1cc2325bebfa5ef4121382228f578e7)
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
            check_type(argname="argument hosted_zone_name", value=hosted_zone_name, expected_type=type_hints["hosted_zone_name"])
            check_type(argname="argument service_account_secret_ref", value=service_account_secret_ref, expected_type=type_hints["service_account_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "project": project,
        }
        if hosted_zone_name is not None:
            self._values["hosted_zone_name"] = hosted_zone_name
        if service_account_secret_ref is not None:
            self._values["service_account_secret_ref"] = service_account_secret_ref

    @builtins.property
    def project(self) -> builtins.str:
        '''
        :schema: IssuerSpecAcmeSolversDns01CloudDns#project
        '''
        result = self._values.get("project")
        assert result is not None, "Required property 'project' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def hosted_zone_name(self) -> typing.Optional[builtins.str]:
        '''HostedZoneName is an optional field that tells cert-manager in which Cloud DNS zone the challenge record has to be created.

        If left empty cert-manager will automatically choose a zone.

        :schema: IssuerSpecAcmeSolversDns01CloudDns#hostedZoneName
        '''
        result = self._values.get("hosted_zone_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_account_secret_ref(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: IssuerSpecAcmeSolversDns01CloudDns#serviceAccountSecretRef
        '''
        result = self._values.get("service_account_secret_ref")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01CloudDns(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5aae493aafb82a17189f7b1276db6e8cc246b65f009311dc5cb4504f8aa933a2)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01Cloudflare",
    jsii_struct_bases=[],
    name_mapping={
        "api_key_secret_ref": "apiKeySecretRef",
        "api_token_secret_ref": "apiTokenSecretRef",
        "email": "email",
    },
)
class IssuerSpecAcmeSolversDns01Cloudflare:
    def __init__(
        self,
        *,
        api_key_secret_ref: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        api_token_secret_ref: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        email: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Use the Cloudflare API to manage DNS01 challenge records.

        :param api_key_secret_ref: API key to use to authenticate with Cloudflare. Note: using an API token to authenticate is now the recommended method as it allows greater control of permissions.
        :param api_token_secret_ref: API token used to authenticate with Cloudflare.
        :param email: Email of the account, only required when using API key based authentication.

        :schema: IssuerSpecAcmeSolversDns01Cloudflare
        '''
        if isinstance(api_key_secret_ref, dict):
            api_key_secret_ref = IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef(**api_key_secret_ref)
        if isinstance(api_token_secret_ref, dict):
            api_token_secret_ref = IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef(**api_token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__032e0836bdbbc3d7675ed1dcf336b375d189f7a3b88e93f9da6111d6c96d1566)
            check_type(argname="argument api_key_secret_ref", value=api_key_secret_ref, expected_type=type_hints["api_key_secret_ref"])
            check_type(argname="argument api_token_secret_ref", value=api_token_secret_ref, expected_type=type_hints["api_token_secret_ref"])
            check_type(argname="argument email", value=email, expected_type=type_hints["email"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if api_key_secret_ref is not None:
            self._values["api_key_secret_ref"] = api_key_secret_ref
        if api_token_secret_ref is not None:
            self._values["api_token_secret_ref"] = api_token_secret_ref
        if email is not None:
            self._values["email"] = email

    @builtins.property
    def api_key_secret_ref(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef"]:
        '''API key to use to authenticate with Cloudflare.

        Note: using an API token to authenticate is now the recommended method
        as it allows greater control of permissions.

        :schema: IssuerSpecAcmeSolversDns01Cloudflare#apiKeySecretRef
        '''
        result = self._values.get("api_key_secret_ref")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef"], result)

    @builtins.property
    def api_token_secret_ref(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef"]:
        '''API token used to authenticate with Cloudflare.

        :schema: IssuerSpecAcmeSolversDns01Cloudflare#apiTokenSecretRef
        '''
        result = self._values.get("api_token_secret_ref")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef"], result)

    @builtins.property
    def email(self) -> typing.Optional[builtins.str]:
        '''Email of the account, only required when using API key based authentication.

        :schema: IssuerSpecAcmeSolversDns01Cloudflare#email
        '''
        result = self._values.get("email")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01Cloudflare(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''API key to use to authenticate with Cloudflare.

        Note: using an API token to authenticate is now the recommended method
        as it allows greater control of permissions.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__331f8d356453e4ee390d77e9697b2ba85d66bb612830aac61ab1fca35c9160d4)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''API token used to authenticate with Cloudflare.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__80235029e6947ed91ef8492ebe7247d193719ff3f992606c47423d64b8ae6d88)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01CnameStrategy")
class IssuerSpecAcmeSolversDns01CnameStrategy(enum.Enum):
    '''CNAMEStrategy configures how the DNS01 provider should handle CNAME records when found in DNS zones.

    :schema: IssuerSpecAcmeSolversDns01CnameStrategy
    '''

    NONE = "NONE"
    '''None.'''
    FOLLOW = "FOLLOW"
    '''Follow.'''


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01Digitalocean",
    jsii_struct_bases=[],
    name_mapping={"token_secret_ref": "tokenSecretRef"},
)
class IssuerSpecAcmeSolversDns01Digitalocean:
    def __init__(
        self,
        *,
        token_secret_ref: typing.Union["IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Use the DigitalOcean DNS API to manage DNS01 challenge records.

        :param token_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: IssuerSpecAcmeSolversDns01Digitalocean
        '''
        if isinstance(token_secret_ref, dict):
            token_secret_ref = IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef(**token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__68ba79130f363f4bfe1e7fd9eb299c7a1176cd97aee060aad4e12adf022f3034)
            check_type(argname="argument token_secret_ref", value=token_secret_ref, expected_type=type_hints["token_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "token_secret_ref": token_secret_ref,
        }

    @builtins.property
    def token_secret_ref(
        self,
    ) -> "IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: IssuerSpecAcmeSolversDns01Digitalocean#tokenSecretRef
        '''
        result = self._values.get("token_secret_ref")
        assert result is not None, "Required property 'token_secret_ref' is missing"
        return typing.cast("IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01Digitalocean(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__21be24f72251f2c01dc6697dc55466348220a65c50b2e65fd1bf56a2f67bf015)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01Rfc2136",
    jsii_struct_bases=[],
    name_mapping={
        "nameserver": "nameserver",
        "tsig_algorithm": "tsigAlgorithm",
        "tsig_key_name": "tsigKeyName",
        "tsig_secret_secret_ref": "tsigSecretSecretRef",
    },
)
class IssuerSpecAcmeSolversDns01Rfc2136:
    def __init__(
        self,
        *,
        nameserver: builtins.str,
        tsig_algorithm: typing.Optional[builtins.str] = None,
        tsig_key_name: typing.Optional[builtins.str] = None,
        tsig_secret_secret_ref: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/) to manage DNS01 challenge records.

        :param nameserver: The IP address or hostname of an authoritative DNS server supporting RFC2136 in the form host:port. If the host is an IPv6 address it must be enclosed in square brackets (e.g [2001:db8::1]) ; port is optional. This field is required.
        :param tsig_algorithm: The TSIG Algorithm configured in the DNS supporting RFC2136. Used only when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined. Supported values are (case-insensitive): ``HMACMD5`` (default), ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
        :param tsig_key_name: The TSIG Key name configured in the DNS. If ``tsigSecretSecretRef`` is defined, this field is required.
        :param tsig_secret_secret_ref: The name of the secret containing the TSIG value. If ``tsigKeyName`` is defined, this field is required.

        :schema: IssuerSpecAcmeSolversDns01Rfc2136
        '''
        if isinstance(tsig_secret_secret_ref, dict):
            tsig_secret_secret_ref = IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef(**tsig_secret_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f185a423ff293541c4fbfc259e8613e1490e77ee049c177550865250a767457)
            check_type(argname="argument nameserver", value=nameserver, expected_type=type_hints["nameserver"])
            check_type(argname="argument tsig_algorithm", value=tsig_algorithm, expected_type=type_hints["tsig_algorithm"])
            check_type(argname="argument tsig_key_name", value=tsig_key_name, expected_type=type_hints["tsig_key_name"])
            check_type(argname="argument tsig_secret_secret_ref", value=tsig_secret_secret_ref, expected_type=type_hints["tsig_secret_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "nameserver": nameserver,
        }
        if tsig_algorithm is not None:
            self._values["tsig_algorithm"] = tsig_algorithm
        if tsig_key_name is not None:
            self._values["tsig_key_name"] = tsig_key_name
        if tsig_secret_secret_ref is not None:
            self._values["tsig_secret_secret_ref"] = tsig_secret_secret_ref

    @builtins.property
    def nameserver(self) -> builtins.str:
        '''The IP address or hostname of an authoritative DNS server supporting RFC2136 in the form host:port.

        If the host is an IPv6 address it must be
        enclosed in square brackets (e.g [2001:db8::1]); port is optional.
        This field is required.

        :schema: IssuerSpecAcmeSolversDns01Rfc2136#nameserver
        '''
        result = self._values.get("nameserver")
        assert result is not None, "Required property 'nameserver' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tsig_algorithm(self) -> typing.Optional[builtins.str]:
        '''The TSIG Algorithm configured in the DNS supporting RFC2136.

        Used only
        when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined.
        Supported values are (case-insensitive): ``HMACMD5`` (default),
        ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.

        :schema: IssuerSpecAcmeSolversDns01Rfc2136#tsigAlgorithm
        '''
        result = self._values.get("tsig_algorithm")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tsig_key_name(self) -> typing.Optional[builtins.str]:
        '''The TSIG Key name configured in the DNS.

        If ``tsigSecretSecretRef`` is defined, this field is required.

        :schema: IssuerSpecAcmeSolversDns01Rfc2136#tsigKeyName
        '''
        result = self._values.get("tsig_key_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tsig_secret_secret_ref(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef"]:
        '''The name of the secret containing the TSIG value.

        If ``tsigKeyName`` is defined, this field is required.

        :schema: IssuerSpecAcmeSolversDns01Rfc2136#tsigSecretSecretRef
        '''
        result = self._values.get("tsig_secret_secret_ref")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01Rfc2136(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The name of the secret containing the TSIG value.

        If ``tsigKeyName`` is defined, this field is required.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f5c81ed304443fbf966447a43723db20d7ebc6990d2feb73299b662f3157403)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01Route53",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id": "accessKeyId",
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "auth": "auth",
        "hosted_zone_id": "hostedZoneId",
        "region": "region",
        "role": "role",
        "secret_access_key_secret_ref": "secretAccessKeySecretRef",
    },
)
class IssuerSpecAcmeSolversDns01Route53:
    def __init__(
        self,
        *,
        access_key_id: typing.Optional[builtins.str] = None,
        access_key_id_secret_ref: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        auth: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01Route53Auth", typing.Dict[builtins.str, typing.Any]]] = None,
        hosted_zone_id: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        secret_access_key_secret_ref: typing.Optional[typing.Union["IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Use the AWS Route53 API to manage DNS01 challenge records.

        :param access_key_id: The AccessKeyID is used for authentication. Cannot be set when SecretAccessKeyID is set. If neither the Access Key nor Key ID are set, we fall-back to using env vars, shared credentials file or AWS Instance metadata, see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
        :param access_key_id_secret_ref: The SecretAccessKey is used for authentication. If set, pull the AWS access key ID from a key within a Kubernetes Secret. Cannot be set when AccessKeyID is set. If neither the Access Key nor Key ID are set, we fall-back to using env vars, shared credentials file or AWS Instance metadata, see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
        :param auth: Auth configures how cert-manager authenticates.
        :param hosted_zone_id: If set, the provider will manage only this zone in Route53 and will not do a lookup using the route53:ListHostedZonesByName api call.
        :param region: Override the AWS region. Route53 is a global service and does not have regional endpoints but the region specified here (or via environment variables) is used as a hint to help compute the correct AWS credential scope and partition when it connects to Route53. See: - `Amazon Route 53 endpoints and quotas <https://docs.aws.amazon.com/general/latest/gr/r53.html>`_ - `Global services <https://docs.aws.amazon.com/whitepapers/latest/aws-fault-isolation-boundaries/global-services.html>`_ If you omit this region field, cert-manager will use the region from AWS_REGION and AWS_DEFAULT_REGION environment variables, if they are set in the cert-manager controller Pod. The ``region`` field is not needed if you use `IAM Roles for Service Accounts (IRSA) <https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html>`_. Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by: `Amazon EKS Pod Identity Webhook <https://github.com/aws/amazon-eks-pod-identity-webhook>`_. In this case this ``region`` field value is ignored. The ``region`` field is not needed if you use `EKS Pod Identities <https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html>`_. Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by: `Amazon EKS Pod Identity Agent <https://github.com/aws/eks-pod-identity-agent>`_, In this case this ``region`` field value is ignored.
        :param role: Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata.
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication. If neither the Access Key nor Key ID are set, we fall-back to using env vars, shared credentials file or AWS Instance metadata, see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials

        :schema: IssuerSpecAcmeSolversDns01Route53
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(auth, dict):
            auth = IssuerSpecAcmeSolversDns01Route53Auth(**auth)
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf01c5d5fc83dfa7e7314e95f234907e657c29a32af89b946028c3c927b91656)
            check_type(argname="argument access_key_id", value=access_key_id, expected_type=type_hints["access_key_id"])
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument hosted_zone_id", value=hosted_zone_id, expected_type=type_hints["hosted_zone_id"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_key_id is not None:
            self._values["access_key_id"] = access_key_id
        if access_key_id_secret_ref is not None:
            self._values["access_key_id_secret_ref"] = access_key_id_secret_ref
        if auth is not None:
            self._values["auth"] = auth
        if hosted_zone_id is not None:
            self._values["hosted_zone_id"] = hosted_zone_id
        if region is not None:
            self._values["region"] = region
        if role is not None:
            self._values["role"] = role
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref

    @builtins.property
    def access_key_id(self) -> typing.Optional[builtins.str]:
        '''The AccessKeyID is used for authentication.

        Cannot be set when SecretAccessKeyID is set.
        If neither the Access Key nor Key ID are set, we fall-back to using env
        vars, shared credentials file or AWS Instance metadata,
        see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials

        :schema: IssuerSpecAcmeSolversDns01Route53#accessKeyID
        '''
        result = self._values.get("access_key_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef"]:
        '''The SecretAccessKey is used for authentication.

        If set, pull the AWS
        access key ID from a key within a Kubernetes Secret.
        Cannot be set when AccessKeyID is set.
        If neither the Access Key nor Key ID are set, we fall-back to using env
        vars, shared credentials file or AWS Instance metadata,
        see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials

        :schema: IssuerSpecAcmeSolversDns01Route53#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef"], result)

    @builtins.property
    def auth(self) -> typing.Optional["IssuerSpecAcmeSolversDns01Route53Auth"]:
        '''Auth configures how cert-manager authenticates.

        :schema: IssuerSpecAcmeSolversDns01Route53#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01Route53Auth"], result)

    @builtins.property
    def hosted_zone_id(self) -> typing.Optional[builtins.str]:
        '''If set, the provider will manage only this zone in Route53 and will not do a lookup using the route53:ListHostedZonesByName api call.

        :schema: IssuerSpecAcmeSolversDns01Route53#hostedZoneID
        '''
        result = self._values.get("hosted_zone_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''Override the AWS region.

        Route53 is a global service and does not have regional endpoints but the
        region specified here (or via environment variables) is used as a hint to
        help compute the correct AWS credential scope and partition when it
        connects to Route53. See:

        - `Amazon Route 53 endpoints and quotas <https://docs.aws.amazon.com/general/latest/gr/r53.html>`_
        - `Global services <https://docs.aws.amazon.com/whitepapers/latest/aws-fault-isolation-boundaries/global-services.html>`_

        If you omit this region field, cert-manager will use the region from
        AWS_REGION and AWS_DEFAULT_REGION environment variables, if they are set
        in the cert-manager controller Pod.

        The ``region`` field is not needed if you use `IAM Roles for Service Accounts (IRSA) <https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html>`_.
        Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by:
        `Amazon EKS Pod Identity Webhook <https://github.com/aws/amazon-eks-pod-identity-webhook>`_.
        In this case this ``region`` field value is ignored.

        The ``region`` field is not needed if you use `EKS Pod Identities <https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html>`_.
        Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by:
        `Amazon EKS Pod Identity Agent <https://github.com/aws/eks-pod-identity-agent>`_,
        In this case this ``region`` field value is ignored.

        :schema: IssuerSpecAcmeSolversDns01Route53#region
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata.

        :schema: IssuerSpecAcmeSolversDns01Route53#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        If neither the Access Key nor Key ID are set, we fall-back to using env
        vars, shared credentials file or AWS Instance metadata,
        see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials

        :schema: IssuerSpecAcmeSolversDns01Route53#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01Route53(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        If set, pull the AWS
        access key ID from a key within a Kubernetes Secret.
        Cannot be set when AccessKeyID is set.
        If neither the Access Key nor Key ID are set, we fall-back to using env
        vars, shared credentials file or AWS Instance metadata,
        see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__edd58f1483cb70a3ef543f1c817660cb1c3ca2bf393f94f59d035db152dfb91b)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01Route53Auth",
    jsii_struct_bases=[],
    name_mapping={"kubernetes": "kubernetes"},
)
class IssuerSpecAcmeSolversDns01Route53Auth:
    def __init__(
        self,
        *,
        kubernetes: typing.Union["IssuerSpecAcmeSolversDns01Route53AuthKubernetes", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how cert-manager authenticates.

        :param kubernetes: Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity by passing a bound ServiceAccount token.

        :schema: IssuerSpecAcmeSolversDns01Route53Auth
        '''
        if isinstance(kubernetes, dict):
            kubernetes = IssuerSpecAcmeSolversDns01Route53AuthKubernetes(**kubernetes)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52bfe6172bd352db7d57db701c800c85ea670ac0836d2579df4bd8b96b1374ad)
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "kubernetes": kubernetes,
        }

    @builtins.property
    def kubernetes(self) -> "IssuerSpecAcmeSolversDns01Route53AuthKubernetes":
        '''Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity by passing a bound ServiceAccount token.

        :schema: IssuerSpecAcmeSolversDns01Route53Auth#kubernetes
        '''
        result = self._values.get("kubernetes")
        assert result is not None, "Required property 'kubernetes' is missing"
        return typing.cast("IssuerSpecAcmeSolversDns01Route53AuthKubernetes", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01Route53Auth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01Route53AuthKubernetes",
    jsii_struct_bases=[],
    name_mapping={"service_account_ref": "serviceAccountRef"},
)
class IssuerSpecAcmeSolversDns01Route53AuthKubernetes:
    def __init__(
        self,
        *,
        service_account_ref: typing.Union["IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity by passing a bound ServiceAccount token.

        :param service_account_ref: A reference to a service account that will be used to request a bound token (also known as "projected token"). To use this field, you must configure an RBAC rule to let cert-manager request a token.

        :schema: IssuerSpecAcmeSolversDns01Route53AuthKubernetes
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__260be20f67e778281bcfc1f338ca6e843c457030b60c8c83bcaebb96ca426df2)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "service_account_ref": service_account_ref,
        }

    @builtins.property
    def service_account_ref(
        self,
    ) -> "IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef":
        '''A reference to a service account that will be used to request a bound token (also known as "projected token").

        To use this field, you must
        configure an RBAC rule to let cert-manager request a token.

        :schema: IssuerSpecAcmeSolversDns01Route53AuthKubernetes#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01Route53AuthKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences"},
)
class IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A reference to a service account that will be used to request a bound token (also known as "projected token").

        To use this field, you must
        configure an RBAC rule to let cert-manager request a token.

        :param name: Name of the ServiceAccount used to request a token.
        :param audiences: TokenAudiences is an optional list of audiences to include in the token passed to AWS. The default token consisting of the issuer's namespace and name is always included. If unset the audience defaults to ``sts.amazonaws.com``.

        :schema: IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__96f8f055b6a88f39fc8999a8a4f169b1d7f1c7df1de1de5b2eab697f5b53e4f4)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the ServiceAccount used to request a token.

        :schema: IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''TokenAudiences is an optional list of audiences to include in the token passed to AWS.

        The default token consisting of the issuer's namespace
        and name is always included.
        If unset the audience defaults to ``sts.amazonaws.com``.

        :schema: IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        If neither the Access Key nor Key ID are set, we fall-back to using env
        vars, shared credentials file or AWS Instance metadata,
        see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f42e61abb4eb5b0c56df23dff7c88faafddc07495bb67281d8a4a094df1eab4f)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversDns01Webhook",
    jsii_struct_bases=[],
    name_mapping={
        "group_name": "groupName",
        "solver_name": "solverName",
        "config": "config",
    },
)
class IssuerSpecAcmeSolversDns01Webhook:
    def __init__(
        self,
        *,
        group_name: builtins.str,
        solver_name: builtins.str,
        config: typing.Any = None,
    ) -> None:
        '''Configure an external webhook based DNS01 challenge solver to manage DNS01 challenge records.

        :param group_name: The API group name that should be used when POSTing ChallengePayload resources to the webhook apiserver. This should be the same as the GroupName specified in the webhook provider implementation.
        :param solver_name: The name of the solver to use, as defined in the webhook provider implementation. This will typically be the name of the provider, e.g. 'cloudflare'.
        :param config: Additional configuration that should be passed to the webhook apiserver when challenges are processed. This can contain arbitrary JSON data. Secret values should not be specified in this stanza. If secret values are needed (e.g. credentials for a DNS service), you should use a SecretKeySelector to reference a Secret resource. For details on the schema of this field, consult the webhook provider implementation's documentation.

        :schema: IssuerSpecAcmeSolversDns01Webhook
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__27324d34c2d74899335664b8f69d21c8cdeffc3a38db0f99db2cac90149a6e87)
            check_type(argname="argument group_name", value=group_name, expected_type=type_hints["group_name"])
            check_type(argname="argument solver_name", value=solver_name, expected_type=type_hints["solver_name"])
            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "group_name": group_name,
            "solver_name": solver_name,
        }
        if config is not None:
            self._values["config"] = config

    @builtins.property
    def group_name(self) -> builtins.str:
        '''The API group name that should be used when POSTing ChallengePayload resources to the webhook apiserver.

        This should be the same as the GroupName specified in the webhook
        provider implementation.

        :schema: IssuerSpecAcmeSolversDns01Webhook#groupName
        '''
        result = self._values.get("group_name")
        assert result is not None, "Required property 'group_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def solver_name(self) -> builtins.str:
        '''The name of the solver to use, as defined in the webhook provider implementation.

        This will typically be the name of the provider, e.g. 'cloudflare'.

        :schema: IssuerSpecAcmeSolversDns01Webhook#solverName
        '''
        result = self._values.get("solver_name")
        assert result is not None, "Required property 'solver_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def config(self) -> typing.Any:
        '''Additional configuration that should be passed to the webhook apiserver when challenges are processed.

        This can contain arbitrary JSON data.
        Secret values should not be specified in this stanza.
        If secret values are needed (e.g. credentials for a DNS service), you
        should use a SecretKeySelector to reference a Secret resource.
        For details on the schema of this field, consult the webhook provider
        implementation's documentation.

        :schema: IssuerSpecAcmeSolversDns01Webhook#config
        '''
        result = self._values.get("config")
        return typing.cast(typing.Any, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversDns01Webhook(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01",
    jsii_struct_bases=[],
    name_mapping={"gateway_http_route": "gatewayHttpRoute", "ingress": "ingress"},
)
class IssuerSpecAcmeSolversHttp01:
    def __init__(
        self,
        *,
        gateway_http_route: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoute", typing.Dict[builtins.str, typing.Any]]] = None,
        ingress: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01Ingress", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Configures cert-manager to attempt to complete authorizations by performing the HTTP01 challenge flow.

        It is not possible to obtain certificates for wildcard domain names
        (e.g. ``*.example.com``) using the HTTP01 challenge mechanism.

        :param gateway_http_route: The Gateway API is a sig-network community API that models service networking in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will create HTTPRoutes with the specified labels in the same namespace as the challenge. This solver is experimental, and fields / behaviour may change in the future.
        :param ingress: The ingress based HTTP01 challenge solver will solve challenges by creating or modifying Ingress resources in order to route requests for '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are provisioned by cert-manager for each Challenge to be completed.

        :schema: IssuerSpecAcmeSolversHttp01
        '''
        if isinstance(gateway_http_route, dict):
            gateway_http_route = IssuerSpecAcmeSolversHttp01GatewayHttpRoute(**gateway_http_route)
        if isinstance(ingress, dict):
            ingress = IssuerSpecAcmeSolversHttp01Ingress(**ingress)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3aafb9438fec2fdf63fd881c9e96858264a616864bac7381200e92024347b456)
            check_type(argname="argument gateway_http_route", value=gateway_http_route, expected_type=type_hints["gateway_http_route"])
            check_type(argname="argument ingress", value=ingress, expected_type=type_hints["ingress"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if gateway_http_route is not None:
            self._values["gateway_http_route"] = gateway_http_route
        if ingress is not None:
            self._values["ingress"] = ingress

    @builtins.property
    def gateway_http_route(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoute"]:
        '''The Gateway API is a sig-network community API that models service networking in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will create HTTPRoutes with the specified labels in the same namespace as the challenge. This solver is experimental, and fields / behaviour may change in the future.

        :schema: IssuerSpecAcmeSolversHttp01#gatewayHTTPRoute
        '''
        result = self._values.get("gateway_http_route")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoute"], result)

    @builtins.property
    def ingress(self) -> typing.Optional["IssuerSpecAcmeSolversHttp01Ingress"]:
        '''The ingress based HTTP01 challenge solver will solve challenges by creating or modifying Ingress resources in order to route requests for '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are provisioned by cert-manager for each Challenge to be completed.

        :schema: IssuerSpecAcmeSolversHttp01#ingress
        '''
        result = self._values.get("ingress")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01Ingress"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoute",
    jsii_struct_bases=[],
    name_mapping={
        "labels": "labels",
        "parent_refs": "parentRefs",
        "pod_template": "podTemplate",
        "service_type": "serviceType",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoute:
    def __init__(
        self,
        *,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        parent_refs: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs", typing.Dict[builtins.str, typing.Any]]]] = None,
        pod_template: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate", typing.Dict[builtins.str, typing.Any]]] = None,
        service_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Gateway API is a sig-network community API that models service networking in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will create HTTPRoutes with the specified labels in the same namespace as the challenge. This solver is experimental, and fields / behaviour may change in the future.

        :param labels: Custom labels that will be applied to HTTPRoutes created by cert-manager while solving HTTP-01 challenges.
        :param parent_refs: When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute. cert-manager needs to know which parentRefs should be used when creating the HTTPRoute. Usually, the parentRef references a Gateway. See: https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
        :param pod_template: Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges.
        :param service_type: Optional service type for Kubernetes solver service. Supported values are NodePort or ClusterIP. If unset, defaults to NodePort.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoute
        '''
        if isinstance(pod_template, dict):
            pod_template = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate(**pod_template)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__01c6fa97afc7115093037fa1ee58039db5322745602af262264ec0712d240cb5)
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument parent_refs", value=parent_refs, expected_type=type_hints["parent_refs"])
            check_type(argname="argument pod_template", value=pod_template, expected_type=type_hints["pod_template"])
            check_type(argname="argument service_type", value=service_type, expected_type=type_hints["service_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if labels is not None:
            self._values["labels"] = labels
        if parent_refs is not None:
            self._values["parent_refs"] = parent_refs
        if pod_template is not None:
            self._values["pod_template"] = pod_template
        if service_type is not None:
            self._values["service_type"] = service_type

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Custom labels that will be applied to HTTPRoutes created by cert-manager while solving HTTP-01 challenges.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoute#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def parent_refs(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs"]]:
        '''When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.

        cert-manager needs to know which parentRefs should be used when creating
        the HTTPRoute. Usually, the parentRef references a Gateway. See:
        https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoute#parentRefs
        '''
        result = self._values.get("parent_refs")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs"]], result)

    @builtins.property
    def pod_template(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate"]:
        '''Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoute#podTemplate
        '''
        result = self._values.get("pod_template")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate"], result)

    @builtins.property
    def service_type(self) -> typing.Optional[builtins.str]:
        '''Optional service type for Kubernetes solver service.

        Supported values
        are NodePort or ClusterIP. If unset, defaults to NodePort.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoute#serviceType
        '''
        result = self._values.get("service_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "group": "group",
        "kind": "kind",
        "namespace": "namespace",
        "port": "port",
        "section_name": "sectionName",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs:
    def __init__(
        self,
        *,
        name: builtins.str,
        group: typing.Optional[builtins.str] = None,
        kind: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
        port: typing.Optional[jsii.Number] = None,
        section_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route).

        There are two kinds of parent resources
        with "Core" support:

        - Gateway (Gateway conformance profile)
        - Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.

        :param name: Name is the name of the referent. Support: Core
        :param group: Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string). Support: Core
        :param kind: Kind is kind of the referent. There are two kinds of parent resources with "Core" support: - Gateway (Gateway conformance profile) - Service (Mesh conformance profile, ClusterIP Services only) Support for other resources is Implementation-Specific.
        :param namespace: Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route. Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference. `gateway:experimental:description <gateway:experimental:description>`_ ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service. ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route. </gateway:experimental:description> Support: Core
        :param port: Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource. When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set ``Port`` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values. `gateway:experimental:description <gateway:experimental:description>`_ When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values. </gateway:experimental:description> Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted. For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. Support: Extended
        :param section_name: SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following: - Gateway: Listener name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. - Service: Port name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted. When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. Support: Core

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4605df1924b14afa961f4b7013e4f8015f77f1b5fbb0deaa3998ffac25fbfd28)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument group", value=group, expected_type=type_hints["group"])
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument section_name", value=section_name, expected_type=type_hints["section_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if group is not None:
            self._values["group"] = group
        if kind is not None:
            self._values["kind"] = kind
        if namespace is not None:
            self._values["namespace"] = namespace
        if port is not None:
            self._values["port"] = port
        if section_name is not None:
            self._values["section_name"] = section_name

    @builtins.property
    def name(self) -> builtins.str:
        '''Name is the name of the referent.

        Support: Core

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group(self) -> typing.Optional[builtins.str]:
        '''Group is the group of the referent.

        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#group
        '''
        result = self._values.get("group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        '''Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        - Gateway (Gateway conformance profile)
        - Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.

        `gateway:experimental:description <gateway:experimental:description>`_
        ParentRefs from a Route to a Service in the same namespace are "producer"
        routes, which apply default routing rules to inbound connections from
        any namespace to the Service.

        ParentRefs from a Route to a Service in a different namespace are
        "consumer" routes, and these routing rules are only applied to outbound
        connections originating from the same namespace as the Route, for which
        the intended destination of the connections are a Service targeted as a
        ParentRef of the Route.
        </gateway:experimental:description>

        Support: Core

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set ``Port`` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.

        `gateway:experimental:description <gateway:experimental:description>`_
        When the parent resource is a Service, this targets a specific port in the
        Service spec. When both Port (experimental) and SectionName are specified,
        the name and port of the selected port must match both specified values.
        </gateway:experimental:description>

        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#port
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def section_name(self) -> typing.Optional[builtins.str]:
        '''SectionName is the name of a section within the target resource.

        In the
        following resources, SectionName is interpreted as the following:

        - Gateway: Listener name. When both Port (experimental) and SectionName
          are specified, the name and port of the selected listener must match
          both specified values.
        - Service: Port name. When both Port (experimental) and SectionName
          are specified, the name and port of the selected listener must match
          both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs#sectionName
        '''
        result = self._values.get("section_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata", typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges.

        :param metadata: ObjectMeta overrides for the pod used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
        :param spec: PodSpec defines overrides for the HTTP01 challenge solver pod. Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields. All other fields will be ignored.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate
        '''
        if isinstance(metadata, dict):
            metadata = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata(**metadata)
        if isinstance(spec, dict):
            spec = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec(**spec)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fc37a43be420c152ee18fecd16af838853044711792db026fbbbcec28575dbf7)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata"]:
        '''ObjectMeta overrides for the pod used to solve HTTP01 challenges.

        Only the 'labels' and 'annotations' fields may be set.
        If labels or annotations overlap with in-built values, the values here
        will override the in-built values.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata"], result)

    @builtins.property
    def spec(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec"]:
        '''PodSpec defines overrides for the HTTP01 challenge solver pod.

        Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
        All other fields will be ignored.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={"annotations": "annotations", "labels": "labels"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''ObjectMeta overrides for the pod used to solve HTTP01 challenges.

        Only the 'labels' and 'annotations' fields may be set.
        If labels or annotations overlap with in-built values, the values here
        will override the in-built values.

        :param annotations: Annotations that should be added to the created ACME HTTP01 solver pods.
        :param labels: Labels that should be added to the created ACME HTTP01 solver pods.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cc9f7ec2da345065af36a17748de295da93d476c83fb0d25aef20dbf77496bce)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Annotations that should be added to the created ACME HTTP01 solver pods.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Labels that should be added to the created ACME HTTP01 solver pods.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec",
    jsii_struct_bases=[],
    name_mapping={
        "affinity": "affinity",
        "image_pull_secrets": "imagePullSecrets",
        "node_selector": "nodeSelector",
        "priority_class_name": "priorityClassName",
        "security_context": "securityContext",
        "service_account_name": "serviceAccountName",
        "tolerations": "tolerations",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec:
    def __init__(
        self,
        *,
        affinity: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
        image_pull_secrets: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets", typing.Dict[builtins.str, typing.Any]]]] = None,
        node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        priority_class_name: typing.Optional[builtins.str] = None,
        security_context: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        tolerations: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''PodSpec defines overrides for the HTTP01 challenge solver pod.

        Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
        All other fields will be ignored.

        :param affinity: If specified, the pod's scheduling constraints.
        :param image_pull_secrets: If specified, the pod's imagePullSecrets.
        :param node_selector: NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
        :param priority_class_name: If specified, the pod's priorityClassName.
        :param security_context: If specified, the pod's security context.
        :param service_account_name: If specified, the pod's service account.
        :param tolerations: If specified, the pod's tolerations.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec
        '''
        if isinstance(affinity, dict):
            affinity = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity(**affinity)
        if isinstance(security_context, dict):
            security_context = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext(**security_context)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2cfaafd225eb29c244bb16061edf044aaa795312361c5abf24090484faf198f6)
            check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
            check_type(argname="argument image_pull_secrets", value=image_pull_secrets, expected_type=type_hints["image_pull_secrets"])
            check_type(argname="argument node_selector", value=node_selector, expected_type=type_hints["node_selector"])
            check_type(argname="argument priority_class_name", value=priority_class_name, expected_type=type_hints["priority_class_name"])
            check_type(argname="argument security_context", value=security_context, expected_type=type_hints["security_context"])
            check_type(argname="argument service_account_name", value=service_account_name, expected_type=type_hints["service_account_name"])
            check_type(argname="argument tolerations", value=tolerations, expected_type=type_hints["tolerations"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if affinity is not None:
            self._values["affinity"] = affinity
        if image_pull_secrets is not None:
            self._values["image_pull_secrets"] = image_pull_secrets
        if node_selector is not None:
            self._values["node_selector"] = node_selector
        if priority_class_name is not None:
            self._values["priority_class_name"] = priority_class_name
        if security_context is not None:
            self._values["security_context"] = security_context
        if service_account_name is not None:
            self._values["service_account_name"] = service_account_name
        if tolerations is not None:
            self._values["tolerations"] = tolerations

    @builtins.property
    def affinity(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity"]:
        '''If specified, the pod's scheduling constraints.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#affinity
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity"], result)

    @builtins.property
    def image_pull_secrets(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets"]]:
        '''If specified, the pod's imagePullSecrets.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#imagePullSecrets
        '''
        result = self._values.get("image_pull_secrets")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets"]], result)

    @builtins.property
    def node_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''NodeSelector is a selector which must be true for the pod to fit on a node.

        Selector which must match a node's labels for the pod to be scheduled on that node.
        More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#nodeSelector
        '''
        result = self._values.get("node_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def priority_class_name(self) -> typing.Optional[builtins.str]:
        '''If specified, the pod's priorityClassName.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#priorityClassName
        '''
        result = self._values.get("priority_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_context(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext"]:
        '''If specified, the pod's security context.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#securityContext
        '''
        result = self._values.get("security_context")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext"], result)

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        '''If specified, the pod's service account.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#serviceAccountName
        '''
        result = self._values.get("service_account_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tolerations(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations"]]:
        '''If specified, the pod's tolerations.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec#tolerations
        '''
        result = self._values.get("tolerations")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "node_affinity": "nodeAffinity",
        "pod_affinity": "podAffinity",
        "pod_anti_affinity": "podAntiAffinity",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity:
    def __init__(
        self,
        *,
        node_affinity: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_affinity: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_anti_affinity: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''If specified, the pod's scheduling constraints.

        :param node_affinity: Describes node affinity scheduling rules for the pod.
        :param pod_affinity: Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
        :param pod_anti_affinity: Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity
        '''
        if isinstance(node_affinity, dict):
            node_affinity = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity(**node_affinity)
        if isinstance(pod_affinity, dict):
            pod_affinity = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity(**pod_affinity)
        if isinstance(pod_anti_affinity, dict):
            pod_anti_affinity = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity(**pod_anti_affinity)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e960e38cf4fcb20355989b6b48d85c68326dfabdedd9920ae952b328f7933d4)
            check_type(argname="argument node_affinity", value=node_affinity, expected_type=type_hints["node_affinity"])
            check_type(argname="argument pod_affinity", value=pod_affinity, expected_type=type_hints["pod_affinity"])
            check_type(argname="argument pod_anti_affinity", value=pod_anti_affinity, expected_type=type_hints["pod_anti_affinity"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if node_affinity is not None:
            self._values["node_affinity"] = node_affinity
        if pod_affinity is not None:
            self._values["pod_affinity"] = pod_affinity
        if pod_anti_affinity is not None:
            self._values["pod_anti_affinity"] = pod_anti_affinity

    @builtins.property
    def node_affinity(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity"]:
        '''Describes node affinity scheduling rules for the pod.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity#nodeAffinity
        '''
        result = self._values.get("node_affinity")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity"], result)

    @builtins.property
    def pod_affinity(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity"]:
        '''Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity#podAffinity
        '''
        result = self._values.get("pod_affinity")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity"], result)

    @builtins.property
    def pod_anti_affinity(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity"]:
        '''Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity#podAntiAffinity
        '''
        result = self._values.get("pod_anti_affinity")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Describes node affinity scheduling rules for the pod.

        :param preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
        :param required_during_scheduling_ignored_during_execution: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity
        '''
        if isinstance(required_during_scheduling_ignored_during_execution, dict):
            required_during_scheduling_ignored_during_execution = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(**required_during_scheduling_ignored_during_execution)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e5d71b50d85cf749ebde0354afed9c5a74a5e818dfc4731923f6b2bbddcbf21)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.

        The node that is
        most preferred is the one with the greatest sum of weights, i.e.
        for each node that meets all of the scheduling requirements (resource
        request, requiredDuringScheduling affinity expressions, etc.),
        compute a sum by iterating through the elements of this field and adding
        "weight" to the sum if the node matches the corresponding matchExpressions; the
        node(s) with the highest sum are the most preferred.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"]:
        '''If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the affinity requirements specified by this field cease to be met
        at some point during pod execution (e.g. due to an update), the system
        may or may not try to eventually evict the pod from its node.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"preference": "preference", "weight": "weight"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        preference: typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", typing.Dict[builtins.str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).

        :param preference: A node selector term, associated with the corresponding weight.
        :param weight: Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(preference, dict):
            preference = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(**preference)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a10e2bf918d041c428d585692b846f49427fb9b697058e18942918167f710514)
            check_type(argname="argument preference", value=preference, expected_type=type_hints["preference"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "preference": preference,
            "weight": weight,
        }

    @builtins.property
    def preference(
        self,
    ) -> "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference":
        '''A node selector term, associated with the corresponding weight.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
        '''
        result = self._values.get("preference")
        assert result is not None, "Required property 'preference' is missing"
        return typing.cast("IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''A node selector term, associated with the corresponding weight.

        :param match_expressions: A list of node selector requirements by node's labels.
        :param match_fields: A list of node selector requirements by node's fields.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__67c632b0becb9c79bba61ecfbc570059ecbea112da7847bb2e85fafed527b0b4)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]]:
        '''A list of node selector requirements by node's labels.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]]:
        '''A list of node selector requirements by node's fields.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c8bba19691eef4fe04b976862d70cf9286fd400f66cbb75a1bbc36ec1307f548)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''The label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''Represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. If the operator is Gt or Lt, the values
        array must have a single element, which will be interpreted as an integer.
        This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17ce6b4ca22f0732a72196cd678d291197212b16f005c8aa2f40709a1a296980)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''The label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''Represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. If the operator is Gt or Lt, the values
        array must have a single element, which will be interpreted as an integer.
        This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"node_selector_terms": "nodeSelectorTerms"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        node_selector_terms: typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms", typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the affinity requirements specified by this field cease to be met
        at some point during pod execution (e.g. due to an update), the system
        may or may not try to eventually evict the pod from its node.

        :param node_selector_terms: Required. A list of node selector terms. The terms are ORed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d3daeac4fbf2c77cf223aad1483b2f0c7b039ae2879d04428cecca37312860ee)
            check_type(argname="argument node_selector_terms", value=node_selector_terms, expected_type=type_hints["node_selector_terms"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "node_selector_terms": node_selector_terms,
        }

    @builtins.property
    def node_selector_terms(
        self,
    ) -> typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"]:
        '''Required.

        A list of node selector terms. The terms are ORed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
        '''
        result = self._values.get("node_selector_terms")
        assert result is not None, "Required property 'node_selector_terms' is missing"
        return typing.cast(typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''A null or empty node selector term matches no objects.

        The requirements of
        them are ANDed.
        The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.

        :param match_expressions: A list of node selector requirements by node's labels.
        :param match_fields: A list of node selector requirements by node's fields.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eebf5fa09c1d6515e17b55681c10ac7af9b185398f26515ab31ce84956fc782a)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]]:
        '''A list of node selector requirements by node's labels.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]]:
        '''A list of node selector requirements by node's fields.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b71c8fca97cf32ccffe4bee872ebdb151872f7407ac0ab01c760ff68d8d5a3c9)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''The label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''Represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. If the operator is Gt or Lt, the values
        array must have a single element, which will be interpreted as an integer.
        This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e2109e48c4e35740a563e4d634894a210aec88aa3fa11feb3782fbf66e8b946)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''The label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''Represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. If the operator is Gt or Lt, the values
        array must have a single element, which will be interpreted as an integer.
        This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).

        :param preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        :param required_during_scheduling_ignored_during_execution: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__770b9cae483b068dd658c393f9fda9eec646118479117ea31c83b90a8a1b7afa)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.

        The node that is
        most preferred is the one with the greatest sum of weights, i.e.
        for each node that meets all of the scheduling requirements (resource
        request, requiredDuringScheduling affinity expressions, etc.),
        compute a sum by iterating through the elements of this field and adding
        "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
        node(s) with the highest sum are the most preferred.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the affinity requirements specified by this field cease to be met
        at some point during pod execution (e.g. due to a pod label update), the
        system may or may not try to eventually evict the pod from its node.
        When there are multiple elements, the lists of nodes corresponding to each
        podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[builtins.str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s).

        :param pod_affinity_term: Required. A pod affinity term, associated with the corresponding weight.
        :param weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f570b94e4651013c7429fbf6f83f4657638d552f87e6957d93b944a49a657bdb)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''Required.

        A pod affinity term, associated with the corresponding weight.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "match_label_keys": "matchLabelKeys",
        "mismatch_label_keys": "mismatchLabelKeys",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Required.

        A pod affinity term, associated with the corresponding weight.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
        :param match_label_keys: MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param mismatch_label_keys: MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
        :param namespace_selector: A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__337c0e937692229cc452a0811b0ae2e48d3fef58d8c073f01ca63ec43d9cbadb)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument match_label_keys", value=match_label_keys, expected_type=type_hints["match_label_keys"])
            check_type(argname="argument mismatch_label_keys", value=mismatch_label_keys, expected_type=type_hints["mismatch_label_keys"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if match_label_keys is not None:
            self._values["match_label_keys"] = match_label_keys
        if mismatch_label_keys is not None:
            self._values["mismatch_label_keys"] = mismatch_label_keys
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def match_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both matchLabelKeys and labelSelector.
        Also, matchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
        '''
        result = self._values.get("match_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def mismatch_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
        Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
        '''
        result = self._values.get("mismatch_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field
        and the ones selected by namespaceSelector.
        null or empty namespaces list and null namespaceSelector means "this pod's namespace".

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"]:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e70680078810df8710ec769a369901e5e0a043064e2722dbe492a2ccbad5591f)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a478e4cb9e1f8a5b4cb181e35d5dcafb3167a6b9d7a3f16ae5ee66d5939d72ae)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba68be71f7cef1afdb63d699ee545de522dceae354901e85d16a7508fddcde2a)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b8c1b13e4bb69f0d3f7b9147f8693505cc43c2b749cda54d058918c6a8d7b84)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "match_label_keys": "matchLabelKeys",
        "mismatch_label_keys": "mismatchLabelKeys",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key  matches that of any node on which a pod of the set of pods is running.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
        :param match_label_keys: MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param mismatch_label_keys: MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
        :param namespace_selector: A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0cd68ebb7582795497068a0edc1d89f6b23edc034c8884663407b6c598e48205)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument match_label_keys", value=match_label_keys, expected_type=type_hints["match_label_keys"])
            check_type(argname="argument mismatch_label_keys", value=mismatch_label_keys, expected_type=type_hints["mismatch_label_keys"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if match_label_keys is not None:
            self._values["match_label_keys"] = match_label_keys
        if mismatch_label_keys is not None:
            self._values["mismatch_label_keys"] = mismatch_label_keys
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def match_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both matchLabelKeys and labelSelector.
        Also, matchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
        '''
        result = self._values.get("match_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def mismatch_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
        Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
        '''
        result = self._values.get("mismatch_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field
        and the ones selected by namespaceSelector.
        null or empty namespaces list and null namespaceSelector means "this pod's namespace".

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"]:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89fcbac0be98710fa0c3f781c16c055b257bd693d8634ef837ebdeb6e1e95625)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89be4f03c001ab0482380abb7f039851f9fab7eafc3e8ba5c4527bbc283df5e0)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83799ea4463e2670a760452a981931cc89a5b0a5fcb4d5e350eaec2cf6185fd3)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7144207226f5a38152eedda15aaf4c28de4fa2729ff1d3190a30aafe86c60603)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).

        :param preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        :param required_during_scheduling_ignored_during_execution: If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f02a0c283445d718912f837ac3954a8a966d4078af1db24959268248206cdc60)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.

        The node that is
        most preferred is the one with the greatest sum of weights, i.e.
        for each node that meets all of the scheduling requirements (resource
        request, requiredDuringScheduling anti-affinity expressions, etc.),
        compute a sum by iterating through the elements of this field and adding
        "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
        node(s) with the highest sum are the most preferred.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the anti-affinity requirements specified by this field cease to be met
        at some point during pod execution (e.g. due to a pod label update), the
        system may or may not try to eventually evict the pod from its node.
        When there are multiple elements, the lists of nodes corresponding to each
        podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[builtins.str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s).

        :param pod_affinity_term: Required. A pod affinity term, associated with the corresponding weight.
        :param weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__78ef0c9f2a1966bb53502b4ea71f99488e276142557cd3155d878cd285055a0a)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''Required.

        A pod affinity term, associated with the corresponding weight.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "match_label_keys": "matchLabelKeys",
        "mismatch_label_keys": "mismatchLabelKeys",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Required.

        A pod affinity term, associated with the corresponding weight.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
        :param match_label_keys: MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param mismatch_label_keys: MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
        :param namespace_selector: A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5ef970f8ad3e2f56fba1dcfa005212c4e0df48f898fa68ce72b3eb7210bdb0d3)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument match_label_keys", value=match_label_keys, expected_type=type_hints["match_label_keys"])
            check_type(argname="argument mismatch_label_keys", value=mismatch_label_keys, expected_type=type_hints["mismatch_label_keys"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if match_label_keys is not None:
            self._values["match_label_keys"] = match_label_keys
        if mismatch_label_keys is not None:
            self._values["mismatch_label_keys"] = mismatch_label_keys
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def match_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both matchLabelKeys and labelSelector.
        Also, matchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
        '''
        result = self._values.get("match_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def mismatch_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
        Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
        '''
        result = self._values.get("mismatch_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field
        and the ones selected by namespaceSelector.
        null or empty namespaces list and null namespaceSelector means "this pod's namespace".

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"]:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e0a509c934a90a81037c11bdbd8ca13dd05f4d2560184496d80313177ba60574)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2bfe7cadf921a874d8551b11c295c6e1d9035b49bfd5e54497d1985cf269d25b)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d88840345bf5db559bc4af67bf5163dfc832a4563a8634c9b0e0db1be0dd1fc8)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b26a159425ef812abe43e3fa8cfc6782e66fc017171fdbd9727261e9d0b2bb1)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "match_label_keys": "matchLabelKeys",
        "mismatch_label_keys": "mismatchLabelKeys",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key  matches that of any node on which a pod of the set of pods is running.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
        :param match_label_keys: MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param mismatch_label_keys: MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
        :param namespace_selector: A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ac82888f0deddbab109280901a8560fdf93f5f101b6e9d94ffeb1a1b6c58f4ea)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument match_label_keys", value=match_label_keys, expected_type=type_hints["match_label_keys"])
            check_type(argname="argument mismatch_label_keys", value=mismatch_label_keys, expected_type=type_hints["mismatch_label_keys"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if match_label_keys is not None:
            self._values["match_label_keys"] = match_label_keys
        if mismatch_label_keys is not None:
            self._values["mismatch_label_keys"] = mismatch_label_keys
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def match_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both matchLabelKeys and labelSelector.
        Also, matchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
        '''
        result = self._values.get("match_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def mismatch_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
        Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
        '''
        result = self._values.get("mismatch_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field
        and the ones selected by namespaceSelector.
        null or empty namespaces list and null namespaceSelector means "this pod's namespace".

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"]:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ca6914256214683d6f199cb251317bf30f6f3ee7d0e9c81952dfa1d3f2580940)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__db0277363bea6e7223ec8a00ded448916d2821ea4fa63a78ff2267f6a8ce5d7b)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70c6e83e10f8a9dded493f32ed0b17edc045fd208cf557d57db7d00385940a2b)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b6848113fe16fc047aaa2031d880ff52c39d86601eb136569426588e46a96a29)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.

        :param name: Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f622a233e53fa8f1cc049cd22298edf3d6f14f8d777762bb784142de294b496d)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the referent.

        This field is effectively required, but due to backwards compatibility is
        allowed to be empty. Instances of this type with an empty value here are
        almost certainly wrong.
        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "fs_group": "fsGroup",
        "fs_group_change_policy": "fsGroupChangePolicy",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "supplemental_groups": "supplementalGroups",
        "sysctls": "sysctls",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext:
    def __init__(
        self,
        *,
        fs_group: typing.Optional[jsii.Number] = None,
        fs_group_change_policy: typing.Optional[builtins.str] = None,
        run_as_group: typing.Optional[jsii.Number] = None,
        run_as_non_root: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
        seccomp_profile: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile", typing.Dict[builtins.str, typing.Any]]] = None,
        se_linux_options: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions", typing.Dict[builtins.str, typing.Any]]] = None,
        supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
        sysctls: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''If specified, the pod's security context.

        :param fs_group: A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
        :param fs_group_change_policy: fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
        :param run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
        :param run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows. Default: user specified in image metadata if unspecified.
        :param seccomp_profile: The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        :param se_linux_options: The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
        :param supplemental_groups: A list of groups applied to the first process run in each container, in addition to the container's primary GID, the fsGroup (if specified), and group memberships defined in the container image for the uid of the container process. If unspecified, no additional groups are added to any container. Note that group memberships defined in the container image for the uid of the container process are still effective, even if they are not included in this list. Note that this field cannot be set when spec.os.name is windows.
        :param sysctls: Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext
        '''
        if isinstance(seccomp_profile, dict):
            seccomp_profile = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile(**seccomp_profile)
        if isinstance(se_linux_options, dict):
            se_linux_options = IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions(**se_linux_options)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aa7f661a14acca333c27d1c3e4ea87e43099b300a285ad8669ccf3ae445f7a1a)
            check_type(argname="argument fs_group", value=fs_group, expected_type=type_hints["fs_group"])
            check_type(argname="argument fs_group_change_policy", value=fs_group_change_policy, expected_type=type_hints["fs_group_change_policy"])
            check_type(argname="argument run_as_group", value=run_as_group, expected_type=type_hints["run_as_group"])
            check_type(argname="argument run_as_non_root", value=run_as_non_root, expected_type=type_hints["run_as_non_root"])
            check_type(argname="argument run_as_user", value=run_as_user, expected_type=type_hints["run_as_user"])
            check_type(argname="argument seccomp_profile", value=seccomp_profile, expected_type=type_hints["seccomp_profile"])
            check_type(argname="argument se_linux_options", value=se_linux_options, expected_type=type_hints["se_linux_options"])
            check_type(argname="argument supplemental_groups", value=supplemental_groups, expected_type=type_hints["supplemental_groups"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if fs_group is not None:
            self._values["fs_group"] = fs_group
        if fs_group_change_policy is not None:
            self._values["fs_group_change_policy"] = fs_group_change_policy
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if supplemental_groups is not None:
            self._values["supplemental_groups"] = supplemental_groups
        if sysctls is not None:
            self._values["sysctls"] = sysctls

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''A special supplemental group that applies to all containers in a pod.

        Some volume types allow the Kubelet to change the ownership of that volume
        to be owned by the pod:

        1. The owning GID will be the FSGroup
        2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
        3. The permission bits are OR'd with rw-rw----

        If unset, the Kubelet will not modify the ownership and permissions of any volume.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#fsGroup
        '''
        result = self._values.get("fs_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_group_change_policy(self) -> typing.Optional[builtins.str]:
        '''fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod.

        This field will only apply to
        volume types which support fsGroup based ownership(and permissions).
        It will have no effect on ephemeral volume types such as: secret, configmaps
        and emptydir.
        Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#fsGroupChangePolicy
        '''
        result = self._values.get("fs_group_change_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[jsii.Number]:
        '''The GID to run the entrypoint of the container process.

        Uses runtime default if unset.
        May also be set in SecurityContext.  If set in both SecurityContext and
        PodSecurityContext, the value specified in SecurityContext takes precedence
        for that container.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#runAsGroup
        '''
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def run_as_non_root(self) -> typing.Optional[builtins.bool]:
        '''Indicates that the container must run as a non-root user.

        If true, the Kubelet will validate the image at runtime to ensure that it
        does not run as UID 0 (root) and fail to start the container if it does.
        If unset or false, no such validation will be performed.
        May also be set in SecurityContext.  If set in both SecurityContext and
        PodSecurityContext, the value specified in SecurityContext takes precedence.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#runAsNonRoot
        '''
        result = self._values.get("run_as_non_root")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''The UID to run the entrypoint of the container process.

        Defaults to user specified in image metadata if unspecified.
        May also be set in SecurityContext.  If set in both SecurityContext and
        PodSecurityContext, the value specified in SecurityContext takes precedence
        for that container.
        Note that this field cannot be set when spec.os.name is windows.

        :default: user specified in image metadata if unspecified.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#runAsUser
        '''
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile"]:
        '''The seccomp options to use by the containers in this pod.

        Note that this field cannot be set when spec.os.name is windows.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#seccompProfile
        '''
        result = self._values.get("seccomp_profile")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile"], result)

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions"]:
        '''The SELinux context to be applied to all containers.

        If unspecified, the container runtime will allocate a random SELinux context for each
        container.  May also be set in SecurityContext.  If set in
        both SecurityContext and PodSecurityContext, the value specified in SecurityContext
        takes precedence for that container.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#seLinuxOptions
        '''
        result = self._values.get("se_linux_options")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions"], result)

    @builtins.property
    def supplemental_groups(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''A list of groups applied to the first process run in each container, in addition to the container's primary GID, the fsGroup (if specified), and group memberships defined in the container image for the uid of the container process.

        If unspecified,
        no additional groups are added to any container. Note that group memberships
        defined in the container image for the uid of the container process are still effective,
        even if they are not included in this list.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#supplementalGroups
        '''
        result = self._values.get("supplemental_groups")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def sysctls(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls"]]:
        '''Sysctls hold a list of namespaced sysctls used for the pod.

        Pods with unsupported
        sysctls (by the container runtime) might fail to launch.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext#sysctls
        '''
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SELinux context to be applied to all containers.

        If unspecified, the container runtime will allocate a random SELinux context for each
        container.  May also be set in SecurityContext.  If set in
        both SecurityContext and PodSecurityContext, the value specified in SecurityContext
        takes precedence for that container.
        Note that this field cannot be set when spec.os.name is windows.

        :param level: Level is SELinux level label that applies to the container.
        :param role: Role is a SELinux role label that applies to the container.
        :param type: Type is a SELinux type label that applies to the container.
        :param user: User is a SELinux user label that applies to the container.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__428282459b1965936e325d87d613511ccd46bc7fd6b4be416e2e9383bfe042e2)
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        '''Level is SELinux level label that applies to the container.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions#level
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a SELinux role label that applies to the container.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''Type is a SELinux type label that applies to the container.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''User is a SELinux user label that applies to the container.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "localhost_profile": "localhostProfile"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        type: builtins.str,
        localhost_profile: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The seccomp options to use by the containers in this pod.

        Note that this field cannot be set when spec.os.name is windows.

        :param type: type indicates which kind of seccomp profile will be applied. Valid options are:. Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
        :param localhost_profile: localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any other type.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64d4c232613257f7aa3d850797d74e26bc06d264f03bd88be4d46c7a6e2e63b8)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument localhost_profile", value=localhost_profile, expected_type=type_hints["localhost_profile"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "type": type,
        }
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile

    @builtins.property
    def type(self) -> builtins.str:
        '''type indicates which kind of seccomp profile will be applied. Valid options are:.

        Localhost - a profile defined in a file on the node should be used.
        RuntimeDefault - the container runtime default profile should be used.
        Unconfined - no profile should be applied.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        '''localhostProfile indicates a profile defined in a file on the node should be used.

        The profile must be preconfigured on the node to work.
        Must be a descending path, relative to the kubelet's configured seccomp profile location.
        Must be set if type is "Localhost". Must NOT be set for any other type.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile#localhostProfile
        '''
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''Sysctl defines a kernel parameter to be set.

        :param name: Name of a property to set.
        :param value: Value of a property to set.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__703b1bbc01eab508106a514983ca9aa86fceda87af19f075116936a4e5b4c3bf)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of a property to set.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''Value of a property to set.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations",
    jsii_struct_bases=[],
    name_mapping={
        "effect": "effect",
        "key": "key",
        "operator": "operator",
        "toleration_seconds": "tolerationSeconds",
        "value": "value",
    },
)
class IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations:
    def __init__(
        self,
        *,
        effect: typing.Optional[builtins.str] = None,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        toleration_seconds: typing.Optional[jsii.Number] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator .

        :param effect: Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        :param key: Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        :param operator: Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category. Default: Equal.
        :param toleration_seconds: TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        :param value: Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__417cd8c23c9d09b13441d7b1aef943afd9a77adbb0292592f9560ac7d71f880b)
            check_type(argname="argument effect", value=effect, expected_type=type_hints["effect"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument toleration_seconds", value=toleration_seconds, expected_type=type_hints["toleration_seconds"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if effect is not None:
            self._values["effect"] = effect
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if toleration_seconds is not None:
            self._values["toleration_seconds"] = toleration_seconds
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def effect(self) -> typing.Optional[builtins.str]:
        '''Effect indicates the taint effect to match.

        Empty means match all taint effects.
        When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations#effect
        '''
        result = self._values.get("effect")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''Key is the taint key that the toleration applies to.

        Empty means match all taint keys.
        If the key is empty, operator must be Exists; this combination means to match all values and all keys.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''Operator represents a key's relationship to the value.

        Valid operators are Exists and Equal. Defaults to Equal.
        Exists is equivalent to wildcard for value, so that a pod can
        tolerate all taints of a particular category.

        :default: Equal.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations#operator
        '''
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def toleration_seconds(self) -> typing.Optional[jsii.Number]:
        '''TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.

        By default,
        it is not set, which means tolerate the taint forever (do not evict). Zero and
        negative values will be treated as 0 (evict immediately) by the system.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations#tolerationSeconds
        '''
        result = self._values.get("toleration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value is the taint value the toleration matches to.

        If the operator is Exists, the value should be empty, otherwise just a regular string.

        :schema: IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01Ingress",
    jsii_struct_bases=[],
    name_mapping={
        "class_": "class",
        "ingress_class_name": "ingressClassName",
        "ingress_template": "ingressTemplate",
        "name": "name",
        "pod_template": "podTemplate",
        "service_type": "serviceType",
    },
)
class IssuerSpecAcmeSolversHttp01Ingress:
    def __init__(
        self,
        *,
        class_: typing.Optional[builtins.str] = None,
        ingress_class_name: typing.Optional[builtins.str] = None,
        ingress_template: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressIngressTemplate", typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        pod_template: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplate", typing.Dict[builtins.str, typing.Any]]] = None,
        service_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The ingress based HTTP01 challenge solver will solve challenges by creating or modifying Ingress resources in order to route requests for '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are provisioned by cert-manager for each Challenge to be completed.

        :param class_: This field configures the annotation ``kubernetes.io/ingress.class`` when creating Ingress resources to solve ACME challenges that use this challenge solver. Only one of ``class``, ``name`` or ``ingressClassName`` may be specified.
        :param ingress_class_name: This field configures the field ``ingressClassName`` on the created Ingress resources used to solve ACME challenges that use this challenge solver. This is the recommended way of configuring the ingress class. Only one of ``class``, ``name`` or ``ingressClassName`` may be specified.
        :param ingress_template: Optional ingress template used to configure the ACME challenge solver ingress used for HTTP01 challenges.
        :param name: The name of the ingress resource that should have ACME challenge solving routes inserted into it in order to solve HTTP01 challenges. This is typically used in conjunction with ingress controllers like ingress-gce, which maintains a 1:1 mapping between external IPs and ingress resources. Only one of ``class``, ``name`` or ``ingressClassName`` may be specified.
        :param pod_template: Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges.
        :param service_type: Optional service type for Kubernetes solver service. Supported values are NodePort or ClusterIP. If unset, defaults to NodePort.

        :schema: IssuerSpecAcmeSolversHttp01Ingress
        '''
        if isinstance(ingress_template, dict):
            ingress_template = IssuerSpecAcmeSolversHttp01IngressIngressTemplate(**ingress_template)
        if isinstance(pod_template, dict):
            pod_template = IssuerSpecAcmeSolversHttp01IngressPodTemplate(**pod_template)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__182b4c45bace3813bc89a9a939c8dca360a8d6df22b0013c80b17b19440ea692)
            check_type(argname="argument class_", value=class_, expected_type=type_hints["class_"])
            check_type(argname="argument ingress_class_name", value=ingress_class_name, expected_type=type_hints["ingress_class_name"])
            check_type(argname="argument ingress_template", value=ingress_template, expected_type=type_hints["ingress_template"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument pod_template", value=pod_template, expected_type=type_hints["pod_template"])
            check_type(argname="argument service_type", value=service_type, expected_type=type_hints["service_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if class_ is not None:
            self._values["class_"] = class_
        if ingress_class_name is not None:
            self._values["ingress_class_name"] = ingress_class_name
        if ingress_template is not None:
            self._values["ingress_template"] = ingress_template
        if name is not None:
            self._values["name"] = name
        if pod_template is not None:
            self._values["pod_template"] = pod_template
        if service_type is not None:
            self._values["service_type"] = service_type

    @builtins.property
    def class_(self) -> typing.Optional[builtins.str]:
        '''This field configures the annotation ``kubernetes.io/ingress.class`` when creating Ingress resources to solve ACME challenges that use this challenge solver. Only one of ``class``, ``name`` or ``ingressClassName`` may be specified.

        :schema: IssuerSpecAcmeSolversHttp01Ingress#class
        '''
        result = self._values.get("class_")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ingress_class_name(self) -> typing.Optional[builtins.str]:
        '''This field configures the field ``ingressClassName`` on the created Ingress resources used to solve ACME challenges that use this challenge solver.

        This is the recommended way of configuring the ingress class. Only one of
        ``class``, ``name`` or ``ingressClassName`` may be specified.

        :schema: IssuerSpecAcmeSolversHttp01Ingress#ingressClassName
        '''
        result = self._values.get("ingress_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ingress_template(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressIngressTemplate"]:
        '''Optional ingress template used to configure the ACME challenge solver ingress used for HTTP01 challenges.

        :schema: IssuerSpecAcmeSolversHttp01Ingress#ingressTemplate
        '''
        result = self._values.get("ingress_template")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressIngressTemplate"], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the ingress resource that should have ACME challenge solving routes inserted into it in order to solve HTTP01 challenges.

        This is typically used in conjunction with ingress controllers like
        ingress-gce, which maintains a 1:1 mapping between external IPs and
        ingress resources. Only one of ``class``, ``name`` or ``ingressClassName`` may
        be specified.

        :schema: IssuerSpecAcmeSolversHttp01Ingress#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pod_template(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplate"]:
        '''Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges.

        :schema: IssuerSpecAcmeSolversHttp01Ingress#podTemplate
        '''
        result = self._values.get("pod_template")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplate"], result)

    @builtins.property
    def service_type(self) -> typing.Optional[builtins.str]:
        '''Optional service type for Kubernetes solver service.

        Supported values
        are NodePort or ClusterIP. If unset, defaults to NodePort.

        :schema: IssuerSpecAcmeSolversHttp01Ingress#serviceType
        '''
        result = self._values.get("service_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01Ingress(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressIngressTemplate",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata"},
)
class IssuerSpecAcmeSolversHttp01IngressIngressTemplate:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Optional ingress template used to configure the ACME challenge solver ingress used for HTTP01 challenges.

        :param metadata: ObjectMeta overrides for the ingress used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.

        :schema: IssuerSpecAcmeSolversHttp01IngressIngressTemplate
        '''
        if isinstance(metadata, dict):
            metadata = IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata(**metadata)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af88e7045a3b2900d709e578c968ec044124b57238357736fa199737ed700056)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata"]:
        '''ObjectMeta overrides for the ingress used to solve HTTP01 challenges.

        Only the 'labels' and 'annotations' fields may be set.
        If labels or annotations overlap with in-built values, the values here
        will override the in-built values.

        :schema: IssuerSpecAcmeSolversHttp01IngressIngressTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressIngressTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={"annotations": "annotations", "labels": "labels"},
)
class IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''ObjectMeta overrides for the ingress used to solve HTTP01 challenges.

        Only the 'labels' and 'annotations' fields may be set.
        If labels or annotations overlap with in-built values, the values here
        will override the in-built values.

        :param annotations: Annotations that should be added to the created ACME HTTP01 solver ingress.
        :param labels: Labels that should be added to the created ACME HTTP01 solver ingress.

        :schema: IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__53a2aa199ea989321aebcfca1554c8922219f1643d0b2bb8846e4863ede34090)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Annotations that should be added to the created ACME HTTP01 solver ingress.

        :schema: IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Labels that should be added to the created ACME HTTP01 solver ingress.

        :schema: IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplate",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplate:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata", typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges.

        :param metadata: ObjectMeta overrides for the pod used to solve HTTP01 challenges. Only the 'labels' and 'annotations' fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values.
        :param spec: PodSpec defines overrides for the HTTP01 challenge solver pod. Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields. All other fields will be ignored.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplate
        '''
        if isinstance(metadata, dict):
            metadata = IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata(**metadata)
        if isinstance(spec, dict):
            spec = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec(**spec)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2ed11b300b44553042c29d41779b68baaba8140f1368ef365dd4d915e6242c02)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata"]:
        '''ObjectMeta overrides for the pod used to solve HTTP01 challenges.

        Only the 'labels' and 'annotations' fields may be set.
        If labels or annotations overlap with in-built values, the values here
        will override the in-built values.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata"], result)

    @builtins.property
    def spec(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec"]:
        '''PodSpec defines overrides for the HTTP01 challenge solver pod.

        Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
        All other fields will be ignored.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplate#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={"annotations": "annotations", "labels": "labels"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''ObjectMeta overrides for the pod used to solve HTTP01 challenges.

        Only the 'labels' and 'annotations' fields may be set.
        If labels or annotations overlap with in-built values, the values here
        will override the in-built values.

        :param annotations: Annotations that should be added to the created ACME HTTP01 solver pods.
        :param labels: Labels that should be added to the created ACME HTTP01 solver pods.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__07a20343ae372cc52cc2654e7589cb639afc30e74e9e2e96e78c45bfc218998e)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Annotations that should be added to the created ACME HTTP01 solver pods.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Labels that should be added to the created ACME HTTP01 solver pods.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec",
    jsii_struct_bases=[],
    name_mapping={
        "affinity": "affinity",
        "image_pull_secrets": "imagePullSecrets",
        "node_selector": "nodeSelector",
        "priority_class_name": "priorityClassName",
        "security_context": "securityContext",
        "service_account_name": "serviceAccountName",
        "tolerations": "tolerations",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec:
    def __init__(
        self,
        *,
        affinity: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
        image_pull_secrets: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets", typing.Dict[builtins.str, typing.Any]]]] = None,
        node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        priority_class_name: typing.Optional[builtins.str] = None,
        security_context: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        tolerations: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''PodSpec defines overrides for the HTTP01 challenge solver pod.

        Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
        All other fields will be ignored.

        :param affinity: If specified, the pod's scheduling constraints.
        :param image_pull_secrets: If specified, the pod's imagePullSecrets.
        :param node_selector: NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
        :param priority_class_name: If specified, the pod's priorityClassName.
        :param security_context: If specified, the pod's security context.
        :param service_account_name: If specified, the pod's service account.
        :param tolerations: If specified, the pod's tolerations.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec
        '''
        if isinstance(affinity, dict):
            affinity = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity(**affinity)
        if isinstance(security_context, dict):
            security_context = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext(**security_context)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1e7494033d29f3e7c2a26c25fde35b8f69d6e95f180dcd0d2e40746eb4459a23)
            check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
            check_type(argname="argument image_pull_secrets", value=image_pull_secrets, expected_type=type_hints["image_pull_secrets"])
            check_type(argname="argument node_selector", value=node_selector, expected_type=type_hints["node_selector"])
            check_type(argname="argument priority_class_name", value=priority_class_name, expected_type=type_hints["priority_class_name"])
            check_type(argname="argument security_context", value=security_context, expected_type=type_hints["security_context"])
            check_type(argname="argument service_account_name", value=service_account_name, expected_type=type_hints["service_account_name"])
            check_type(argname="argument tolerations", value=tolerations, expected_type=type_hints["tolerations"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if affinity is not None:
            self._values["affinity"] = affinity
        if image_pull_secrets is not None:
            self._values["image_pull_secrets"] = image_pull_secrets
        if node_selector is not None:
            self._values["node_selector"] = node_selector
        if priority_class_name is not None:
            self._values["priority_class_name"] = priority_class_name
        if security_context is not None:
            self._values["security_context"] = security_context
        if service_account_name is not None:
            self._values["service_account_name"] = service_account_name
        if tolerations is not None:
            self._values["tolerations"] = tolerations

    @builtins.property
    def affinity(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity"]:
        '''If specified, the pod's scheduling constraints.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#affinity
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity"], result)

    @builtins.property
    def image_pull_secrets(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets"]]:
        '''If specified, the pod's imagePullSecrets.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#imagePullSecrets
        '''
        result = self._values.get("image_pull_secrets")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets"]], result)

    @builtins.property
    def node_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''NodeSelector is a selector which must be true for the pod to fit on a node.

        Selector which must match a node's labels for the pod to be scheduled on that node.
        More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#nodeSelector
        '''
        result = self._values.get("node_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def priority_class_name(self) -> typing.Optional[builtins.str]:
        '''If specified, the pod's priorityClassName.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#priorityClassName
        '''
        result = self._values.get("priority_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_context(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext"]:
        '''If specified, the pod's security context.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#securityContext
        '''
        result = self._values.get("security_context")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext"], result)

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        '''If specified, the pod's service account.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#serviceAccountName
        '''
        result = self._values.get("service_account_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tolerations(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations"]]:
        '''If specified, the pod's tolerations.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec#tolerations
        '''
        result = self._values.get("tolerations")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "node_affinity": "nodeAffinity",
        "pod_affinity": "podAffinity",
        "pod_anti_affinity": "podAntiAffinity",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity:
    def __init__(
        self,
        *,
        node_affinity: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_affinity: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_anti_affinity: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''If specified, the pod's scheduling constraints.

        :param node_affinity: Describes node affinity scheduling rules for the pod.
        :param pod_affinity: Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
        :param pod_anti_affinity: Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity
        '''
        if isinstance(node_affinity, dict):
            node_affinity = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity(**node_affinity)
        if isinstance(pod_affinity, dict):
            pod_affinity = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity(**pod_affinity)
        if isinstance(pod_anti_affinity, dict):
            pod_anti_affinity = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity(**pod_anti_affinity)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f373764257fad5085fd13f16b8a5ca49bbd3ba63bf49feec8e805d874f0d5886)
            check_type(argname="argument node_affinity", value=node_affinity, expected_type=type_hints["node_affinity"])
            check_type(argname="argument pod_affinity", value=pod_affinity, expected_type=type_hints["pod_affinity"])
            check_type(argname="argument pod_anti_affinity", value=pod_anti_affinity, expected_type=type_hints["pod_anti_affinity"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if node_affinity is not None:
            self._values["node_affinity"] = node_affinity
        if pod_affinity is not None:
            self._values["pod_affinity"] = pod_affinity
        if pod_anti_affinity is not None:
            self._values["pod_anti_affinity"] = pod_anti_affinity

    @builtins.property
    def node_affinity(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity"]:
        '''Describes node affinity scheduling rules for the pod.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity#nodeAffinity
        '''
        result = self._values.get("node_affinity")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity"], result)

    @builtins.property
    def pod_affinity(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity"]:
        '''Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity#podAffinity
        '''
        result = self._values.get("pod_affinity")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity"], result)

    @builtins.property
    def pod_anti_affinity(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity"]:
        '''Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity#podAntiAffinity
        '''
        result = self._values.get("pod_anti_affinity")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Describes node affinity scheduling rules for the pod.

        :param preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
        :param required_during_scheduling_ignored_during_execution: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity
        '''
        if isinstance(required_during_scheduling_ignored_during_execution, dict):
            required_during_scheduling_ignored_during_execution = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(**required_during_scheduling_ignored_during_execution)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e558ef371869e227c8d2968108286f0ca10af4a3bcb8c32a3f0c55ab68811df)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.

        The node that is
        most preferred is the one with the greatest sum of weights, i.e.
        for each node that meets all of the scheduling requirements (resource
        request, requiredDuringScheduling affinity expressions, etc.),
        compute a sum by iterating through the elements of this field and adding
        "weight" to the sum if the node matches the corresponding matchExpressions; the
        node(s) with the highest sum are the most preferred.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"]:
        '''If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the affinity requirements specified by this field cease to be met
        at some point during pod execution (e.g. due to an update), the system
        may or may not try to eventually evict the pod from its node.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"preference": "preference", "weight": "weight"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        preference: typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", typing.Dict[builtins.str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).

        :param preference: A node selector term, associated with the corresponding weight.
        :param weight: Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(preference, dict):
            preference = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(**preference)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__21d0d7a71502a15ac78a58ecb57e8f93ad8847ef1b733a3fc9d060895da8e5e1)
            check_type(argname="argument preference", value=preference, expected_type=type_hints["preference"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "preference": preference,
            "weight": weight,
        }

    @builtins.property
    def preference(
        self,
    ) -> "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference":
        '''A node selector term, associated with the corresponding weight.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
        '''
        result = self._values.get("preference")
        assert result is not None, "Required property 'preference' is missing"
        return typing.cast("IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''A node selector term, associated with the corresponding weight.

        :param match_expressions: A list of node selector requirements by node's labels.
        :param match_fields: A list of node selector requirements by node's fields.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91bcced19c9adfee8d9ab534a628f882416135b729640fb0c0a94f8b9233c993)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]]:
        '''A list of node selector requirements by node's labels.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]]:
        '''A list of node selector requirements by node's fields.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8cb04223888829deda9db21c362cdbb3000a5831958711b672980c868071c85)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''The label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''Represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. If the operator is Gt or Lt, the values
        array must have a single element, which will be interpreted as an integer.
        This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cd0adb78fb91460b8b1b202921cf7ac2d64bc32344ad22e94a660ec0c490511f)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''The label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''Represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. If the operator is Gt or Lt, the values
        array must have a single element, which will be interpreted as an integer.
        This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"node_selector_terms": "nodeSelectorTerms"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        node_selector_terms: typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms", typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the affinity requirements specified by this field cease to be met
        at some point during pod execution (e.g. due to an update), the system
        may or may not try to eventually evict the pod from its node.

        :param node_selector_terms: Required. A list of node selector terms. The terms are ORed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bf3550ded68b07665172bde4539b09fb9811d16d296e113ae6e34f72d1a53070)
            check_type(argname="argument node_selector_terms", value=node_selector_terms, expected_type=type_hints["node_selector_terms"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "node_selector_terms": node_selector_terms,
        }

    @builtins.property
    def node_selector_terms(
        self,
    ) -> typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"]:
        '''Required.

        A list of node selector terms. The terms are ORed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
        '''
        result = self._values.get("node_selector_terms")
        assert result is not None, "Required property 'node_selector_terms' is missing"
        return typing.cast(typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''A null or empty node selector term matches no objects.

        The requirements of
        them are ANDed.
        The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.

        :param match_expressions: A list of node selector requirements by node's labels.
        :param match_fields: A list of node selector requirements by node's fields.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c1d62a4b59b0c98cdc7e15d31f5e0aaddfb96d486346d8aabbd9739104709545)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]]:
        '''A list of node selector requirements by node's labels.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]]:
        '''A list of node selector requirements by node's fields.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__917b5a9cc550a3b32d25d2639532640e9ccd79ada5a59244d0ba0b373a1b83f0)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''The label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''Represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. If the operator is Gt or Lt, the values
        array must have a single element, which will be interpreted as an integer.
        This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8cc1b076cdcd4b53834911de769e1c08cf11a7f0c28b6c98ebbfe7f14a9f6f7f)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''The label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''Represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. If the operator is Gt or Lt, the values
        array must have a single element, which will be interpreted as an integer.
        This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).

        :param preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        :param required_during_scheduling_ignored_during_execution: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c646ac8a99006633a52c6f1843c12b33f75c20184cffd729343d4274aeef86ec)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.

        The node that is
        most preferred is the one with the greatest sum of weights, i.e.
        for each node that meets all of the scheduling requirements (resource
        request, requiredDuringScheduling affinity expressions, etc.),
        compute a sum by iterating through the elements of this field and adding
        "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
        node(s) with the highest sum are the most preferred.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the affinity requirements specified by this field cease to be met
        at some point during pod execution (e.g. due to a pod label update), the
        system may or may not try to eventually evict the pod from its node.
        When there are multiple elements, the lists of nodes corresponding to each
        podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[builtins.str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s).

        :param pod_affinity_term: Required. A pod affinity term, associated with the corresponding weight.
        :param weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ec3e548c456db0de962bb299e938a66ee4e2a22d85df0fbd77bcdf430ccfb1e)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''Required.

        A pod affinity term, associated with the corresponding weight.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "match_label_keys": "matchLabelKeys",
        "mismatch_label_keys": "mismatchLabelKeys",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Required.

        A pod affinity term, associated with the corresponding weight.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
        :param match_label_keys: MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param mismatch_label_keys: MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
        :param namespace_selector: A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__132790204a16b9feb4c3ba16221361b24d5d1d0e413240b1e762df405c598b17)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument match_label_keys", value=match_label_keys, expected_type=type_hints["match_label_keys"])
            check_type(argname="argument mismatch_label_keys", value=mismatch_label_keys, expected_type=type_hints["mismatch_label_keys"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if match_label_keys is not None:
            self._values["match_label_keys"] = match_label_keys
        if mismatch_label_keys is not None:
            self._values["mismatch_label_keys"] = mismatch_label_keys
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def match_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both matchLabelKeys and labelSelector.
        Also, matchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
        '''
        result = self._values.get("match_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def mismatch_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
        Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
        '''
        result = self._values.get("mismatch_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field
        and the ones selected by namespaceSelector.
        null or empty namespaces list and null namespaceSelector means "this pod's namespace".

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"]:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__92984c59a1d7649f76370a9645310b8435730cf21521381819702d0b45748bff)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__969365c3fbe238006f5b61efea5d55a3267947cfff6d34e9a7694a49026d48fc)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8817c747dd0fd5ceb9ff7ffd7e365f75123165d94ff054657abec742289b3276)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83e6ca235e7b4c96dc8fb540a92d823d3875c38bd53998477e53b8142455d4ab)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "match_label_keys": "matchLabelKeys",
        "mismatch_label_keys": "mismatchLabelKeys",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key  matches that of any node on which a pod of the set of pods is running.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
        :param match_label_keys: MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param mismatch_label_keys: MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
        :param namespace_selector: A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95cafe3316c15ba0cd9f611787bbff976072dc23e74362c176426d2d7c7d7ba0)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument match_label_keys", value=match_label_keys, expected_type=type_hints["match_label_keys"])
            check_type(argname="argument mismatch_label_keys", value=mismatch_label_keys, expected_type=type_hints["mismatch_label_keys"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if match_label_keys is not None:
            self._values["match_label_keys"] = match_label_keys
        if mismatch_label_keys is not None:
            self._values["mismatch_label_keys"] = mismatch_label_keys
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def match_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both matchLabelKeys and labelSelector.
        Also, matchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
        '''
        result = self._values.get("match_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def mismatch_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
        Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
        '''
        result = self._values.get("mismatch_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field
        and the ones selected by namespaceSelector.
        null or empty namespaces list and null namespaceSelector means "this pod's namespace".

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"]:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2128e2b5a9a912f000afacb2a176703d278cafdd39ba8f9b69f53b2e26b4f38c)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c681c3bd5261df52e4481eb18304eed22e35e340823f526a11139f098deefbbb)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__065476f80b2c1b81306fd17aeac8ef3bdd71f1c115733c4471367285abe6eac4)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd80193fbe7aa13853ab1c6103293ca3c83919da4f51b5a8b393edabeeade96d)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).

        :param preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        :param required_during_scheduling_ignored_during_execution: If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5ceaac555e75ba9a1320b345a819d12c2835b44b0311a4a814097c06b7ffa7e1)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.

        The node that is
        most preferred is the one with the greatest sum of weights, i.e.
        for each node that meets all of the scheduling requirements (resource
        request, requiredDuringScheduling anti-affinity expressions, etc.),
        compute a sum by iterating through the elements of this field and adding
        "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
        node(s) with the highest sum are the most preferred.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the anti-affinity requirements specified by this field cease to be met
        at some point during pod execution (e.g. due to a pod label update), the
        system may or may not try to eventually evict the pod from its node.
        When there are multiple elements, the lists of nodes corresponding to each
        podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[builtins.str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s).

        :param pod_affinity_term: Required. A pod affinity term, associated with the corresponding weight.
        :param weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b6c9bdb241451a0f8dc3dca127ea8d7f135e07204610d401bddbf4a75b3d17d)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''Required.

        A pod affinity term, associated with the corresponding weight.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "match_label_keys": "matchLabelKeys",
        "mismatch_label_keys": "mismatchLabelKeys",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Required.

        A pod affinity term, associated with the corresponding weight.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
        :param match_label_keys: MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param mismatch_label_keys: MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
        :param namespace_selector: A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__77e53cf9b0b1c16dfb8204ec6549caf33e8ecf6da78f377d4377639ee28b9833)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument match_label_keys", value=match_label_keys, expected_type=type_hints["match_label_keys"])
            check_type(argname="argument mismatch_label_keys", value=mismatch_label_keys, expected_type=type_hints["mismatch_label_keys"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if match_label_keys is not None:
            self._values["match_label_keys"] = match_label_keys
        if mismatch_label_keys is not None:
            self._values["mismatch_label_keys"] = mismatch_label_keys
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def match_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both matchLabelKeys and labelSelector.
        Also, matchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
        '''
        result = self._values.get("match_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def mismatch_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
        Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
        '''
        result = self._values.get("mismatch_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field
        and the ones selected by namespaceSelector.
        null or empty namespaces list and null namespaceSelector means "this pod's namespace".

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"]:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ef54cb842e44125885b07c9d5071f34742d3f60910d75f80c08a76508205e76)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70630e7bc657e14b01835c04db29ce66ab74ead622195ddf46b58e928a4dc846)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd4e5ce8bfcc6aa03e7661b8c97ea38a0a00aa988a3e6fa7ae0e97c2b7225c10)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d0af4d9781b21726299684216d4a38d835d5926821e37186bad1dbdcbdd3adf)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "match_label_keys": "matchLabelKeys",
        "mismatch_label_keys": "mismatchLabelKeys",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key  matches that of any node on which a pod of the set of pods is running.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
        :param match_label_keys: MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param mismatch_label_keys: MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)`` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
        :param namespace_selector: A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe4a21fdc86a23101744f25b753063eb501b50fcf8a3721c311c2a5a56bdfc56)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument match_label_keys", value=match_label_keys, expected_type=type_hints["match_label_keys"])
            check_type(argname="argument mismatch_label_keys", value=mismatch_label_keys, expected_type=type_hints["mismatch_label_keys"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if match_label_keys is not None:
            self._values["match_label_keys"] = match_label_keys
        if mismatch_label_keys is not None:
            self._values["mismatch_label_keys"] = mismatch_label_keys
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def match_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key in (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both matchLabelKeys and labelSelector.
        Also, matchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
        '''
        result = self._values.get("match_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def mismatch_label_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.

        The keys are used to lookup values from the
        incoming pod labels, those key-value labels are merged with ``labelSelector`` as ``key notin (value)``
        to select the group of existing pods which pods will be taken into consideration
        for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
        pod labels will be ignored. The default value is empty.
        The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
        Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
        This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
        '''
        result = self._values.get("mismatch_label_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field
        and the ones selected by namespaceSelector.
        null or empty namespaces list and null namespaceSelector means "this pod's namespace".

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"]:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over a set of resources, in this case pods.

        If it's null, this PodAffinityTerm matches with no Pods.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8861490e35c26e63bc1fa5fd63fc1d5f3acb41a5b64d043e56fd9b8787a7c514)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86548093d03b6d100f55fe8f70c737219143572d4b074586940658301f513b6d)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label query over the set of namespaces that the term applies to.

        The term is applied to the union of the namespaces selected by this field
        and the ones listed in the namespaces field.
        null selector and null or empty namespaces list means "this pod's namespace".
        An empty selector ({}) matches all namespaces.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37e6ce7a01b4b3609950862108aaf31985b77f250549f7068a7e400b127d4b68)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2823dadc3279d67057f627473b0d026214756265ad1a26169a8d9a21dabd1ff5)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.

        :param name: Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8b88a290e5d2800c0064d5c988836c4c3e1307735eb46475e69e587918bcdf48)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the referent.

        This field is effectively required, but due to backwards compatibility is
        allowed to be empty. Instances of this type with an empty value here are
        almost certainly wrong.
        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "fs_group": "fsGroup",
        "fs_group_change_policy": "fsGroupChangePolicy",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "supplemental_groups": "supplementalGroups",
        "sysctls": "sysctls",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext:
    def __init__(
        self,
        *,
        fs_group: typing.Optional[jsii.Number] = None,
        fs_group_change_policy: typing.Optional[builtins.str] = None,
        run_as_group: typing.Optional[jsii.Number] = None,
        run_as_non_root: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
        seccomp_profile: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile", typing.Dict[builtins.str, typing.Any]]] = None,
        se_linux_options: typing.Optional[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions", typing.Dict[builtins.str, typing.Any]]] = None,
        supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
        sysctls: typing.Optional[typing.Sequence[typing.Union["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''If specified, the pod's security context.

        :param fs_group: A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
        :param fs_group_change_policy: fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
        :param run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
        :param run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows. Default: user specified in image metadata if unspecified.
        :param seccomp_profile: The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        :param se_linux_options: The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
        :param supplemental_groups: A list of groups applied to the first process run in each container, in addition to the container's primary GID, the fsGroup (if specified), and group memberships defined in the container image for the uid of the container process. If unspecified, no additional groups are added to any container. Note that group memberships defined in the container image for the uid of the container process are still effective, even if they are not included in this list. Note that this field cannot be set when spec.os.name is windows.
        :param sysctls: Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext
        '''
        if isinstance(seccomp_profile, dict):
            seccomp_profile = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile(**seccomp_profile)
        if isinstance(se_linux_options, dict):
            se_linux_options = IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions(**se_linux_options)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4afeefb66683568b2a1a6709e07a78a90ba48a4fdba567be2c9c0c33e414e67)
            check_type(argname="argument fs_group", value=fs_group, expected_type=type_hints["fs_group"])
            check_type(argname="argument fs_group_change_policy", value=fs_group_change_policy, expected_type=type_hints["fs_group_change_policy"])
            check_type(argname="argument run_as_group", value=run_as_group, expected_type=type_hints["run_as_group"])
            check_type(argname="argument run_as_non_root", value=run_as_non_root, expected_type=type_hints["run_as_non_root"])
            check_type(argname="argument run_as_user", value=run_as_user, expected_type=type_hints["run_as_user"])
            check_type(argname="argument seccomp_profile", value=seccomp_profile, expected_type=type_hints["seccomp_profile"])
            check_type(argname="argument se_linux_options", value=se_linux_options, expected_type=type_hints["se_linux_options"])
            check_type(argname="argument supplemental_groups", value=supplemental_groups, expected_type=type_hints["supplemental_groups"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if fs_group is not None:
            self._values["fs_group"] = fs_group
        if fs_group_change_policy is not None:
            self._values["fs_group_change_policy"] = fs_group_change_policy
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if supplemental_groups is not None:
            self._values["supplemental_groups"] = supplemental_groups
        if sysctls is not None:
            self._values["sysctls"] = sysctls

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''A special supplemental group that applies to all containers in a pod.

        Some volume types allow the Kubelet to change the ownership of that volume
        to be owned by the pod:

        1. The owning GID will be the FSGroup
        2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
        3. The permission bits are OR'd with rw-rw----

        If unset, the Kubelet will not modify the ownership and permissions of any volume.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#fsGroup
        '''
        result = self._values.get("fs_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_group_change_policy(self) -> typing.Optional[builtins.str]:
        '''fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod.

        This field will only apply to
        volume types which support fsGroup based ownership(and permissions).
        It will have no effect on ephemeral volume types such as: secret, configmaps
        and emptydir.
        Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#fsGroupChangePolicy
        '''
        result = self._values.get("fs_group_change_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[jsii.Number]:
        '''The GID to run the entrypoint of the container process.

        Uses runtime default if unset.
        May also be set in SecurityContext.  If set in both SecurityContext and
        PodSecurityContext, the value specified in SecurityContext takes precedence
        for that container.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#runAsGroup
        '''
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def run_as_non_root(self) -> typing.Optional[builtins.bool]:
        '''Indicates that the container must run as a non-root user.

        If true, the Kubelet will validate the image at runtime to ensure that it
        does not run as UID 0 (root) and fail to start the container if it does.
        If unset or false, no such validation will be performed.
        May also be set in SecurityContext.  If set in both SecurityContext and
        PodSecurityContext, the value specified in SecurityContext takes precedence.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#runAsNonRoot
        '''
        result = self._values.get("run_as_non_root")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''The UID to run the entrypoint of the container process.

        Defaults to user specified in image metadata if unspecified.
        May also be set in SecurityContext.  If set in both SecurityContext and
        PodSecurityContext, the value specified in SecurityContext takes precedence
        for that container.
        Note that this field cannot be set when spec.os.name is windows.

        :default: user specified in image metadata if unspecified.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#runAsUser
        '''
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile"]:
        '''The seccomp options to use by the containers in this pod.

        Note that this field cannot be set when spec.os.name is windows.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#seccompProfile
        '''
        result = self._values.get("seccomp_profile")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile"], result)

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions"]:
        '''The SELinux context to be applied to all containers.

        If unspecified, the container runtime will allocate a random SELinux context for each
        container.  May also be set in SecurityContext.  If set in
        both SecurityContext and PodSecurityContext, the value specified in SecurityContext
        takes precedence for that container.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#seLinuxOptions
        '''
        result = self._values.get("se_linux_options")
        return typing.cast(typing.Optional["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions"], result)

    @builtins.property
    def supplemental_groups(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''A list of groups applied to the first process run in each container, in addition to the container's primary GID, the fsGroup (if specified), and group memberships defined in the container image for the uid of the container process.

        If unspecified,
        no additional groups are added to any container. Note that group memberships
        defined in the container image for the uid of the container process are still effective,
        even if they are not included in this list.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#supplementalGroups
        '''
        result = self._values.get("supplemental_groups")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def sysctls(
        self,
    ) -> typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls"]]:
        '''Sysctls hold a list of namespaced sysctls used for the pod.

        Pods with unsupported
        sysctls (by the container runtime) might fail to launch.
        Note that this field cannot be set when spec.os.name is windows.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext#sysctls
        '''
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[typing.List["IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SELinux context to be applied to all containers.

        If unspecified, the container runtime will allocate a random SELinux context for each
        container.  May also be set in SecurityContext.  If set in
        both SecurityContext and PodSecurityContext, the value specified in SecurityContext
        takes precedence for that container.
        Note that this field cannot be set when spec.os.name is windows.

        :param level: Level is SELinux level label that applies to the container.
        :param role: Role is a SELinux role label that applies to the container.
        :param type: Type is a SELinux type label that applies to the container.
        :param user: User is a SELinux user label that applies to the container.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dff03fc0e2ec84e8f285fb3f5c994cab65416888aa531f7db56f16fb075f2d2b)
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        '''Level is SELinux level label that applies to the container.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions#level
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a SELinux role label that applies to the container.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''Type is a SELinux type label that applies to the container.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''User is a SELinux user label that applies to the container.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "localhost_profile": "localhostProfile"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        type: builtins.str,
        localhost_profile: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The seccomp options to use by the containers in this pod.

        Note that this field cannot be set when spec.os.name is windows.

        :param type: type indicates which kind of seccomp profile will be applied. Valid options are:. Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
        :param localhost_profile: localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any other type.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba325ddab20e1f1f5c73e964cb7c326716fe446e259ad1cabbcce0237e2c41d3)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument localhost_profile", value=localhost_profile, expected_type=type_hints["localhost_profile"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "type": type,
        }
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile

    @builtins.property
    def type(self) -> builtins.str:
        '''type indicates which kind of seccomp profile will be applied. Valid options are:.

        Localhost - a profile defined in a file on the node should be used.
        RuntimeDefault - the container runtime default profile should be used.
        Unconfined - no profile should be applied.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        '''localhostProfile indicates a profile defined in a file on the node should be used.

        The profile must be preconfigured on the node to work.
        Must be a descending path, relative to the kubelet's configured seccomp profile location.
        Must be set if type is "Localhost". Must NOT be set for any other type.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile#localhostProfile
        '''
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''Sysctl defines a kernel parameter to be set.

        :param name: Name of a property to set.
        :param value: Value of a property to set.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f441232ea07187ceda138922957d701a1a1315fc3c9031918f56a9b48fa13624)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of a property to set.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''Value of a property to set.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations",
    jsii_struct_bases=[],
    name_mapping={
        "effect": "effect",
        "key": "key",
        "operator": "operator",
        "toleration_seconds": "tolerationSeconds",
        "value": "value",
    },
)
class IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations:
    def __init__(
        self,
        *,
        effect: typing.Optional[builtins.str] = None,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        toleration_seconds: typing.Optional[jsii.Number] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator .

        :param effect: Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        :param key: Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        :param operator: Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category. Default: Equal.
        :param toleration_seconds: TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        :param value: Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e92b618030a3e35314381c9428a66bf55a0fbde7a47342af86c4c8babf506d93)
            check_type(argname="argument effect", value=effect, expected_type=type_hints["effect"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument toleration_seconds", value=toleration_seconds, expected_type=type_hints["toleration_seconds"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if effect is not None:
            self._values["effect"] = effect
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if toleration_seconds is not None:
            self._values["toleration_seconds"] = toleration_seconds
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def effect(self) -> typing.Optional[builtins.str]:
        '''Effect indicates the taint effect to match.

        Empty means match all taint effects.
        When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations#effect
        '''
        result = self._values.get("effect")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''Key is the taint key that the toleration applies to.

        Empty means match all taint keys.
        If the key is empty, operator must be Exists; this combination means to match all values and all keys.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''Operator represents a key's relationship to the value.

        Valid operators are Exists and Equal. Defaults to Equal.
        Exists is equivalent to wildcard for value, so that a pod can
        tolerate all taints of a particular category.

        :default: Equal.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations#operator
        '''
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def toleration_seconds(self) -> typing.Optional[jsii.Number]:
        '''TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.

        By default,
        it is not set, which means tolerate the taint forever (do not evict). Zero and
        negative values will be treated as 0 (evict immediately) by the system.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations#tolerationSeconds
        '''
        result = self._values.get("toleration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value is the taint value the toleration matches to.

        If the operator is Exists, the value should be empty, otherwise just a regular string.

        :schema: IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecAcmeSolversSelector",
    jsii_struct_bases=[],
    name_mapping={
        "dns_names": "dnsNames",
        "dns_zones": "dnsZones",
        "match_labels": "matchLabels",
    },
)
class IssuerSpecAcmeSolversSelector:
    def __init__(
        self,
        *,
        dns_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        dns_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Selector selects a set of DNSNames on the Certificate resource that should be solved using this challenge solver.

        If not specified, the solver will be treated as the 'default' solver
        with the lowest priority, i.e. if any other solver has a more specific
        match, it will be used instead.

        :param dns_names: List of DNSNames that this solver will be used to solve. If specified and a match is found, a dnsNames selector will take precedence over a dnsZones selector. If multiple solvers match with the same dnsNames value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected.
        :param dns_zones: List of DNSZones that this solver will be used to solve. The most specific DNS zone match specified here will take precedence over other DNS zone matches, so a solver specifying sys.example.com will be selected over one specifying example.com for the domain www.sys.example.com. If multiple solvers match with the same dnsZones value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected.
        :param match_labels: A label selector that is used to refine the set of certificate's that this challenge solver will apply to.

        :schema: IssuerSpecAcmeSolversSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ad3008cf977de3efd0f98199a41ff11453fc3a3cafccd06d925d94ab2744b5fa)
            check_type(argname="argument dns_names", value=dns_names, expected_type=type_hints["dns_names"])
            check_type(argname="argument dns_zones", value=dns_zones, expected_type=type_hints["dns_zones"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dns_names is not None:
            self._values["dns_names"] = dns_names
        if dns_zones is not None:
            self._values["dns_zones"] = dns_zones
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def dns_names(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of DNSNames that this solver will be used to solve.

        If specified and a match is found, a dnsNames selector will take
        precedence over a dnsZones selector.
        If multiple solvers match with the same dnsNames value, the solver
        with the most matching labels in matchLabels will be selected.
        If neither has more matches, the solver defined earlier in the list
        will be selected.

        :schema: IssuerSpecAcmeSolversSelector#dnsNames
        '''
        result = self._values.get("dns_names")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def dns_zones(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of DNSZones that this solver will be used to solve.

        The most specific DNS zone match specified here will take precedence
        over other DNS zone matches, so a solver specifying sys.example.com
        will be selected over one specifying example.com for the domain
        www.sys.example.com.
        If multiple solvers match with the same dnsZones value, the solver
        with the most matching labels in matchLabels will be selected.
        If neither has more matches, the solver defined earlier in the list
        will be selected.

        :schema: IssuerSpecAcmeSolversSelector#dnsZones
        '''
        result = self._values.get("dns_zones")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A label selector that is used to refine the set of certificate's that this challenge solver will apply to.

        :schema: IssuerSpecAcmeSolversSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecAcmeSolversSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecCa",
    jsii_struct_bases=[],
    name_mapping={
        "secret_name": "secretName",
        "crl_distribution_points": "crlDistributionPoints",
        "issuing_certificate_ur_ls": "issuingCertificateUrLs",
        "ocsp_servers": "ocspServers",
    },
)
class IssuerSpecCa:
    def __init__(
        self,
        *,
        secret_name: builtins.str,
        crl_distribution_points: typing.Optional[typing.Sequence[builtins.str]] = None,
        issuing_certificate_ur_ls: typing.Optional[typing.Sequence[builtins.str]] = None,
        ocsp_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''CA configures this issuer to sign certificates using a signing CA keypair stored in a Secret resource.

        This is used to build internal PKIs that are managed by cert-manager.

        :param secret_name: SecretName is the name of the secret used to sign Certificates issued by this Issuer.
        :param crl_distribution_points: The CRL distribution points is an X.509 v3 certificate extension which identifies the location of the CRL from which the revocation of this certificate can be checked. If not set, certificates will be issued without distribution points set.
        :param issuing_certificate_ur_ls: IssuingCertificateURLs is a list of URLs which this issuer should embed into certificates it creates. See https://www.rfc-editor.org/rfc/rfc5280#section-4.2.2.1 for more details. As an example, such a URL might be "http://ca.domain.com/ca.crt".
        :param ocsp_servers: The OCSP server list is an X.509 v3 extension that defines a list of URLs of OCSP responders. The OCSP responders can be queried for the revocation status of an issued certificate. If not set, the certificate will be issued with no OCSP servers set. For example, an OCSP server URL could be "http://ocsp.int-x3.letsencrypt.org".

        :schema: IssuerSpecCa
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__466b89ab20e391ba331d51cad076c0d1a7f2b3658d4b2ae9f8b7aa10229fc92f)
            check_type(argname="argument secret_name", value=secret_name, expected_type=type_hints["secret_name"])
            check_type(argname="argument crl_distribution_points", value=crl_distribution_points, expected_type=type_hints["crl_distribution_points"])
            check_type(argname="argument issuing_certificate_ur_ls", value=issuing_certificate_ur_ls, expected_type=type_hints["issuing_certificate_ur_ls"])
            check_type(argname="argument ocsp_servers", value=ocsp_servers, expected_type=type_hints["ocsp_servers"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_name": secret_name,
        }
        if crl_distribution_points is not None:
            self._values["crl_distribution_points"] = crl_distribution_points
        if issuing_certificate_ur_ls is not None:
            self._values["issuing_certificate_ur_ls"] = issuing_certificate_ur_ls
        if ocsp_servers is not None:
            self._values["ocsp_servers"] = ocsp_servers

    @builtins.property
    def secret_name(self) -> builtins.str:
        '''SecretName is the name of the secret used to sign Certificates issued by this Issuer.

        :schema: IssuerSpecCa#secretName
        '''
        result = self._values.get("secret_name")
        assert result is not None, "Required property 'secret_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def crl_distribution_points(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The CRL distribution points is an X.509 v3 certificate extension which identifies the location of the CRL from which the revocation of this certificate can be checked. If not set, certificates will be issued without distribution points set.

        :schema: IssuerSpecCa#crlDistributionPoints
        '''
        result = self._values.get("crl_distribution_points")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def issuing_certificate_ur_ls(self) -> typing.Optional[typing.List[builtins.str]]:
        '''IssuingCertificateURLs is a list of URLs which this issuer should embed into certificates it creates.

        See https://www.rfc-editor.org/rfc/rfc5280#section-4.2.2.1 for more details.
        As an example, such a URL might be "http://ca.domain.com/ca.crt".

        :schema: IssuerSpecCa#issuingCertificateURLs
        '''
        result = self._values.get("issuing_certificate_ur_ls")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def ocsp_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The OCSP server list is an X.509 v3 extension that defines a list of URLs of OCSP responders. The OCSP responders can be queried for the revocation status of an issued certificate. If not set, the certificate will be issued with no OCSP servers set. For example, an OCSP server URL could be "http://ocsp.int-x3.letsencrypt.org".

        :schema: IssuerSpecCa#ocspServers
        '''
        result = self._values.get("ocsp_servers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecCa(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecSelfSigned",
    jsii_struct_bases=[],
    name_mapping={"crl_distribution_points": "crlDistributionPoints"},
)
class IssuerSpecSelfSigned:
    def __init__(
        self,
        *,
        crl_distribution_points: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''SelfSigned configures this issuer to 'self sign' certificates using the private key used to create the CertificateRequest object.

        :param crl_distribution_points: The CRL distribution points is an X.509 v3 certificate extension which identifies the location of the CRL from which the revocation of this certificate can be checked. If not set certificate will be issued without CDP. Values are strings.

        :schema: IssuerSpecSelfSigned
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e1f1b2ede1230831b3cbdc9bafdf7d0e443628e37f980daf2277c2798a6e71e)
            check_type(argname="argument crl_distribution_points", value=crl_distribution_points, expected_type=type_hints["crl_distribution_points"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if crl_distribution_points is not None:
            self._values["crl_distribution_points"] = crl_distribution_points

    @builtins.property
    def crl_distribution_points(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The CRL distribution points is an X.509 v3 certificate extension which identifies the location of the CRL from which the revocation of this certificate can be checked. If not set certificate will be issued without CDP. Values are strings.

        :schema: IssuerSpecSelfSigned#crlDistributionPoints
        '''
        result = self._values.get("crl_distribution_points")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecSelfSigned(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVault",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "path": "path",
        "server": "server",
        "ca_bundle": "caBundle",
        "ca_bundle_secret_ref": "caBundleSecretRef",
        "client_cert_secret_ref": "clientCertSecretRef",
        "client_key_secret_ref": "clientKeySecretRef",
        "namespace": "namespace",
    },
)
class IssuerSpecVault:
    def __init__(
        self,
        *,
        auth: typing.Union["IssuerSpecVaultAuth", typing.Dict[builtins.str, typing.Any]],
        path: builtins.str,
        server: builtins.str,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_bundle_secret_ref: typing.Optional[typing.Union["IssuerSpecVaultCaBundleSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        client_cert_secret_ref: typing.Optional[typing.Union["IssuerSpecVaultClientCertSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        client_key_secret_ref: typing.Optional[typing.Union["IssuerSpecVaultClientKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Vault configures this issuer to sign certificates using a HashiCorp Vault PKI backend.

        :param auth: Auth configures how cert-manager authenticates with the Vault server.
        :param path: Path is the mount path of the Vault PKI backend's ``sign`` endpoint, e.g: "my_pki_mount/sign/my-role-name".
        :param server: Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
        :param ca_bundle: Base64-encoded bundle of PEM CAs which will be used to validate the certificate chain presented by Vault. Only used if using HTTPS to connect to Vault and ignored for HTTP connections. Mutually exclusive with CABundleSecretRef. If neither CABundle nor CABundleSecretRef are defined, the certificate bundle in the cert-manager controller container is used to validate the TLS connection.
        :param ca_bundle_secret_ref: Reference to a Secret containing a bundle of PEM-encoded CAs to use when verifying the certificate chain presented by Vault when using HTTPS. Mutually exclusive with CABundle. If neither CABundle nor CABundleSecretRef are defined, the certificate bundle in the cert-manager controller container is used to validate the TLS connection. If no key for the Secret is specified, cert-manager will default to 'ca.crt'.
        :param client_cert_secret_ref: Reference to a Secret containing a PEM-encoded Client Certificate to use when the Vault server requires mTLS.
        :param client_key_secret_ref: Reference to a Secret containing a PEM-encoded Client Private Key to use when the Vault server requires mTLS.
        :param namespace: Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1" More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces

        :schema: IssuerSpecVault
        '''
        if isinstance(auth, dict):
            auth = IssuerSpecVaultAuth(**auth)
        if isinstance(ca_bundle_secret_ref, dict):
            ca_bundle_secret_ref = IssuerSpecVaultCaBundleSecretRef(**ca_bundle_secret_ref)
        if isinstance(client_cert_secret_ref, dict):
            client_cert_secret_ref = IssuerSpecVaultClientCertSecretRef(**client_cert_secret_ref)
        if isinstance(client_key_secret_ref, dict):
            client_key_secret_ref = IssuerSpecVaultClientKeySecretRef(**client_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a39a5efadd872548b56058d6e676861d5981980d82342c2562d4f6ae56fb908f)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_bundle_secret_ref", value=ca_bundle_secret_ref, expected_type=type_hints["ca_bundle_secret_ref"])
            check_type(argname="argument client_cert_secret_ref", value=client_cert_secret_ref, expected_type=type_hints["client_cert_secret_ref"])
            check_type(argname="argument client_key_secret_ref", value=client_key_secret_ref, expected_type=type_hints["client_key_secret_ref"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "path": path,
            "server": server,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_bundle_secret_ref is not None:
            self._values["ca_bundle_secret_ref"] = ca_bundle_secret_ref
        if client_cert_secret_ref is not None:
            self._values["client_cert_secret_ref"] = client_cert_secret_ref
        if client_key_secret_ref is not None:
            self._values["client_key_secret_ref"] = client_key_secret_ref
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def auth(self) -> "IssuerSpecVaultAuth":
        '''Auth configures how cert-manager authenticates with the Vault server.

        :schema: IssuerSpecVault#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("IssuerSpecVaultAuth", result)

    @builtins.property
    def path(self) -> builtins.str:
        '''Path is the mount path of the Vault PKI backend's ``sign`` endpoint, e.g: "my_pki_mount/sign/my-role-name".

        :schema: IssuerSpecVault#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def server(self) -> builtins.str:
        '''Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".

        :schema: IssuerSpecVault#server
        '''
        result = self._values.get("server")
        assert result is not None, "Required property 'server' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''Base64-encoded bundle of PEM CAs which will be used to validate the certificate chain presented by Vault.

        Only used if using HTTPS to connect to Vault and
        ignored for HTTP connections.
        Mutually exclusive with CABundleSecretRef.
        If neither CABundle nor CABundleSecretRef are defined, the certificate bundle in
        the cert-manager controller container is used to validate the TLS connection.

        :schema: IssuerSpecVault#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_bundle_secret_ref(
        self,
    ) -> typing.Optional["IssuerSpecVaultCaBundleSecretRef"]:
        '''Reference to a Secret containing a bundle of PEM-encoded CAs to use when verifying the certificate chain presented by Vault when using HTTPS.

        Mutually exclusive with CABundle.
        If neither CABundle nor CABundleSecretRef are defined, the certificate bundle in
        the cert-manager controller container is used to validate the TLS connection.
        If no key for the Secret is specified, cert-manager will default to 'ca.crt'.

        :schema: IssuerSpecVault#caBundleSecretRef
        '''
        result = self._values.get("ca_bundle_secret_ref")
        return typing.cast(typing.Optional["IssuerSpecVaultCaBundleSecretRef"], result)

    @builtins.property
    def client_cert_secret_ref(
        self,
    ) -> typing.Optional["IssuerSpecVaultClientCertSecretRef"]:
        '''Reference to a Secret containing a PEM-encoded Client Certificate to use when the Vault server requires mTLS.

        :schema: IssuerSpecVault#clientCertSecretRef
        '''
        result = self._values.get("client_cert_secret_ref")
        return typing.cast(typing.Optional["IssuerSpecVaultClientCertSecretRef"], result)

    @builtins.property
    def client_key_secret_ref(
        self,
    ) -> typing.Optional["IssuerSpecVaultClientKeySecretRef"]:
        '''Reference to a Secret containing a PEM-encoded Client Private Key to use when the Vault server requires mTLS.

        :schema: IssuerSpecVault#clientKeySecretRef
        '''
        result = self._values.get("client_key_secret_ref")
        return typing.cast(typing.Optional["IssuerSpecVaultClientKeySecretRef"], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Name of the vault namespace.

        Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1"
        More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces

        :schema: IssuerSpecVault#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVault(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVaultAuth",
    jsii_struct_bases=[],
    name_mapping={
        "app_role": "appRole",
        "client_certificate": "clientCertificate",
        "kubernetes": "kubernetes",
        "token_secret_ref": "tokenSecretRef",
    },
)
class IssuerSpecVaultAuth:
    def __init__(
        self,
        *,
        app_role: typing.Optional[typing.Union["IssuerSpecVaultAuthAppRole", typing.Dict[builtins.str, typing.Any]]] = None,
        client_certificate: typing.Optional[typing.Union["IssuerSpecVaultAuthClientCertificate", typing.Dict[builtins.str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["IssuerSpecVaultAuthKubernetes", typing.Dict[builtins.str, typing.Any]]] = None,
        token_secret_ref: typing.Optional[typing.Union["IssuerSpecVaultAuthTokenSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how cert-manager authenticates with the Vault server.

        :param app_role: AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
        :param client_certificate: ClientCertificate authenticates with Vault by presenting a client certificate during the request's TLS handshake. Works only when using HTTPS protocol.
        :param kubernetes: Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
        :param token_secret_ref: TokenSecretRef authenticates with Vault by presenting a token.

        :schema: IssuerSpecVaultAuth
        '''
        if isinstance(app_role, dict):
            app_role = IssuerSpecVaultAuthAppRole(**app_role)
        if isinstance(client_certificate, dict):
            client_certificate = IssuerSpecVaultAuthClientCertificate(**client_certificate)
        if isinstance(kubernetes, dict):
            kubernetes = IssuerSpecVaultAuthKubernetes(**kubernetes)
        if isinstance(token_secret_ref, dict):
            token_secret_ref = IssuerSpecVaultAuthTokenSecretRef(**token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd96325df56196378aca00e9c0250307bd090ca706e6200b62641b7443884662)
            check_type(argname="argument app_role", value=app_role, expected_type=type_hints["app_role"])
            check_type(argname="argument client_certificate", value=client_certificate, expected_type=type_hints["client_certificate"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument token_secret_ref", value=token_secret_ref, expected_type=type_hints["token_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if app_role is not None:
            self._values["app_role"] = app_role
        if client_certificate is not None:
            self._values["client_certificate"] = client_certificate
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if token_secret_ref is not None:
            self._values["token_secret_ref"] = token_secret_ref

    @builtins.property
    def app_role(self) -> typing.Optional["IssuerSpecVaultAuthAppRole"]:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :schema: IssuerSpecVaultAuth#appRole
        '''
        result = self._values.get("app_role")
        return typing.cast(typing.Optional["IssuerSpecVaultAuthAppRole"], result)

    @builtins.property
    def client_certificate(
        self,
    ) -> typing.Optional["IssuerSpecVaultAuthClientCertificate"]:
        '''ClientCertificate authenticates with Vault by presenting a client certificate during the request's TLS handshake.

        Works only when using HTTPS protocol.

        :schema: IssuerSpecVaultAuth#clientCertificate
        '''
        result = self._values.get("client_certificate")
        return typing.cast(typing.Optional["IssuerSpecVaultAuthClientCertificate"], result)

    @builtins.property
    def kubernetes(self) -> typing.Optional["IssuerSpecVaultAuthKubernetes"]:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :schema: IssuerSpecVaultAuth#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["IssuerSpecVaultAuthKubernetes"], result)

    @builtins.property
    def token_secret_ref(self) -> typing.Optional["IssuerSpecVaultAuthTokenSecretRef"]:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :schema: IssuerSpecVaultAuth#tokenSecretRef
        '''
        result = self._values.get("token_secret_ref")
        return typing.cast(typing.Optional["IssuerSpecVaultAuthTokenSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVaultAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVaultAuthAppRole",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "role_id": "roleId", "secret_ref": "secretRef"},
)
class IssuerSpecVaultAuthAppRole:
    def __init__(
        self,
        *,
        path: builtins.str,
        role_id: builtins.str,
        secret_ref: typing.Union["IssuerSpecVaultAuthAppRoleSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :param path: Path where the App Role authentication backend is mounted in Vault, e.g: "approle".
        :param role_id: RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
        :param secret_ref: Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.

        :schema: IssuerSpecVaultAuthAppRole
        '''
        if isinstance(secret_ref, dict):
            secret_ref = IssuerSpecVaultAuthAppRoleSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f9e3b8b938ff4994ca79d22c0ed228070d3ba12398b3a681dad866b777a535f)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument role_id", value=role_id, expected_type=type_hints["role_id"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
            "role_id": role_id,
            "secret_ref": secret_ref,
        }

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the App Role authentication backend is mounted in Vault, e.g: "approle".

        :schema: IssuerSpecVaultAuthAppRole#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_id(self) -> builtins.str:
        '''RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.

        :schema: IssuerSpecVaultAuthAppRole#roleId
        '''
        result = self._values.get("role_id")
        assert result is not None, "Required property 'role_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(self) -> "IssuerSpecVaultAuthAppRoleSecretRef":
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret
        resource is used as the app role secret.

        :schema: IssuerSpecVaultAuthAppRole#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("IssuerSpecVaultAuthAppRoleSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVaultAuthAppRole(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVaultAuthAppRoleSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecVaultAuthAppRoleSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret
        resource is used as the app role secret.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecVaultAuthAppRoleSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d39cee765742baef80216bd5b29bf24b4d1cb35a54fbb95214603c2f2c78aa7)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecVaultAuthAppRoleSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecVaultAuthAppRoleSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVaultAuthAppRoleSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVaultAuthClientCertificate",
    jsii_struct_bases=[],
    name_mapping={
        "mount_path": "mountPath",
        "name": "name",
        "secret_name": "secretName",
    },
)
class IssuerSpecVaultAuthClientCertificate:
    def __init__(
        self,
        *,
        mount_path: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        secret_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientCertificate authenticates with Vault by presenting a client certificate during the request's TLS handshake.

        Works only when using HTTPS protocol.

        :param mount_path: The Vault mountPath here is the mount path to use when authenticating with Vault. For example, setting a value to ``/v1/auth/foo``, will use the path ``/v1/auth/foo/login`` to authenticate with Vault. If unspecified, the default value "/v1/auth/cert" will be used.
        :param name: Name of the certificate role to authenticate against. If not set, matching any certificate role, if available.
        :param secret_name: Reference to Kubernetes Secret of type "kubernetes.io/tls" (hence containing tls.crt and tls.key) used to authenticate to Vault using TLS client authentication.

        :schema: IssuerSpecVaultAuthClientCertificate
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd7c45120497fd59d49f6f2d5fe5481cc3a656d63f564360f2691147bc4d7b0a)
            check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument secret_name", value=secret_name, expected_type=type_hints["secret_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if mount_path is not None:
            self._values["mount_path"] = mount_path
        if name is not None:
            self._values["name"] = name
        if secret_name is not None:
            self._values["secret_name"] = secret_name

    @builtins.property
    def mount_path(self) -> typing.Optional[builtins.str]:
        '''The Vault mountPath here is the mount path to use when authenticating with Vault.

        For example, setting a value to ``/v1/auth/foo``, will use the path
        ``/v1/auth/foo/login`` to authenticate with Vault. If unspecified, the
        default value "/v1/auth/cert" will be used.

        :schema: IssuerSpecVaultAuthClientCertificate#mountPath
        '''
        result = self._values.get("mount_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the certificate role to authenticate against.

        If not set, matching any certificate role, if available.

        :schema: IssuerSpecVaultAuthClientCertificate#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_name(self) -> typing.Optional[builtins.str]:
        '''Reference to Kubernetes Secret of type "kubernetes.io/tls" (hence containing tls.crt and tls.key) used to authenticate to Vault using TLS client authentication.

        :schema: IssuerSpecVaultAuthClientCertificate#secretName
        '''
        result = self._values.get("secret_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVaultAuthClientCertificate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVaultAuthKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "role": "role",
        "mount_path": "mountPath",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class IssuerSpecVaultAuthKubernetes:
    def __init__(
        self,
        *,
        role: builtins.str,
        mount_path: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["IssuerSpecVaultAuthKubernetesSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["IssuerSpecVaultAuthKubernetesServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :param role: A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
        :param mount_path: The Vault mountPath here is the mount path to use when authenticating with Vault. For example, setting a value to ``/v1/auth/foo``, will use the path ``/v1/auth/foo/login`` to authenticate with Vault. If unspecified, the default value "/v1/auth/kubernetes" will be used.
        :param secret_ref: The required Secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. Use of 'ambient credentials' is not supported.
        :param service_account_ref: A reference to a service account that will be used to request a bound token (also known as "projected token"). Compared to using "secretRef", using this field means that you don't rely on statically bound tokens. To use this field, you must configure an RBAC rule to let cert-manager request a token.

        :schema: IssuerSpecVaultAuthKubernetes
        '''
        if isinstance(secret_ref, dict):
            secret_ref = IssuerSpecVaultAuthKubernetesSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = IssuerSpecVaultAuthKubernetesServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d6221a3681154bdb8df032c8ef071f72c1865736ca28bfd04df576935a7ae86f)
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "role": role,
        }
        if mount_path is not None:
            self._values["mount_path"] = mount_path
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def role(self) -> builtins.str:
        '''A required field containing the Vault Role to assume.

        A Role binds a
        Kubernetes ServiceAccount with a set of Vault policies.

        :schema: IssuerSpecVaultAuthKubernetes#role
        '''
        result = self._values.get("role")
        assert result is not None, "Required property 'role' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mount_path(self) -> typing.Optional[builtins.str]:
        '''The Vault mountPath here is the mount path to use when authenticating with Vault.

        For example, setting a value to ``/v1/auth/foo``, will use the path
        ``/v1/auth/foo/login`` to authenticate with Vault. If unspecified, the
        default value "/v1/auth/kubernetes" will be used.

        :schema: IssuerSpecVaultAuthKubernetes#mountPath
        '''
        result = self._values.get("mount_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(self) -> typing.Optional["IssuerSpecVaultAuthKubernetesSecretRef"]:
        '''The required Secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        Use of 'ambient credentials' is not
        supported.

        :schema: IssuerSpecVaultAuthKubernetes#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["IssuerSpecVaultAuthKubernetesSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["IssuerSpecVaultAuthKubernetesServiceAccountRef"]:
        '''A reference to a service account that will be used to request a bound token (also known as "projected token").

        Compared to using "secretRef",
        using this field means that you don't rely on statically bound tokens. To
        use this field, you must configure an RBAC rule to let cert-manager
        request a token.

        :schema: IssuerSpecVaultAuthKubernetes#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["IssuerSpecVaultAuthKubernetesServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVaultAuthKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVaultAuthKubernetesSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecVaultAuthKubernetesSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The required Secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        Use of 'ambient credentials' is not
        supported.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecVaultAuthKubernetesSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd69c31b677638ae6bda333d1772e1e2d2555f59bf4c2e0dccdf006ffb4012da)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecVaultAuthKubernetesSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecVaultAuthKubernetesSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVaultAuthKubernetesSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVaultAuthKubernetesServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences"},
)
class IssuerSpecVaultAuthKubernetesServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A reference to a service account that will be used to request a bound token (also known as "projected token").

        Compared to using "secretRef",
        using this field means that you don't rely on statically bound tokens. To
        use this field, you must configure an RBAC rule to let cert-manager
        request a token.

        :param name: Name of the ServiceAccount used to request a token.
        :param audiences: TokenAudiences is an optional list of extra audiences to include in the token passed to Vault. The default token consisting of the issuer's namespace and name is always included.

        :schema: IssuerSpecVaultAuthKubernetesServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9308e54fac39d2501bd327ba2e44db85ecfa3c29efd8d344d8ceca2f9f1a339d)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the ServiceAccount used to request a token.

        :schema: IssuerSpecVaultAuthKubernetesServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''TokenAudiences is an optional list of extra audiences to include in the token passed to Vault.

        The default token
        consisting of the issuer's namespace and name is always included.

        :schema: IssuerSpecVaultAuthKubernetesServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVaultAuthKubernetesServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVaultAuthTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecVaultAuthTokenSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecVaultAuthTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__191033eb4e56092b96ce87eb804a68718b9f21932a9b8feb31764fbb08fe17ec)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecVaultAuthTokenSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecVaultAuthTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVaultAuthTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVaultCaBundleSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecVaultCaBundleSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a Secret containing a bundle of PEM-encoded CAs to use when verifying the certificate chain presented by Vault when using HTTPS.

        Mutually exclusive with CABundle.
        If neither CABundle nor CABundleSecretRef are defined, the certificate bundle in
        the cert-manager controller container is used to validate the TLS connection.
        If no key for the Secret is specified, cert-manager will default to 'ca.crt'.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecVaultCaBundleSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e4a0a2db2538b6a85c85a979a09f9645254646f9b3554cd43d0970373cede76e)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecVaultCaBundleSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecVaultCaBundleSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVaultCaBundleSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVaultClientCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecVaultClientCertSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a Secret containing a PEM-encoded Client Certificate to use when the Vault server requires mTLS.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecVaultClientCertSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd02dec17c46aeeaebbc4ec59705c6b76f6d93cd830d5a9cf862d05faaa3ae97)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecVaultClientCertSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecVaultClientCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVaultClientCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVaultClientKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecVaultClientKeySecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a Secret containing a PEM-encoded Client Private Key to use when the Vault server requires mTLS.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecVaultClientKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29ccf4df99f1f6844cd22c8c05988541ab11c4d19222662f6be4bf32d1723b3c)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecVaultClientKeySecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecVaultClientKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVaultClientKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVenafi",
    jsii_struct_bases=[],
    name_mapping={"zone": "zone", "cloud": "cloud", "tpp": "tpp"},
)
class IssuerSpecVenafi:
    def __init__(
        self,
        *,
        zone: builtins.str,
        cloud: typing.Optional[typing.Union["IssuerSpecVenafiCloud", typing.Dict[builtins.str, typing.Any]]] = None,
        tpp: typing.Optional[typing.Union["IssuerSpecVenafiTpp", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Venafi configures this issuer to sign certificates using a Venafi TPP or Venafi Cloud policy zone.

        :param zone: Zone is the Venafi Policy Zone to use for this issuer. All requests made to the Venafi platform will be restricted by the named zone policy. This field is required.
        :param cloud: Cloud specifies the Venafi cloud configuration settings. Only one of TPP or Cloud may be specified.
        :param tpp: TPP specifies Trust Protection Platform configuration settings. Only one of TPP or Cloud may be specified.

        :schema: IssuerSpecVenafi
        '''
        if isinstance(cloud, dict):
            cloud = IssuerSpecVenafiCloud(**cloud)
        if isinstance(tpp, dict):
            tpp = IssuerSpecVenafiTpp(**tpp)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41471c5806506574d816a45163907eed7153e50656bf0ea754813c1550ae7be4)
            check_type(argname="argument zone", value=zone, expected_type=type_hints["zone"])
            check_type(argname="argument cloud", value=cloud, expected_type=type_hints["cloud"])
            check_type(argname="argument tpp", value=tpp, expected_type=type_hints["tpp"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "zone": zone,
        }
        if cloud is not None:
            self._values["cloud"] = cloud
        if tpp is not None:
            self._values["tpp"] = tpp

    @builtins.property
    def zone(self) -> builtins.str:
        '''Zone is the Venafi Policy Zone to use for this issuer.

        All requests made to the Venafi platform will be restricted by the named
        zone policy.
        This field is required.

        :schema: IssuerSpecVenafi#zone
        '''
        result = self._values.get("zone")
        assert result is not None, "Required property 'zone' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cloud(self) -> typing.Optional["IssuerSpecVenafiCloud"]:
        '''Cloud specifies the Venafi cloud configuration settings.

        Only one of TPP or Cloud may be specified.

        :schema: IssuerSpecVenafi#cloud
        '''
        result = self._values.get("cloud")
        return typing.cast(typing.Optional["IssuerSpecVenafiCloud"], result)

    @builtins.property
    def tpp(self) -> typing.Optional["IssuerSpecVenafiTpp"]:
        '''TPP specifies Trust Protection Platform configuration settings.

        Only one of TPP or Cloud may be specified.

        :schema: IssuerSpecVenafi#tpp
        '''
        result = self._values.get("tpp")
        return typing.cast(typing.Optional["IssuerSpecVenafiTpp"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVenafi(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVenafiCloud",
    jsii_struct_bases=[],
    name_mapping={"api_token_secret_ref": "apiTokenSecretRef", "url": "url"},
)
class IssuerSpecVenafiCloud:
    def __init__(
        self,
        *,
        api_token_secret_ref: typing.Union["IssuerSpecVenafiCloudApiTokenSecretRef", typing.Dict[builtins.str, typing.Any]],
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Cloud specifies the Venafi cloud configuration settings.

        Only one of TPP or Cloud may be specified.

        :param api_token_secret_ref: APITokenSecretRef is a secret key selector for the Venafi Cloud API token.
        :param url: URL is the base URL for Venafi Cloud. Defaults to "https://api.venafi.cloud/v1". Default: https://api.venafi.cloud/v1".

        :schema: IssuerSpecVenafiCloud
        '''
        if isinstance(api_token_secret_ref, dict):
            api_token_secret_ref = IssuerSpecVenafiCloudApiTokenSecretRef(**api_token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0f6e000b7abffa99f37db8834819dcd3bb8248961720598110b6d36081ca388)
            check_type(argname="argument api_token_secret_ref", value=api_token_secret_ref, expected_type=type_hints["api_token_secret_ref"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_token_secret_ref": api_token_secret_ref,
        }
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def api_token_secret_ref(self) -> "IssuerSpecVenafiCloudApiTokenSecretRef":
        '''APITokenSecretRef is a secret key selector for the Venafi Cloud API token.

        :schema: IssuerSpecVenafiCloud#apiTokenSecretRef
        '''
        result = self._values.get("api_token_secret_ref")
        assert result is not None, "Required property 'api_token_secret_ref' is missing"
        return typing.cast("IssuerSpecVenafiCloudApiTokenSecretRef", result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''URL is the base URL for Venafi Cloud.

        Defaults to "https://api.venafi.cloud/v1".

        :default: https://api.venafi.cloud/v1".

        :schema: IssuerSpecVenafiCloud#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVenafiCloud(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVenafiCloudApiTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecVenafiCloudApiTokenSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''APITokenSecretRef is a secret key selector for the Venafi Cloud API token.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecVenafiCloudApiTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0ecd39f00f0c94da3d96bdb331d210453bb31d98424723feb4cef5b8cfde7884)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecVenafiCloudApiTokenSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecVenafiCloudApiTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVenafiCloudApiTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVenafiTpp",
    jsii_struct_bases=[],
    name_mapping={
        "credentials_ref": "credentialsRef",
        "url": "url",
        "ca_bundle": "caBundle",
        "ca_bundle_secret_ref": "caBundleSecretRef",
    },
)
class IssuerSpecVenafiTpp:
    def __init__(
        self,
        *,
        credentials_ref: typing.Union["IssuerSpecVenafiTppCredentialsRef", typing.Dict[builtins.str, typing.Any]],
        url: builtins.str,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_bundle_secret_ref: typing.Optional[typing.Union["IssuerSpecVenafiTppCaBundleSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''TPP specifies Trust Protection Platform configuration settings.

        Only one of TPP or Cloud may be specified.

        :param credentials_ref: CredentialsRef is a reference to a Secret containing the Venafi TPP API credentials. The secret must contain the key 'access-token' for the Access Token Authentication, or two keys, 'username' and 'password' for the API Keys Authentication.
        :param url: URL is the base URL for the vedsdk endpoint of the Venafi TPP instance, for example: "https://tpp.example.com/vedsdk".
        :param ca_bundle: Base64-encoded bundle of PEM CAs which will be used to validate the certificate chain presented by the TPP server. Only used if using HTTPS; ignored for HTTP. If undefined, the certificate bundle in the cert-manager controller container is used to validate the chain.
        :param ca_bundle_secret_ref: Reference to a Secret containing a base64-encoded bundle of PEM CAs which will be used to validate the certificate chain presented by the TPP server. Only used if using HTTPS; ignored for HTTP. Mutually exclusive with CABundle. If neither CABundle nor CABundleSecretRef is defined, the certificate bundle in the cert-manager controller container is used to validate the TLS connection.

        :schema: IssuerSpecVenafiTpp
        '''
        if isinstance(credentials_ref, dict):
            credentials_ref = IssuerSpecVenafiTppCredentialsRef(**credentials_ref)
        if isinstance(ca_bundle_secret_ref, dict):
            ca_bundle_secret_ref = IssuerSpecVenafiTppCaBundleSecretRef(**ca_bundle_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__34eaf3d8d15be8301d9607c483a2dd9958ce79d1af180e51bd695220d72cc7cc)
            check_type(argname="argument credentials_ref", value=credentials_ref, expected_type=type_hints["credentials_ref"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_bundle_secret_ref", value=ca_bundle_secret_ref, expected_type=type_hints["ca_bundle_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "credentials_ref": credentials_ref,
            "url": url,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_bundle_secret_ref is not None:
            self._values["ca_bundle_secret_ref"] = ca_bundle_secret_ref

    @builtins.property
    def credentials_ref(self) -> "IssuerSpecVenafiTppCredentialsRef":
        '''CredentialsRef is a reference to a Secret containing the Venafi TPP API credentials.

        The secret must contain the key 'access-token' for the Access Token Authentication,
        or two keys, 'username' and 'password' for the API Keys Authentication.

        :schema: IssuerSpecVenafiTpp#credentialsRef
        '''
        result = self._values.get("credentials_ref")
        assert result is not None, "Required property 'credentials_ref' is missing"
        return typing.cast("IssuerSpecVenafiTppCredentialsRef", result)

    @builtins.property
    def url(self) -> builtins.str:
        '''URL is the base URL for the vedsdk endpoint of the Venafi TPP instance, for example: "https://tpp.example.com/vedsdk".

        :schema: IssuerSpecVenafiTpp#url
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''Base64-encoded bundle of PEM CAs which will be used to validate the certificate chain presented by the TPP server.

        Only used if using HTTPS; ignored for HTTP.
        If undefined, the certificate bundle in the cert-manager controller container
        is used to validate the chain.

        :schema: IssuerSpecVenafiTpp#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_bundle_secret_ref(
        self,
    ) -> typing.Optional["IssuerSpecVenafiTppCaBundleSecretRef"]:
        '''Reference to a Secret containing a base64-encoded bundle of PEM CAs which will be used to validate the certificate chain presented by the TPP server.

        Only used if using HTTPS; ignored for HTTP. Mutually exclusive with CABundle.
        If neither CABundle nor CABundleSecretRef is defined, the certificate bundle in
        the cert-manager controller container is used to validate the TLS connection.

        :schema: IssuerSpecVenafiTpp#caBundleSecretRef
        '''
        result = self._values.get("ca_bundle_secret_ref")
        return typing.cast(typing.Optional["IssuerSpecVenafiTppCaBundleSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVenafiTpp(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVenafiTppCaBundleSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "key": "key"},
)
class IssuerSpecVenafiTppCaBundleSecretRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a Secret containing a base64-encoded bundle of PEM CAs which will be used to validate the certificate chain presented by the TPP server.

        Only used if using HTTPS; ignored for HTTP. Mutually exclusive with CABundle.
        If neither CABundle nor CABundleSecretRef is defined, the certificate bundle in
        the cert-manager controller container is used to validate the TLS connection.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.

        :schema: IssuerSpecVenafiTppCaBundleSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ac5433d9f83a8070e92ab6f524f5a848262fbab0127f670c864c4581e9eaf1e6)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if key is not None:
            self._values["key"] = key

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecVenafiTppCaBundleSecretRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be
        required.

        :schema: IssuerSpecVenafiTppCaBundleSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVenafiTppCaBundleSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="iocert-manager.IssuerSpecVenafiTppCredentialsRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class IssuerSpecVenafiTppCredentialsRef:
    def __init__(self, *, name: builtins.str) -> None:
        '''CredentialsRef is a reference to a Secret containing the Venafi TPP API credentials.

        The secret must contain the key 'access-token' for the Access Token Authentication,
        or two keys, 'username' and 'password' for the API Keys Authentication.

        :param name: Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecVenafiTppCredentialsRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aa86795723230eb90c20ee071c8aa5a47c64b4b2b45ff84e5070eb3c6383dafb)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the resource being referred to.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: IssuerSpecVenafiTppCredentialsRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IssuerSpecVenafiTppCredentialsRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "Certificate",
    "CertificateProps",
    "CertificateRequest",
    "CertificateRequestProps",
    "CertificateRequestSpec",
    "CertificateRequestSpecIssuerRef",
    "CertificateRequestSpecUsages",
    "CertificateSpec",
    "CertificateSpecAdditionalOutputFormats",
    "CertificateSpecAdditionalOutputFormatsType",
    "CertificateSpecIssuerRef",
    "CertificateSpecKeystores",
    "CertificateSpecKeystoresJks",
    "CertificateSpecKeystoresJksPasswordSecretRef",
    "CertificateSpecKeystoresPkcs12",
    "CertificateSpecKeystoresPkcs12PasswordSecretRef",
    "CertificateSpecKeystoresPkcs12Profile",
    "CertificateSpecNameConstraints",
    "CertificateSpecNameConstraintsExcluded",
    "CertificateSpecNameConstraintsPermitted",
    "CertificateSpecOtherNames",
    "CertificateSpecPrivateKey",
    "CertificateSpecPrivateKeyAlgorithm",
    "CertificateSpecPrivateKeyEncoding",
    "CertificateSpecPrivateKeyRotationPolicy",
    "CertificateSpecSecretTemplate",
    "CertificateSpecSubject",
    "CertificateSpecUsages",
    "ClusterIssuer",
    "ClusterIssuerProps",
    "ClusterIssuerSpec",
    "ClusterIssuerSpecAcme",
    "ClusterIssuerSpecAcmeExternalAccountBinding",
    "ClusterIssuerSpecAcmeExternalAccountBindingKeyAlgorithm",
    "ClusterIssuerSpecAcmeExternalAccountBindingKeySecretRef",
    "ClusterIssuerSpecAcmePrivateKeySecretRef",
    "ClusterIssuerSpecAcmeSolvers",
    "ClusterIssuerSpecAcmeSolversDns01",
    "ClusterIssuerSpecAcmeSolversDns01AcmeDns",
    "ClusterIssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef",
    "ClusterIssuerSpecAcmeSolversDns01Akamai",
    "ClusterIssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef",
    "ClusterIssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef",
    "ClusterIssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef",
    "ClusterIssuerSpecAcmeSolversDns01AzureDns",
    "ClusterIssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef",
    "ClusterIssuerSpecAcmeSolversDns01AzureDnsEnvironment",
    "ClusterIssuerSpecAcmeSolversDns01AzureDnsManagedIdentity",
    "ClusterIssuerSpecAcmeSolversDns01CloudDns",
    "ClusterIssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef",
    "ClusterIssuerSpecAcmeSolversDns01Cloudflare",
    "ClusterIssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef",
    "ClusterIssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef",
    "ClusterIssuerSpecAcmeSolversDns01CnameStrategy",
    "ClusterIssuerSpecAcmeSolversDns01Digitalocean",
    "ClusterIssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef",
    "ClusterIssuerSpecAcmeSolversDns01Rfc2136",
    "ClusterIssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef",
    "ClusterIssuerSpecAcmeSolversDns01Route53",
    "ClusterIssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef",
    "ClusterIssuerSpecAcmeSolversDns01Route53Auth",
    "ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetes",
    "ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef",
    "ClusterIssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef",
    "ClusterIssuerSpecAcmeSolversDns01Webhook",
    "ClusterIssuerSpecAcmeSolversHttp01",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoute",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls",
    "ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations",
    "ClusterIssuerSpecAcmeSolversHttp01Ingress",
    "ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplate",
    "ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplate",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpec",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls",
    "ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations",
    "ClusterIssuerSpecAcmeSolversSelector",
    "ClusterIssuerSpecCa",
    "ClusterIssuerSpecSelfSigned",
    "ClusterIssuerSpecVault",
    "ClusterIssuerSpecVaultAuth",
    "ClusterIssuerSpecVaultAuthAppRole",
    "ClusterIssuerSpecVaultAuthAppRoleSecretRef",
    "ClusterIssuerSpecVaultAuthClientCertificate",
    "ClusterIssuerSpecVaultAuthKubernetes",
    "ClusterIssuerSpecVaultAuthKubernetesSecretRef",
    "ClusterIssuerSpecVaultAuthKubernetesServiceAccountRef",
    "ClusterIssuerSpecVaultAuthTokenSecretRef",
    "ClusterIssuerSpecVaultCaBundleSecretRef",
    "ClusterIssuerSpecVaultClientCertSecretRef",
    "ClusterIssuerSpecVaultClientKeySecretRef",
    "ClusterIssuerSpecVenafi",
    "ClusterIssuerSpecVenafiCloud",
    "ClusterIssuerSpecVenafiCloudApiTokenSecretRef",
    "ClusterIssuerSpecVenafiTpp",
    "ClusterIssuerSpecVenafiTppCaBundleSecretRef",
    "ClusterIssuerSpecVenafiTppCredentialsRef",
    "Issuer",
    "IssuerProps",
    "IssuerSpec",
    "IssuerSpecAcme",
    "IssuerSpecAcmeExternalAccountBinding",
    "IssuerSpecAcmeExternalAccountBindingKeyAlgorithm",
    "IssuerSpecAcmeExternalAccountBindingKeySecretRef",
    "IssuerSpecAcmePrivateKeySecretRef",
    "IssuerSpecAcmeSolvers",
    "IssuerSpecAcmeSolversDns01",
    "IssuerSpecAcmeSolversDns01AcmeDns",
    "IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef",
    "IssuerSpecAcmeSolversDns01Akamai",
    "IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef",
    "IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef",
    "IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef",
    "IssuerSpecAcmeSolversDns01AzureDns",
    "IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef",
    "IssuerSpecAcmeSolversDns01AzureDnsEnvironment",
    "IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity",
    "IssuerSpecAcmeSolversDns01CloudDns",
    "IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef",
    "IssuerSpecAcmeSolversDns01Cloudflare",
    "IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef",
    "IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef",
    "IssuerSpecAcmeSolversDns01CnameStrategy",
    "IssuerSpecAcmeSolversDns01Digitalocean",
    "IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef",
    "IssuerSpecAcmeSolversDns01Rfc2136",
    "IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef",
    "IssuerSpecAcmeSolversDns01Route53",
    "IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef",
    "IssuerSpecAcmeSolversDns01Route53Auth",
    "IssuerSpecAcmeSolversDns01Route53AuthKubernetes",
    "IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef",
    "IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef",
    "IssuerSpecAcmeSolversDns01Webhook",
    "IssuerSpecAcmeSolversHttp01",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoute",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls",
    "IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations",
    "IssuerSpecAcmeSolversHttp01Ingress",
    "IssuerSpecAcmeSolversHttp01IngressIngressTemplate",
    "IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplate",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls",
    "IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations",
    "IssuerSpecAcmeSolversSelector",
    "IssuerSpecCa",
    "IssuerSpecSelfSigned",
    "IssuerSpecVault",
    "IssuerSpecVaultAuth",
    "IssuerSpecVaultAuthAppRole",
    "IssuerSpecVaultAuthAppRoleSecretRef",
    "IssuerSpecVaultAuthClientCertificate",
    "IssuerSpecVaultAuthKubernetes",
    "IssuerSpecVaultAuthKubernetesSecretRef",
    "IssuerSpecVaultAuthKubernetesServiceAccountRef",
    "IssuerSpecVaultAuthTokenSecretRef",
    "IssuerSpecVaultCaBundleSecretRef",
    "IssuerSpecVaultClientCertSecretRef",
    "IssuerSpecVaultClientKeySecretRef",
    "IssuerSpecVenafi",
    "IssuerSpecVenafiCloud",
    "IssuerSpecVenafiCloudApiTokenSecretRef",
    "IssuerSpecVenafiTpp",
    "IssuerSpecVenafiTppCaBundleSecretRef",
    "IssuerSpecVenafiTppCredentialsRef",
]

publication.publish()

def _typecheckingstub__83eb4f4530b52ea6853e7191f39bd5a69bc44c12fc79ff4293d5c610eaab4318(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[CertificateSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45dc788c1d2b0c9f9222a2fa306cf217f2020644af3fa92be5fa925ad20fa0c3(
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[CertificateSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85bad730ae89d75454fbc0817d7d071091cfa8f7250fd3c08b7acacddb415e25(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[CertificateRequestSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c9252068788769c92948b7c5a29fa8e75a833c80c13e459f19af04e9476a3ad(
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[CertificateRequestSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__852c3e842d58b913717e1498bc2afc1f9e926550814236cafdf93d20eedcbcf7(
    *,
    issuer_ref: typing.Union[CertificateRequestSpecIssuerRef, typing.Dict[builtins.str, typing.Any]],
    request: builtins.str,
    duration: typing.Optional[builtins.str] = None,
    extra: typing.Optional[typing.Mapping[builtins.str, typing.Sequence[builtins.str]]] = None,
    groups: typing.Optional[typing.Sequence[builtins.str]] = None,
    is_ca: typing.Optional[builtins.bool] = None,
    uid: typing.Optional[builtins.str] = None,
    usages: typing.Optional[typing.Sequence[CertificateRequestSpecUsages]] = None,
    username: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a9d227c2e96d30d52fa91c7d0c2454b38e3f73b481889c1995bca89d98a081f(
    *,
    name: builtins.str,
    group: typing.Optional[builtins.str] = None,
    kind: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32dc1d8bfeef97dbd877eaeb718c4dc3768875c6ca7b447e1282f47888feb140(
    *,
    issuer_ref: typing.Union[CertificateSpecIssuerRef, typing.Dict[builtins.str, typing.Any]],
    secret_name: builtins.str,
    additional_output_formats: typing.Optional[typing.Sequence[typing.Union[CertificateSpecAdditionalOutputFormats, typing.Dict[builtins.str, typing.Any]]]] = None,
    common_name: typing.Optional[builtins.str] = None,
    dns_names: typing.Optional[typing.Sequence[builtins.str]] = None,
    duration: typing.Optional[builtins.str] = None,
    email_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
    encode_usages_in_request: typing.Optional[builtins.bool] = None,
    ip_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
    is_ca: typing.Optional[builtins.bool] = None,
    keystores: typing.Optional[typing.Union[CertificateSpecKeystores, typing.Dict[builtins.str, typing.Any]]] = None,
    literal_subject: typing.Optional[builtins.str] = None,
    name_constraints: typing.Optional[typing.Union[CertificateSpecNameConstraints, typing.Dict[builtins.str, typing.Any]]] = None,
    other_names: typing.Optional[typing.Sequence[typing.Union[CertificateSpecOtherNames, typing.Dict[builtins.str, typing.Any]]]] = None,
    private_key: typing.Optional[typing.Union[CertificateSpecPrivateKey, typing.Dict[builtins.str, typing.Any]]] = None,
    renew_before: typing.Optional[builtins.str] = None,
    renew_before_percentage: typing.Optional[jsii.Number] = None,
    revision_history_limit: typing.Optional[jsii.Number] = None,
    secret_template: typing.Optional[typing.Union[CertificateSpecSecretTemplate, typing.Dict[builtins.str, typing.Any]]] = None,
    subject: typing.Optional[typing.Union[CertificateSpecSubject, typing.Dict[builtins.str, typing.Any]]] = None,
    uris: typing.Optional[typing.Sequence[builtins.str]] = None,
    usages: typing.Optional[typing.Sequence[CertificateSpecUsages]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b105d0e0ff4812a7d27236854fdec57381ceb1aebb380c990c0158888686634f(
    *,
    type: CertificateSpecAdditionalOutputFormatsType,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__250ffc36555234fb3774546a78f06060f14ef24da211d902560be0f8f100fb0b(
    *,
    name: builtins.str,
    group: typing.Optional[builtins.str] = None,
    kind: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__304190a06d3e60433de1a2655ea13ece3d452ac5995f8f0e820230f00e479dd2(
    *,
    jks: typing.Optional[typing.Union[CertificateSpecKeystoresJks, typing.Dict[builtins.str, typing.Any]]] = None,
    pkcs12: typing.Optional[typing.Union[CertificateSpecKeystoresPkcs12, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__571b4581314dc6da5154732cbc505ea05f780b18877fbcbc24fd2e2fa8274e62(
    *,
    create: builtins.bool,
    alias: typing.Optional[builtins.str] = None,
    password: typing.Optional[builtins.str] = None,
    password_secret_ref: typing.Optional[typing.Union[CertificateSpecKeystoresJksPasswordSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c705b97f1ec6666fe596694a6020ae107ebdb667b49d9a0e8e70230b3299e82(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5382e8480294729cddd333c0c832e9c632efa49695fb65db41f2232ecd5fb79(
    *,
    create: builtins.bool,
    password: typing.Optional[builtins.str] = None,
    password_secret_ref: typing.Optional[typing.Union[CertificateSpecKeystoresPkcs12PasswordSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    profile: typing.Optional[CertificateSpecKeystoresPkcs12Profile] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20086e6fd1b2e1e2a9457b1cfb63413328de2c314da016e54e9a15a2a0a98681(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e41e90c83f48c5162562588989d0033ac0148b3c79315d65e7db457c8bbb031(
    *,
    critical: typing.Optional[builtins.bool] = None,
    excluded: typing.Optional[typing.Union[CertificateSpecNameConstraintsExcluded, typing.Dict[builtins.str, typing.Any]]] = None,
    permitted: typing.Optional[typing.Union[CertificateSpecNameConstraintsPermitted, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__247066a7c5bf96c4f593b9dd37634902faee41c7166476230de716b98d28c0d1(
    *,
    dns_domains: typing.Optional[typing.Sequence[builtins.str]] = None,
    email_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
    ip_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
    uri_domains: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b620fa1b845e5778a32c4ec4360e6a1161a21008669ce3ff996e0e05cf7c7cf(
    *,
    dns_domains: typing.Optional[typing.Sequence[builtins.str]] = None,
    email_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
    ip_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
    uri_domains: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b7d18e6290327111a832f5aa91793478e1328e8cde647bcafbca8ee289177d21(
    *,
    oid: typing.Optional[builtins.str] = None,
    utf8_value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f5431d5942f0586bccd87c567d6a856c8a29cf36d3c9a803a66e150a76e9bd2(
    *,
    algorithm: typing.Optional[CertificateSpecPrivateKeyAlgorithm] = None,
    encoding: typing.Optional[CertificateSpecPrivateKeyEncoding] = None,
    rotation_policy: typing.Optional[CertificateSpecPrivateKeyRotationPolicy] = None,
    size: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7ae029c4b2099b6a6b000305048c978f265745e3d7c8a735bb3430f37562f6e(
    *,
    annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c09209f0eeb0075bd242146e02938c5900db62860f11fdd3da07883247f6a4de(
    *,
    countries: typing.Optional[typing.Sequence[builtins.str]] = None,
    localities: typing.Optional[typing.Sequence[builtins.str]] = None,
    organizational_units: typing.Optional[typing.Sequence[builtins.str]] = None,
    organizations: typing.Optional[typing.Sequence[builtins.str]] = None,
    postal_codes: typing.Optional[typing.Sequence[builtins.str]] = None,
    provinces: typing.Optional[typing.Sequence[builtins.str]] = None,
    serial_number: typing.Optional[builtins.str] = None,
    street_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f688143e7d718d47dfa1c6527ed261b298a036dc3e9d79a1ec8589369c8281c(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    spec: typing.Union[ClusterIssuerSpec, typing.Dict[builtins.str, typing.Any]],
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__56b0a5615b6f6e250fd651727f2e68a527c0065c23fb695154f60a5def2d3919(
    *,
    spec: typing.Union[ClusterIssuerSpec, typing.Dict[builtins.str, typing.Any]],
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc77bf1e9be3506aa9d0d03ab0aa9d5dfb37f8ecea565109f44e6b9bc2380ac1(
    *,
    acme: typing.Optional[typing.Union[ClusterIssuerSpecAcme, typing.Dict[builtins.str, typing.Any]]] = None,
    ca: typing.Optional[typing.Union[ClusterIssuerSpecCa, typing.Dict[builtins.str, typing.Any]]] = None,
    self_signed: typing.Optional[typing.Union[ClusterIssuerSpecSelfSigned, typing.Dict[builtins.str, typing.Any]]] = None,
    vault: typing.Optional[typing.Union[ClusterIssuerSpecVault, typing.Dict[builtins.str, typing.Any]]] = None,
    venafi: typing.Optional[typing.Union[ClusterIssuerSpecVenafi, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9bb6e0ab2b3fc65f4af6e791c031975f3e851e7b4b71e657cfd39b48d5e56471(
    *,
    private_key_secret_ref: typing.Union[ClusterIssuerSpecAcmePrivateKeySecretRef, typing.Dict[builtins.str, typing.Any]],
    server: builtins.str,
    ca_bundle: typing.Optional[builtins.str] = None,
    disable_account_key_generation: typing.Optional[builtins.bool] = None,
    email: typing.Optional[builtins.str] = None,
    enable_duration_feature: typing.Optional[builtins.bool] = None,
    external_account_binding: typing.Optional[typing.Union[ClusterIssuerSpecAcmeExternalAccountBinding, typing.Dict[builtins.str, typing.Any]]] = None,
    preferred_chain: typing.Optional[builtins.str] = None,
    skip_tls_verify: typing.Optional[builtins.bool] = None,
    solvers: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolvers, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e2935c6f1a7d45dfda458b5e86889b8ad9343015a3529a6f2cec671ca66beb3(
    *,
    key_id: builtins.str,
    key_secret_ref: typing.Union[ClusterIssuerSpecAcmeExternalAccountBindingKeySecretRef, typing.Dict[builtins.str, typing.Any]],
    key_algorithm: typing.Optional[ClusterIssuerSpecAcmeExternalAccountBindingKeyAlgorithm] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f4e4626d5ac0262d944f0cb16d60ac10e6ac0e5d814aa66216e4f964f609f578(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3974e1faf8d29117a715c76c5e5c381d217a8d161627837b76f459c9a16e5088(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc060c86c0f89fe7498815c4eb86864460951b48da15e9c8dc8f95452ea54dd4(
    *,
    dns01: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01, typing.Dict[builtins.str, typing.Any]]] = None,
    http01: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01, typing.Dict[builtins.str, typing.Any]]] = None,
    selector: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b612595a0aa563b9b8554e32cdf5fb945ded1eb683a5df9ea553623395f4d163(
    *,
    acme_dns: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01AcmeDns, typing.Dict[builtins.str, typing.Any]]] = None,
    akamai: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01Akamai, typing.Dict[builtins.str, typing.Any]]] = None,
    azure_dns: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01AzureDns, typing.Dict[builtins.str, typing.Any]]] = None,
    cloud_dns: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01CloudDns, typing.Dict[builtins.str, typing.Any]]] = None,
    cloudflare: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01Cloudflare, typing.Dict[builtins.str, typing.Any]]] = None,
    cname_strategy: typing.Optional[ClusterIssuerSpecAcmeSolversDns01CnameStrategy] = None,
    digitalocean: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01Digitalocean, typing.Dict[builtins.str, typing.Any]]] = None,
    rfc2136: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01Rfc2136, typing.Dict[builtins.str, typing.Any]]] = None,
    route53: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01Route53, typing.Dict[builtins.str, typing.Any]]] = None,
    webhook: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01Webhook, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0d637f7d5025dd316376b0849a5b1572a04a70e733195375657333551accdfd0(
    *,
    account_secret_ref: typing.Union[ClusterIssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef, typing.Dict[builtins.str, typing.Any]],
    host: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a451a0f4e97d245fa4bc818bce8fdcacf04d9ed81975e051d9ea5e5122808b8(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73aff73e5f7753dc89b3dffede8dee52fdb8ef5985cec4685d968bf538f0f25c(
    *,
    access_token_secret_ref: typing.Union[ClusterIssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef, typing.Dict[builtins.str, typing.Any]],
    client_secret_secret_ref: typing.Union[ClusterIssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef, typing.Dict[builtins.str, typing.Any]],
    client_token_secret_ref: typing.Union[ClusterIssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef, typing.Dict[builtins.str, typing.Any]],
    service_consumer_domain: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e9b3a0c78a6697d24b27eebb4bfc51b1c082d0f75586f04a4bfaacf0990a4c9(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c9449b86bfadea928ab7383791d045c4381eba25b621d3c52276ae599c04aec(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__10d17f7555b9e576a8009d2d295feca0686c198e5817fbf9f1fef93dfce63500(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__726c86548a8d5db296cbacbcaa585df8262700a8dc958218a21e291dab7039a3(
    *,
    resource_group_name: builtins.str,
    subscription_id: builtins.str,
    client_id: typing.Optional[builtins.str] = None,
    client_secret_secret_ref: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    environment: typing.Optional[ClusterIssuerSpecAcmeSolversDns01AzureDnsEnvironment] = None,
    hosted_zone_name: typing.Optional[builtins.str] = None,
    managed_identity: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01AzureDnsManagedIdentity, typing.Dict[builtins.str, typing.Any]]] = None,
    tenant_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__115eee6232fb1e4bf25695990ca5974657f931b9f001cf8b0187af597e2d1480(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__94962ddf89582cc70f23e6fcaa0372658001cb835efa234108d72136614ccaed(
    *,
    client_id: typing.Optional[builtins.str] = None,
    resource_id: typing.Optional[builtins.str] = None,
    tenant_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a06967cfc9512cd69a94046eed190fb959155888c55cf2473c5642aebbc1a2b8(
    *,
    project: builtins.str,
    hosted_zone_name: typing.Optional[builtins.str] = None,
    service_account_secret_ref: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8924894c731b8b98b6dba249316da66bf98a0be9b2fbc9e74f3ba37d597845da(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aa898215d4c5b25a121bb5205eea5f61c2ea7b2fd097cff6c34937aa949eca04(
    *,
    api_key_secret_ref: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    api_token_secret_ref: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    email: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3f46b2ef766268f591a1866a4ebf73925a168a4519dbfbc4cb0fbcbc1722bb40(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e47a19162e21ce9038753737b126298a8a0b85334c0be78de794e8861a7b895(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eaf214b6c82213ce7f12909fad81501029c7b7d4ec0b9b97439777458d79dc26(
    *,
    token_secret_ref: typing.Union[ClusterIssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce4d45e749f2d41ccaa09e09fa5c55539e75c1842b4749a73bc4f050a70f6928(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b002872d6a7a301b7e43c38e303b1a62feb22f38bb20d143771af205e5c698a(
    *,
    nameserver: builtins.str,
    tsig_algorithm: typing.Optional[builtins.str] = None,
    tsig_key_name: typing.Optional[builtins.str] = None,
    tsig_secret_secret_ref: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2eb933161206126e0e029871bfd1f7979f513e14673ca763c3c1f3e00142977(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e396d25f4ccc9637d1aba8a68be65d4313753e7ebdfdf61b81189f29cee89e4(
    *,
    access_key_id: typing.Optional[builtins.str] = None,
    access_key_id_secret_ref: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    auth: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01Route53Auth, typing.Dict[builtins.str, typing.Any]]] = None,
    hosted_zone_id: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
    role: typing.Optional[builtins.str] = None,
    secret_access_key_secret_ref: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3bbd8a7a4c2caed529e0b14309985b9d6f65054ad2c8cafa9bec9c93120528f0(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__182f7e38cdaa741af9edef7a4fff3e98e7f5e04f5a9e6cd310703c3923c9b655(
    *,
    kubernetes: typing.Union[ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetes, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0eb5a6c0f8248c867bbf5d8b1e6492aac10c7101018bf4fb8ca302bde1e93ebd(
    *,
    service_account_ref: typing.Union[ClusterIssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1fff29f97a478a785ada627e37581c3215798c74d9225250412b704b47748adc(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a38f57416ef270f5a78042177e2b680c3eb55f68ed309827126e486b54b77032(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f6b9f64d76edfd1157da00efbca252358d53658a0f70cf2da43b5b73a428e516(
    *,
    group_name: builtins.str,
    solver_name: builtins.str,
    config: typing.Any = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45fed7313bfd75672214658f3692015852cdd4f5812fa9ab5aaab7ce3ac6abce(
    *,
    gateway_http_route: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoute, typing.Dict[builtins.str, typing.Any]]] = None,
    ingress: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01Ingress, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88659644f46c5f99a1c86919d81467cec4faee2f8df7f02554b2ca5af8999052(
    *,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    parent_refs: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs, typing.Dict[builtins.str, typing.Any]]]] = None,
    pod_template: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate, typing.Dict[builtins.str, typing.Any]]] = None,
    service_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c9d8743f5ea47696322c701c19e75d9eb96649c4b152798d5876ebe2ab9304b(
    *,
    name: builtins.str,
    group: typing.Optional[builtins.str] = None,
    kind: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
    port: typing.Optional[jsii.Number] = None,
    section_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__783efb24173c98d4a014f307762e83928681e3b20be92bb381513457cbcc1be4(
    *,
    metadata: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee6b216e647b6e2352c04231149010c88246ae5229a99ad4c070ed0cca605199(
    *,
    annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35961b9eb8906b2d2c4ea7f28774136be7b2cacdd96d517659d6f88f94f499dc(
    *,
    affinity: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
    image_pull_secrets: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets, typing.Dict[builtins.str, typing.Any]]]] = None,
    node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    priority_class_name: typing.Optional[builtins.str] = None,
    security_context: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_name: typing.Optional[builtins.str] = None,
    tolerations: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2476f746dd48b774e046e65665b5e02cef90642293423f8f87b9be5a5a26d7c4(
    *,
    node_affinity: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_affinity: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_anti_affinity: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b8171c6611daff19eed0db6a67f8778ba0074152778ba32486e9060d5bf0e16(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6af9ba061560234cdcd1c125df303afea6d38f9c2643f257327c43ecac7ba526(
    *,
    preference: typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference, typing.Dict[builtins.str, typing.Any]],
    weight: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86c6a1dede316b93ef56bb1badc005559bbe998a647fe3b3f1f893976154c9cd(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_fields: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__92e96d8751817bf072f93ec506de98d281952674f234caaa21a19210b1908fb3(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3f67e8864cd715cfff154c89d57b17a87f3fed27aa9add0fe7ace8a9760f7055(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fcd1fe9417206b4422fe213aa77dd0f46ff2beb1d6f7f5f73564fa14f58ff409(
    *,
    node_selector_terms: typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a52c270195aa28aaeb4678cc56e569c8780ae0d99ffe522f96fe5baa6f0d9775(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_fields: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0c1294338dc92d4289f22c102929658e57501ff1da1bc5197a31cf499216728(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9970b49239e88a60482e980a8cd26a57412afb88dd327877b8043b100ec1cef3(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__adbd9d53aa830a7b9fbe8efce27a6d826e7827bfe37e6cd80c396d4037cc53b4(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7168c3a1cbd26e28570cd65cfce1cbc18a89c06d510b851e1a4ff768be57091(
    *,
    pod_affinity_term: typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm, typing.Dict[builtins.str, typing.Any]],
    weight: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__978f5cd61681eeaf17538f83d1ac222b3b828048d9c3b12ebe8d54ac69703e35(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc78dc74fd53a58831cc40070fe22834ba8ac994719faddfcb938e93820b545d(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20b0a3b4f6ff147a4fef103ea677aaa44ba007fb2c4f3e6d4ffc77214fd708c8(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7ffd280994dbef38c5a78183776be2782c9f3235702a2ea447424df82d3d229(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eec9ff9904833d57461a79a3048d9e475d53da194932f47a1ec30b6580dc4662(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b958e73a151d8663f58e65f4a1a85188031259055252bf85d42652ec424e304c(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff56d2e90ef2477a07cd8e189c6106fd966cc625b905245f658d1d59ac0843fa(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f6a39fbc397d8c9cfe4424570ce05458917b87b5ee8ecdc49c2cafb54f465b0(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5bf574661c7b55c2f0b2c69b96050bd01206493dc9d2a7529d729a4e681c32a1(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fdefe5a9c76dfa76dcebc24be03c293868e02cbb0daf0ad04cd54eb5333d07ae(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b0c80fecb5420c9672db1b2dcdd247fad8af66d44f8da024706faadf0200a72f(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__53a2997a359adbfe6602666a4c623602d8c436799d0cf02377f6050e0f3f0cd1(
    *,
    pod_affinity_term: typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm, typing.Dict[builtins.str, typing.Any]],
    weight: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a653e9d14401afd5215ec04827cd64b465b488875c87e7df8cd8fe989983b34(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ef82c8f1d943a9b522fde523ba68265235c3c38f74f933357f70752c898c2ae(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d390a6fe0a058186061a85f48a8747c7b1e897889205a325dd80fc1cfeca711(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a5de2d23344e620e526ad113aa2e91d78ff6342b785c039cc7ecbd6cee3f20d(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b44468eb27560277471aef7958fd02e3f8bb43fa66cd088ea4d54f7a2405741(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ef05fd52779302a037edd766860d2ada54606d5480e30dc14a2d608309784ae(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__922a4bda926ac2288c8a665d1de6b49c45cd6b49fd5cee91415d620291446ce5(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3624b8580e43c267f0ca660a8384c3a3b1b431f5e57316c4b3e7ae29d226a4b8(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08de91c5d00c89cba34c53ca1c21fccd969a8a66c1787d0ce4689d8482a8577b(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b470fd0f4e5b7a22a2711d813fbc59824ad95ab81226d8982371341f141ad063(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4d881ebf21caad87893689c0f054678a07e63b52512b7665af1255c35c91a55(
    *,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__debea53128a69da47218cb1df33d84cd46e8b37ce5a2b5087cb56576aa478fdb(
    *,
    fs_group: typing.Optional[jsii.Number] = None,
    fs_group_change_policy: typing.Optional[builtins.str] = None,
    run_as_group: typing.Optional[jsii.Number] = None,
    run_as_non_root: typing.Optional[builtins.bool] = None,
    run_as_user: typing.Optional[jsii.Number] = None,
    seccomp_profile: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile, typing.Dict[builtins.str, typing.Any]]] = None,
    se_linux_options: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
    sysctls: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af86ab2d62edef9e01107cf38b3f976db64ac316fdcfb5b201f4a2883b0a7fd3(
    *,
    level: typing.Optional[builtins.str] = None,
    role: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    user: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9017b2de35bded1cf84d1b3c5303254f546be827c465e49d160d21c625c671a3(
    *,
    type: builtins.str,
    localhost_profile: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__148191a61f7c4554990dcae07ef979e9810dd461f608dce33254640d25475b49(
    *,
    name: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f52d399b815cad81d8dbe3175983c4bd6d8183282a32c799f0ec22a7fc01ce8a(
    *,
    effect: typing.Optional[builtins.str] = None,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    toleration_seconds: typing.Optional[jsii.Number] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a720dde644fba8c669808252bfdddf246b1094bdd471540372e5a5a294889f03(
    *,
    class_: typing.Optional[builtins.str] = None,
    ingress_class_name: typing.Optional[builtins.str] = None,
    ingress_template: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplate, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    pod_template: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplate, typing.Dict[builtins.str, typing.Any]]] = None,
    service_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c63fcac5c407168aabeae72c1a52b078dc5b17ff09dfedd6221987d352fe6b18(
    *,
    metadata: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__507f575ac6ba37a1d3398c82a410ebbda5d3ea99a8da7b15d8627c913c9e7f0c(
    *,
    annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d90302ec2794d87360f5d2508bcfdbdf7f220da08fe703d46d79b5c9b8dfb1a4(
    *,
    metadata: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3541848f3d4ba60cfd964fe9b510eb398fe1b307ad60a6bd049af5dfcaa41a96(
    *,
    annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4082788f85069495db77b430f60b9d3e1dbf86e381483a94cfe1baf2026fe9eb(
    *,
    affinity: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
    image_pull_secrets: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets, typing.Dict[builtins.str, typing.Any]]]] = None,
    node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    priority_class_name: typing.Optional[builtins.str] = None,
    security_context: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_name: typing.Optional[builtins.str] = None,
    tolerations: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a2aaf1a37a5bb08e5aea04b27b2325d057eeff195984cc4f8b610da647f3cb6(
    *,
    node_affinity: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_affinity: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_anti_affinity: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de3b6cdecbd7ff31a805ddbf09ac1f0a78e29d5d13f884a97d9559784d9322b7(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c4b9a725821038131fc840c0f515c0c06d807317bfea79009457d6f879f9917(
    *,
    preference: typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference, typing.Dict[builtins.str, typing.Any]],
    weight: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8ab675b045fcce43974cf0b13aaca07a8cc0e59d3ad444131dca6290dc433a4(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_fields: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__90aba9d4794e2c06ea1672b07d00ada32e49cf685153ff7effd35a9f8165dd59(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd86516d5340b0d5eaf8dc0d3f0ef77bdc81fedcb143be0067a32d3e06d261ee(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b7897a3e72bba9f371616afc9be2c4cc6eaf7f3822ffe976730db1dda9b3d34b(
    *,
    node_selector_terms: typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c39be703080f8b3c9aa6769cda1c13621e6a6bada7cec7c49a1f0f9e71f1c71(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_fields: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c1f05a20f8d0cda4a85f74170f5268b0ae9cdfea1b5730cdd2a2adc0a79d0e4(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9781e3bdc4b9e774cb47302c2f3f501df617e4e9874dd80857d6e3918e25210(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d62c1e77f851045817786d440dc82b46b009f14ee02d0f01f216a77433037444(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__baec54efda724a7864b1f53a11538e8e16c1d27722bed5c970fc9329b5ca94f8(
    *,
    pod_affinity_term: typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm, typing.Dict[builtins.str, typing.Any]],
    weight: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c443e39a0ee5185fa8c2b58f988c0d9495fd49d0b5719b913e3b2ff9f4fa597b(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7590226e56e087ad8b333afc50eee96594768d8dc71d20bc02a1d2e6b56c1b4a(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d7106b63193204178633e1c79e70330d5f44f34dbfb73cb47fc6524d976b9db(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2aa0a6444a0153bef2e9873fb7a3aa7d9477833bc8834494d924f3576b6be75b(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad9287c3b4a95fbd7a5c9c49cca49b8998e904aa7c1f2062d2b257626754d393(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__15330d752d39dc7168fb6668f6dc7efe43ae89cded48a41a660180f7e9e313db(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83f71e848ec163a209589fdc4a742c3880d1bf5d805ead5eaa9baa8c80428fc4(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8d17819cd2fa1c2e9cdac972bc34323e28d9fd699e084243b456e0aa163f267(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9466cfe9b51274395b80f88d30f8f4749bf3b4d22faa47d63b3e7beb9e0b7c8e(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__782786e8e2318891f61eac5ecbfb5c9a671b77b6b497fdb0456760353f8f73ab(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17d6a184cf4954ddb83b6eef8e524250ef279231baffdd3fee910b27f79115d6(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6eaefd0094fce1fd892af2ef8e1e98566ce3c5409ced57cdbe2894e135dd51f1(
    *,
    pod_affinity_term: typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm, typing.Dict[builtins.str, typing.Any]],
    weight: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__225dd50b57808ae80182044235c9daf23d6adca99fd986cce600e8c795004e24(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__011346a5dc8fa9c9d96eafbb4188de1f9c13f02b671b0a1dcac2d395e97e46aa(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8663aede452db48324b0bada63b5a395703f7eba782cb78945f95b31df8f3625(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a5e232294189661f38770ae7309891a436526ada2baac324a9f26747cd085d1a(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23cbef0f7e129b1edf245ca9e65f86288a29675718d84ae2144411a71fa18047(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e9216e2c43794490561b9a32b84439ef41d6e3d6e3b6dc5d78ca0a597d389b7(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e4c9785d8a6cd06c780e1a81e13ec13678fb25a443967198e39ef9916b63c59(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__104a293a48255adddcbccdddb08e2b794e3e018f832c5d2d9d8e59d6bf36aba9(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e1ab19a77ea7f3551b883e2df8275f26fd318f38ce8aabd8dcf3ad0fc484b2ee(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a17bf8f376c721c1add602f012d4fcba9d221d6c4c12b620e1f51ef889c9cfac(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f6075c7872d9ff59615dd53aa961d600e79e7c3dcc8e73f89e8fee208d78d77(
    *,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ffb1afb4835a5efd059bc76baeb9bc02e4bae8ca502e02946bc91211902a5da(
    *,
    fs_group: typing.Optional[jsii.Number] = None,
    fs_group_change_policy: typing.Optional[builtins.str] = None,
    run_as_group: typing.Optional[jsii.Number] = None,
    run_as_non_root: typing.Optional[builtins.bool] = None,
    run_as_user: typing.Optional[jsii.Number] = None,
    seccomp_profile: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile, typing.Dict[builtins.str, typing.Any]]] = None,
    se_linux_options: typing.Optional[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
    sysctls: typing.Optional[typing.Sequence[typing.Union[ClusterIssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f61841e474a9b9b68e1ae3ea6c4920f8a8ba29f9281f5da5ab213bfe93bacbf9(
    *,
    level: typing.Optional[builtins.str] = None,
    role: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    user: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71fff328e189b6924e9815d9573b6e0c1b18d1553df2750dac7280a7ed43b052(
    *,
    type: builtins.str,
    localhost_profile: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2d921a119757411f575bee6ab134367ae51e2feda9914f5469a296a169f8dae(
    *,
    name: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4831c350ffe6e8a16e9604d414cc2ffd01407b72140ef576e027ec6e3acaff38(
    *,
    effect: typing.Optional[builtins.str] = None,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    toleration_seconds: typing.Optional[jsii.Number] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc111234004d232ec242a505a4bed40066566c41c934f43c0684db4f29472731(
    *,
    dns_names: typing.Optional[typing.Sequence[builtins.str]] = None,
    dns_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9af815cd0fdbf0b2662c9025f1e4f18b62f8e94c19f4803d506aacfff4d104fe(
    *,
    secret_name: builtins.str,
    crl_distribution_points: typing.Optional[typing.Sequence[builtins.str]] = None,
    issuing_certificate_ur_ls: typing.Optional[typing.Sequence[builtins.str]] = None,
    ocsp_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0bccffbd8bfe34f0b9b1ada81ac7f8da01d1a247d899de15f51ab5d57f71e63(
    *,
    crl_distribution_points: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a84f5ea59776c4b649dbea8f3ffd041fdda50f45b0bfeb7043c1c2852b6f21d(
    *,
    auth: typing.Union[ClusterIssuerSpecVaultAuth, typing.Dict[builtins.str, typing.Any]],
    path: builtins.str,
    server: builtins.str,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_bundle_secret_ref: typing.Optional[typing.Union[ClusterIssuerSpecVaultCaBundleSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    client_cert_secret_ref: typing.Optional[typing.Union[ClusterIssuerSpecVaultClientCertSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    client_key_secret_ref: typing.Optional[typing.Union[ClusterIssuerSpecVaultClientKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fffec414792bfc20839a29402537ecbb3ad8dac2e8bb27b8640dba9c0e39e41b(
    *,
    app_role: typing.Optional[typing.Union[ClusterIssuerSpecVaultAuthAppRole, typing.Dict[builtins.str, typing.Any]]] = None,
    client_certificate: typing.Optional[typing.Union[ClusterIssuerSpecVaultAuthClientCertificate, typing.Dict[builtins.str, typing.Any]]] = None,
    kubernetes: typing.Optional[typing.Union[ClusterIssuerSpecVaultAuthKubernetes, typing.Dict[builtins.str, typing.Any]]] = None,
    token_secret_ref: typing.Optional[typing.Union[ClusterIssuerSpecVaultAuthTokenSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__10962d9ccc2d2117c8284e8f86a6932786f05248ee0ef02e872460ebb0e2766a(
    *,
    path: builtins.str,
    role_id: builtins.str,
    secret_ref: typing.Union[ClusterIssuerSpecVaultAuthAppRoleSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f61a7726d72737ec3407c077887e2d42c296773c312ae875e20c46fea5c183c(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b5d7bf92617a8272153fd0f7e09828f982d88f1edb5ccb7443b7e3c61ee9242(
    *,
    mount_path: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    secret_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b057a2f4f871c50be59887dce41fa0081c910021592c34995715cfc8a2ebba54(
    *,
    role: builtins.str,
    mount_path: typing.Optional[builtins.str] = None,
    secret_ref: typing.Optional[typing.Union[ClusterIssuerSpecVaultAuthKubernetesSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_ref: typing.Optional[typing.Union[ClusterIssuerSpecVaultAuthKubernetesServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b7e8911fbe05841c91efed37cf0283688f60653b757f587aff54ad069bfa7fa(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d61a222bfa7b639938bfda529bac99a51aee0bdf8edbe944502a2ef26d2ebd1(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4985f2766828e51bd0b0f04d3da7d34a6c26080c8f2ef4056f4b385e3712a400(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__047a84475c656884a2dae0a4b7f148156de6c86bbd8aa0bd513f4e001abedc15(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7b90518096b91a05eaadff4db84596d62a493f61e7b4b9ee2638468a72aa9875(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e1804c48c9d9612d72ef5983ad2e2bbbefc37bdc8ba41e187fd7464a846213c(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__876346ead32b143589ade8495ee6c7afaf4b96d31860eb256982004a43ec6866(
    *,
    zone: builtins.str,
    cloud: typing.Optional[typing.Union[ClusterIssuerSpecVenafiCloud, typing.Dict[builtins.str, typing.Any]]] = None,
    tpp: typing.Optional[typing.Union[ClusterIssuerSpecVenafiTpp, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__199580c7a64bf39b6fa7e0a065a62fd461327e949f005cf1f9d622011f6071af(
    *,
    api_token_secret_ref: typing.Union[ClusterIssuerSpecVenafiCloudApiTokenSecretRef, typing.Dict[builtins.str, typing.Any]],
    url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f1ac43ee123aba3d19fa5669836ebbb4e0ecaa342cb2bd7726867e8e9001a126(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc6ef1f9e6227b439ca0d1f316d72d2f48e63ae6d665574139243348f0367573(
    *,
    credentials_ref: typing.Union[ClusterIssuerSpecVenafiTppCredentialsRef, typing.Dict[builtins.str, typing.Any]],
    url: builtins.str,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_bundle_secret_ref: typing.Optional[typing.Union[ClusterIssuerSpecVenafiTppCaBundleSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ebed1fb66852c565e0f6540902636134f50a004d172add9c0d1a42aad50c3cd(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b85404e9798b694950cabde3354acc96dd7ddbf574c07a4886d3fb307193cb4(
    *,
    name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a9f9f3b75216e6d5d6593b8544c53a9f2cfe18ca5f405a59ae6fec870e49fc21(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    spec: typing.Union[IssuerSpec, typing.Dict[builtins.str, typing.Any]],
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd822a90321c72917d572dc83c80fe5a543994d1085bd90f367feae334591c12(
    *,
    spec: typing.Union[IssuerSpec, typing.Dict[builtins.str, typing.Any]],
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5785a20597cfe6a55d2c1c8126933ca1fd315ac00a5069cdab3a42f315aee901(
    *,
    acme: typing.Optional[typing.Union[IssuerSpecAcme, typing.Dict[builtins.str, typing.Any]]] = None,
    ca: typing.Optional[typing.Union[IssuerSpecCa, typing.Dict[builtins.str, typing.Any]]] = None,
    self_signed: typing.Optional[typing.Union[IssuerSpecSelfSigned, typing.Dict[builtins.str, typing.Any]]] = None,
    vault: typing.Optional[typing.Union[IssuerSpecVault, typing.Dict[builtins.str, typing.Any]]] = None,
    venafi: typing.Optional[typing.Union[IssuerSpecVenafi, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2cb898b7ba7bab90e6034e33ab7cf089f8cd02b46dd1b6e913714a63a5a8a1ad(
    *,
    private_key_secret_ref: typing.Union[IssuerSpecAcmePrivateKeySecretRef, typing.Dict[builtins.str, typing.Any]],
    server: builtins.str,
    ca_bundle: typing.Optional[builtins.str] = None,
    disable_account_key_generation: typing.Optional[builtins.bool] = None,
    email: typing.Optional[builtins.str] = None,
    enable_duration_feature: typing.Optional[builtins.bool] = None,
    external_account_binding: typing.Optional[typing.Union[IssuerSpecAcmeExternalAccountBinding, typing.Dict[builtins.str, typing.Any]]] = None,
    preferred_chain: typing.Optional[builtins.str] = None,
    skip_tls_verify: typing.Optional[builtins.bool] = None,
    solvers: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolvers, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__149f4a3e8a26e291f2acf9648915c32e9ea0694c591c3d982c5ff3759a372ff0(
    *,
    key_id: builtins.str,
    key_secret_ref: typing.Union[IssuerSpecAcmeExternalAccountBindingKeySecretRef, typing.Dict[builtins.str, typing.Any]],
    key_algorithm: typing.Optional[IssuerSpecAcmeExternalAccountBindingKeyAlgorithm] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7b25a561840cf943a890f1a8ee1e309316c78716150294a1685e80d88392167e(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__21543d785870011596c840834bc59b65f2a5c5540a5d688a20aa70861795e60b(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f0523c38698d0ee5320f4080a0458bd6011f230a35d3a577a4018d9439a4921(
    *,
    dns01: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01, typing.Dict[builtins.str, typing.Any]]] = None,
    http01: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01, typing.Dict[builtins.str, typing.Any]]] = None,
    selector: typing.Optional[typing.Union[IssuerSpecAcmeSolversSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64ff2487915507a712b7b0f2db7ae7a6199871a213585881524c0e9fca195853(
    *,
    acme_dns: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01AcmeDns, typing.Dict[builtins.str, typing.Any]]] = None,
    akamai: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01Akamai, typing.Dict[builtins.str, typing.Any]]] = None,
    azure_dns: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01AzureDns, typing.Dict[builtins.str, typing.Any]]] = None,
    cloud_dns: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01CloudDns, typing.Dict[builtins.str, typing.Any]]] = None,
    cloudflare: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01Cloudflare, typing.Dict[builtins.str, typing.Any]]] = None,
    cname_strategy: typing.Optional[IssuerSpecAcmeSolversDns01CnameStrategy] = None,
    digitalocean: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01Digitalocean, typing.Dict[builtins.str, typing.Any]]] = None,
    rfc2136: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01Rfc2136, typing.Dict[builtins.str, typing.Any]]] = None,
    route53: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01Route53, typing.Dict[builtins.str, typing.Any]]] = None,
    webhook: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01Webhook, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b8945838123f7229621182c22d672ce571304bf831fc09f71e3f6cf37cdea3b2(
    *,
    account_secret_ref: typing.Union[IssuerSpecAcmeSolversDns01AcmeDnsAccountSecretRef, typing.Dict[builtins.str, typing.Any]],
    host: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da6821fae3a20e0a9fec8dce2d8b5a50a8c098e10fcf4a2ba714c18aedbe8416(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e149e172532ab5c05466e9e94df4608e44ecc867ccc43a8936aba7f66ddbf79(
    *,
    access_token_secret_ref: typing.Union[IssuerSpecAcmeSolversDns01AkamaiAccessTokenSecretRef, typing.Dict[builtins.str, typing.Any]],
    client_secret_secret_ref: typing.Union[IssuerSpecAcmeSolversDns01AkamaiClientSecretSecretRef, typing.Dict[builtins.str, typing.Any]],
    client_token_secret_ref: typing.Union[IssuerSpecAcmeSolversDns01AkamaiClientTokenSecretRef, typing.Dict[builtins.str, typing.Any]],
    service_consumer_domain: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__81809c1b25e7aa59da1601912118f405118772afc4924f0c03b672ccad6c16f6(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a362917d6882faae29084c4254a90c7baa93f4691e66bbd5bdb51ef7d42ec02e(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da946514a1e11e5595113d94deee291e52e7b1687af9a48ba21065d4e7ebf4d4(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bad043d89217aad4f9aad94a72a65b2a8086e2d669074888f55a7c4c25fe62b4(
    *,
    resource_group_name: builtins.str,
    subscription_id: builtins.str,
    client_id: typing.Optional[builtins.str] = None,
    client_secret_secret_ref: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01AzureDnsClientSecretSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    environment: typing.Optional[IssuerSpecAcmeSolversDns01AzureDnsEnvironment] = None,
    hosted_zone_name: typing.Optional[builtins.str] = None,
    managed_identity: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01AzureDnsManagedIdentity, typing.Dict[builtins.str, typing.Any]]] = None,
    tenant_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b23afb300c49b2b2394174efde56547718791d726a7d72202e811211706f4d3(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab6817c21007661949dd13f6c539c59dad5efa42b009fb693fc5a527fb948cef(
    *,
    client_id: typing.Optional[builtins.str] = None,
    resource_id: typing.Optional[builtins.str] = None,
    tenant_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eca5bd7a96840d02dbfb643408ada857d1cc2325bebfa5ef4121382228f578e7(
    *,
    project: builtins.str,
    hosted_zone_name: typing.Optional[builtins.str] = None,
    service_account_secret_ref: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01CloudDnsServiceAccountSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5aae493aafb82a17189f7b1276db6e8cc246b65f009311dc5cb4504f8aa933a2(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__032e0836bdbbc3d7675ed1dcf336b375d189f7a3b88e93f9da6111d6c96d1566(
    *,
    api_key_secret_ref: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01CloudflareApiKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    api_token_secret_ref: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01CloudflareApiTokenSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    email: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__331f8d356453e4ee390d77e9697b2ba85d66bb612830aac61ab1fca35c9160d4(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__80235029e6947ed91ef8492ebe7247d193719ff3f992606c47423d64b8ae6d88(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68ba79130f363f4bfe1e7fd9eb299c7a1176cd97aee060aad4e12adf022f3034(
    *,
    token_secret_ref: typing.Union[IssuerSpecAcmeSolversDns01DigitaloceanTokenSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__21be24f72251f2c01dc6697dc55466348220a65c50b2e65fd1bf56a2f67bf015(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f185a423ff293541c4fbfc259e8613e1490e77ee049c177550865250a767457(
    *,
    nameserver: builtins.str,
    tsig_algorithm: typing.Optional[builtins.str] = None,
    tsig_key_name: typing.Optional[builtins.str] = None,
    tsig_secret_secret_ref: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01Rfc2136TsigSecretSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f5c81ed304443fbf966447a43723db20d7ebc6990d2feb73299b662f3157403(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf01c5d5fc83dfa7e7314e95f234907e657c29a32af89b946028c3c927b91656(
    *,
    access_key_id: typing.Optional[builtins.str] = None,
    access_key_id_secret_ref: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01Route53AccessKeyIdSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    auth: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01Route53Auth, typing.Dict[builtins.str, typing.Any]]] = None,
    hosted_zone_id: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
    role: typing.Optional[builtins.str] = None,
    secret_access_key_secret_ref: typing.Optional[typing.Union[IssuerSpecAcmeSolversDns01Route53SecretAccessKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__edd58f1483cb70a3ef543f1c817660cb1c3ca2bf393f94f59d035db152dfb91b(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52bfe6172bd352db7d57db701c800c85ea670ac0836d2579df4bd8b96b1374ad(
    *,
    kubernetes: typing.Union[IssuerSpecAcmeSolversDns01Route53AuthKubernetes, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__260be20f67e778281bcfc1f338ca6e843c457030b60c8c83bcaebb96ca426df2(
    *,
    service_account_ref: typing.Union[IssuerSpecAcmeSolversDns01Route53AuthKubernetesServiceAccountRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__96f8f055b6a88f39fc8999a8a4f169b1d7f1c7df1de1de5b2eab697f5b53e4f4(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f42e61abb4eb5b0c56df23dff7c88faafddc07495bb67281d8a4a094df1eab4f(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__27324d34c2d74899335664b8f69d21c8cdeffc3a38db0f99db2cac90149a6e87(
    *,
    group_name: builtins.str,
    solver_name: builtins.str,
    config: typing.Any = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3aafb9438fec2fdf63fd881c9e96858264a616864bac7381200e92024347b456(
    *,
    gateway_http_route: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoute, typing.Dict[builtins.str, typing.Any]]] = None,
    ingress: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01Ingress, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01c6fa97afc7115093037fa1ee58039db5322745602af262264ec0712d240cb5(
    *,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    parent_refs: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRouteParentRefs, typing.Dict[builtins.str, typing.Any]]]] = None,
    pod_template: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplate, typing.Dict[builtins.str, typing.Any]]] = None,
    service_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4605df1924b14afa961f4b7013e4f8015f77f1b5fbb0deaa3998ffac25fbfd28(
    *,
    name: builtins.str,
    group: typing.Optional[builtins.str] = None,
    kind: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
    port: typing.Optional[jsii.Number] = None,
    section_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc37a43be420c152ee18fecd16af838853044711792db026fbbbcec28575dbf7(
    *,
    metadata: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cc9f7ec2da345065af36a17748de295da93d476c83fb0d25aef20dbf77496bce(
    *,
    annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2cfaafd225eb29c244bb16061edf044aaa795312361c5abf24090484faf198f6(
    *,
    affinity: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
    image_pull_secrets: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecImagePullSecrets, typing.Dict[builtins.str, typing.Any]]]] = None,
    node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    priority_class_name: typing.Optional[builtins.str] = None,
    security_context: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContext, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_name: typing.Optional[builtins.str] = None,
    tolerations: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecTolerations, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e960e38cf4fcb20355989b6b48d85c68326dfabdedd9920ae952b328f7933d4(
    *,
    node_affinity: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_affinity: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_anti_affinity: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e5d71b50d85cf749ebde0354afed9c5a74a5e818dfc4731923f6b2bbddcbf21(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a10e2bf918d041c428d585692b846f49427fb9b697058e18942918167f710514(
    *,
    preference: typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference, typing.Dict[builtins.str, typing.Any]],
    weight: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__67c632b0becb9c79bba61ecfbc570059ecbea112da7847bb2e85fafed527b0b4(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_fields: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c8bba19691eef4fe04b976862d70cf9286fd400f66cbb75a1bbc36ec1307f548(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17ce6b4ca22f0732a72196cd678d291197212b16f005c8aa2f40709a1a296980(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d3daeac4fbf2c77cf223aad1483b2f0c7b039ae2879d04428cecca37312860ee(
    *,
    node_selector_terms: typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eebf5fa09c1d6515e17b55681c10ac7af9b185398f26515ab31ce84956fc782a(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_fields: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b71c8fca97cf32ccffe4bee872ebdb151872f7407ac0ab01c760ff68d8d5a3c9(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e2109e48c4e35740a563e4d634894a210aec88aa3fa11feb3782fbf66e8b946(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__770b9cae483b068dd658c393f9fda9eec646118479117ea31c83b90a8a1b7afa(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f570b94e4651013c7429fbf6f83f4657638d552f87e6957d93b944a49a657bdb(
    *,
    pod_affinity_term: typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm, typing.Dict[builtins.str, typing.Any]],
    weight: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__337c0e937692229cc452a0811b0ae2e48d3fef58d8c073f01ca63ec43d9cbadb(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e70680078810df8710ec769a369901e5e0a043064e2722dbe492a2ccbad5591f(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a478e4cb9e1f8a5b4cb181e35d5dcafb3167a6b9d7a3f16ae5ee66d5939d72ae(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba68be71f7cef1afdb63d699ee545de522dceae354901e85d16a7508fddcde2a(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b8c1b13e4bb69f0d3f7b9147f8693505cc43c2b749cda54d058918c6a8d7b84(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0cd68ebb7582795497068a0edc1d89f6b23edc034c8884663407b6c598e48205(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89fcbac0be98710fa0c3f781c16c055b257bd693d8634ef837ebdeb6e1e95625(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89be4f03c001ab0482380abb7f039851f9fab7eafc3e8ba5c4527bbc283df5e0(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83799ea4463e2670a760452a981931cc89a5b0a5fcb4d5e350eaec2cf6185fd3(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7144207226f5a38152eedda15aaf4c28de4fa2729ff1d3190a30aafe86c60603(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f02a0c283445d718912f837ac3954a8a966d4078af1db24959268248206cdc60(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__78ef0c9f2a1966bb53502b4ea71f99488e276142557cd3155d878cd285055a0a(
    *,
    pod_affinity_term: typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm, typing.Dict[builtins.str, typing.Any]],
    weight: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5ef970f8ad3e2f56fba1dcfa005212c4e0df48f898fa68ce72b3eb7210bdb0d3(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e0a509c934a90a81037c11bdbd8ca13dd05f4d2560184496d80313177ba60574(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2bfe7cadf921a874d8551b11c295c6e1d9035b49bfd5e54497d1985cf269d25b(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d88840345bf5db559bc4af67bf5163dfc832a4563a8634c9b0e0db1be0dd1fc8(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b26a159425ef812abe43e3fa8cfc6782e66fc017171fdbd9727261e9d0b2bb1(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac82888f0deddbab109280901a8560fdf93f5f101b6e9d94ffeb1a1b6c58f4ea(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca6914256214683d6f199cb251317bf30f6f3ee7d0e9c81952dfa1d3f2580940(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__db0277363bea6e7223ec8a00ded448916d2821ea4fa63a78ff2267f6a8ce5d7b(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70c6e83e10f8a9dded493f32ed0b17edc045fd208cf557d57db7d00385940a2b(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6848113fe16fc047aaa2031d880ff52c39d86601eb136569426588e46a96a29(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f622a233e53fa8f1cc049cd22298edf3d6f14f8d777762bb784142de294b496d(
    *,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aa7f661a14acca333c27d1c3e4ea87e43099b300a285ad8669ccf3ae445f7a1a(
    *,
    fs_group: typing.Optional[jsii.Number] = None,
    fs_group_change_policy: typing.Optional[builtins.str] = None,
    run_as_group: typing.Optional[jsii.Number] = None,
    run_as_non_root: typing.Optional[builtins.bool] = None,
    run_as_user: typing.Optional[jsii.Number] = None,
    seccomp_profile: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeccompProfile, typing.Dict[builtins.str, typing.Any]]] = None,
    se_linux_options: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSeLinuxOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
    sysctls: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01GatewayHttpRoutePodTemplateSpecSecurityContextSysctls, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__428282459b1965936e325d87d613511ccd46bc7fd6b4be416e2e9383bfe042e2(
    *,
    level: typing.Optional[builtins.str] = None,
    role: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    user: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64d4c232613257f7aa3d850797d74e26bc06d264f03bd88be4d46c7a6e2e63b8(
    *,
    type: builtins.str,
    localhost_profile: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__703b1bbc01eab508106a514983ca9aa86fceda87af19f075116936a4e5b4c3bf(
    *,
    name: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__417cd8c23c9d09b13441d7b1aef943afd9a77adbb0292592f9560ac7d71f880b(
    *,
    effect: typing.Optional[builtins.str] = None,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    toleration_seconds: typing.Optional[jsii.Number] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__182b4c45bace3813bc89a9a939c8dca360a8d6df22b0013c80b17b19440ea692(
    *,
    class_: typing.Optional[builtins.str] = None,
    ingress_class_name: typing.Optional[builtins.str] = None,
    ingress_template: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressIngressTemplate, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    pod_template: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplate, typing.Dict[builtins.str, typing.Any]]] = None,
    service_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af88e7045a3b2900d709e578c968ec044124b57238357736fa199737ed700056(
    *,
    metadata: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressIngressTemplateMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__53a2aa199ea989321aebcfca1554c8922219f1643d0b2bb8846e4863ede34090(
    *,
    annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2ed11b300b44553042c29d41779b68baaba8140f1368ef365dd4d915e6242c02(
    *,
    metadata: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__07a20343ae372cc52cc2654e7589cb639afc30e74e9e2e96e78c45bfc218998e(
    *,
    annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e7494033d29f3e7c2a26c25fde35b8f69d6e95f180dcd0d2e40746eb4459a23(
    *,
    affinity: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
    image_pull_secrets: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecImagePullSecrets, typing.Dict[builtins.str, typing.Any]]]] = None,
    node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    priority_class_name: typing.Optional[builtins.str] = None,
    security_context: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContext, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_name: typing.Optional[builtins.str] = None,
    tolerations: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecTolerations, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f373764257fad5085fd13f16b8a5ca49bbd3ba63bf49feec8e805d874f0d5886(
    *,
    node_affinity: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_affinity: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_anti_affinity: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e558ef371869e227c8d2968108286f0ca10af4a3bcb8c32a3f0c55ab68811df(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__21d0d7a71502a15ac78a58ecb57e8f93ad8847ef1b733a3fc9d060895da8e5e1(
    *,
    preference: typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference, typing.Dict[builtins.str, typing.Any]],
    weight: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91bcced19c9adfee8d9ab534a628f882416135b729640fb0c0a94f8b9233c993(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_fields: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8cb04223888829deda9db21c362cdbb3000a5831958711b672980c868071c85(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cd0adb78fb91460b8b1b202921cf7ac2d64bc32344ad22e94a660ec0c490511f(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bf3550ded68b07665172bde4539b09fb9811d16d296e113ae6e34f72d1a53070(
    *,
    node_selector_terms: typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1d62a4b59b0c98cdc7e15d31f5e0aaddfb96d486346d8aabbd9739104709545(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_fields: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__917b5a9cc550a3b32d25d2639532640e9ccd79ada5a59244d0ba0b373a1b83f0(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8cc1b076cdcd4b53834911de769e1c08cf11a7f0c28b6c98ebbfe7f14a9f6f7f(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c646ac8a99006633a52c6f1843c12b33f75c20184cffd729343d4274aeef86ec(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ec3e548c456db0de962bb299e938a66ee4e2a22d85df0fbd77bcdf430ccfb1e(
    *,
    pod_affinity_term: typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm, typing.Dict[builtins.str, typing.Any]],
    weight: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__132790204a16b9feb4c3ba16221361b24d5d1d0e413240b1e762df405c598b17(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__92984c59a1d7649f76370a9645310b8435730cf21521381819702d0b45748bff(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__969365c3fbe238006f5b61efea5d55a3267947cfff6d34e9a7694a49026d48fc(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8817c747dd0fd5ceb9ff7ffd7e365f75123165d94ff054657abec742289b3276(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83e6ca235e7b4c96dc8fb540a92d823d3875c38bd53998477e53b8142455d4ab(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95cafe3316c15ba0cd9f611787bbff976072dc23e74362c176426d2d7c7d7ba0(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2128e2b5a9a912f000afacb2a176703d278cafdd39ba8f9b69f53b2e26b4f38c(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c681c3bd5261df52e4481eb18304eed22e35e340823f526a11139f098deefbbb(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__065476f80b2c1b81306fd17aeac8ef3bdd71f1c115733c4471367285abe6eac4(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd80193fbe7aa13853ab1c6103293ca3c83919da4f51b5a8b393edabeeade96d(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5ceaac555e75ba9a1320b345a819d12c2835b44b0311a4a814097c06b7ffa7e1(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b6c9bdb241451a0f8dc3dca127ea8d7f135e07204610d401bddbf4a75b3d17d(
    *,
    pod_affinity_term: typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm, typing.Dict[builtins.str, typing.Any]],
    weight: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__77e53cf9b0b1c16dfb8204ec6549caf33e8ecf6da78f377d4377639ee28b9833(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ef54cb842e44125885b07c9d5071f34742d3f60910d75f80c08a76508205e76(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70630e7bc657e14b01835c04db29ce66ab74ead622195ddf46b58e928a4dc846(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd4e5ce8bfcc6aa03e7661b8c97ea38a0a00aa988a3e6fa7ae0e97c2b7225c10(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d0af4d9781b21726299684216d4a38d835d5926821e37186bad1dbdcbdd3adf(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe4a21fdc86a23101744f25b753063eb501b50fcf8a3721c311c2a5a56bdfc56(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    match_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    mismatch_label_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8861490e35c26e63bc1fa5fd63fc1d5f3acb41a5b64d043e56fd9b8787a7c514(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86548093d03b6d100f55fe8f70c737219143572d4b074586940658301f513b6d(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37e6ce7a01b4b3609950862108aaf31985b77f250549f7068a7e400b127d4b68(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2823dadc3279d67057f627473b0d026214756265ad1a26169a8d9a21dabd1ff5(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b88a290e5d2800c0064d5c988836c4c3e1307735eb46475e69e587918bcdf48(
    *,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4afeefb66683568b2a1a6709e07a78a90ba48a4fdba567be2c9c0c33e414e67(
    *,
    fs_group: typing.Optional[jsii.Number] = None,
    fs_group_change_policy: typing.Optional[builtins.str] = None,
    run_as_group: typing.Optional[jsii.Number] = None,
    run_as_non_root: typing.Optional[builtins.bool] = None,
    run_as_user: typing.Optional[jsii.Number] = None,
    seccomp_profile: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeccompProfile, typing.Dict[builtins.str, typing.Any]]] = None,
    se_linux_options: typing.Optional[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
    sysctls: typing.Optional[typing.Sequence[typing.Union[IssuerSpecAcmeSolversHttp01IngressPodTemplateSpecSecurityContextSysctls, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dff03fc0e2ec84e8f285fb3f5c994cab65416888aa531f7db56f16fb075f2d2b(
    *,
    level: typing.Optional[builtins.str] = None,
    role: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
    user: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba325ddab20e1f1f5c73e964cb7c326716fe446e259ad1cabbcce0237e2c41d3(
    *,
    type: builtins.str,
    localhost_profile: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f441232ea07187ceda138922957d701a1a1315fc3c9031918f56a9b48fa13624(
    *,
    name: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e92b618030a3e35314381c9428a66bf55a0fbde7a47342af86c4c8babf506d93(
    *,
    effect: typing.Optional[builtins.str] = None,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    toleration_seconds: typing.Optional[jsii.Number] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad3008cf977de3efd0f98199a41ff11453fc3a3cafccd06d925d94ab2744b5fa(
    *,
    dns_names: typing.Optional[typing.Sequence[builtins.str]] = None,
    dns_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__466b89ab20e391ba331d51cad076c0d1a7f2b3658d4b2ae9f8b7aa10229fc92f(
    *,
    secret_name: builtins.str,
    crl_distribution_points: typing.Optional[typing.Sequence[builtins.str]] = None,
    issuing_certificate_ur_ls: typing.Optional[typing.Sequence[builtins.str]] = None,
    ocsp_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e1f1b2ede1230831b3cbdc9bafdf7d0e443628e37f980daf2277c2798a6e71e(
    *,
    crl_distribution_points: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a39a5efadd872548b56058d6e676861d5981980d82342c2562d4f6ae56fb908f(
    *,
    auth: typing.Union[IssuerSpecVaultAuth, typing.Dict[builtins.str, typing.Any]],
    path: builtins.str,
    server: builtins.str,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_bundle_secret_ref: typing.Optional[typing.Union[IssuerSpecVaultCaBundleSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    client_cert_secret_ref: typing.Optional[typing.Union[IssuerSpecVaultClientCertSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    client_key_secret_ref: typing.Optional[typing.Union[IssuerSpecVaultClientKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd96325df56196378aca00e9c0250307bd090ca706e6200b62641b7443884662(
    *,
    app_role: typing.Optional[typing.Union[IssuerSpecVaultAuthAppRole, typing.Dict[builtins.str, typing.Any]]] = None,
    client_certificate: typing.Optional[typing.Union[IssuerSpecVaultAuthClientCertificate, typing.Dict[builtins.str, typing.Any]]] = None,
    kubernetes: typing.Optional[typing.Union[IssuerSpecVaultAuthKubernetes, typing.Dict[builtins.str, typing.Any]]] = None,
    token_secret_ref: typing.Optional[typing.Union[IssuerSpecVaultAuthTokenSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f9e3b8b938ff4994ca79d22c0ed228070d3ba12398b3a681dad866b777a535f(
    *,
    path: builtins.str,
    role_id: builtins.str,
    secret_ref: typing.Union[IssuerSpecVaultAuthAppRoleSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d39cee765742baef80216bd5b29bf24b4d1cb35a54fbb95214603c2f2c78aa7(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd7c45120497fd59d49f6f2d5fe5481cc3a656d63f564360f2691147bc4d7b0a(
    *,
    mount_path: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    secret_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d6221a3681154bdb8df032c8ef071f72c1865736ca28bfd04df576935a7ae86f(
    *,
    role: builtins.str,
    mount_path: typing.Optional[builtins.str] = None,
    secret_ref: typing.Optional[typing.Union[IssuerSpecVaultAuthKubernetesSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_ref: typing.Optional[typing.Union[IssuerSpecVaultAuthKubernetesServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd69c31b677638ae6bda333d1772e1e2d2555f59bf4c2e0dccdf006ffb4012da(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9308e54fac39d2501bd327ba2e44db85ecfa3c29efd8d344d8ceca2f9f1a339d(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__191033eb4e56092b96ce87eb804a68718b9f21932a9b8feb31764fbb08fe17ec(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e4a0a2db2538b6a85c85a979a09f9645254646f9b3554cd43d0970373cede76e(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd02dec17c46aeeaebbc4ec59705c6b76f6d93cd830d5a9cf862d05faaa3ae97(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29ccf4df99f1f6844cd22c8c05988541ab11c4d19222662f6be4bf32d1723b3c(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41471c5806506574d816a45163907eed7153e50656bf0ea754813c1550ae7be4(
    *,
    zone: builtins.str,
    cloud: typing.Optional[typing.Union[IssuerSpecVenafiCloud, typing.Dict[builtins.str, typing.Any]]] = None,
    tpp: typing.Optional[typing.Union[IssuerSpecVenafiTpp, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0f6e000b7abffa99f37db8834819dcd3bb8248961720598110b6d36081ca388(
    *,
    api_token_secret_ref: typing.Union[IssuerSpecVenafiCloudApiTokenSecretRef, typing.Dict[builtins.str, typing.Any]],
    url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0ecd39f00f0c94da3d96bdb331d210453bb31d98424723feb4cef5b8cfde7884(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__34eaf3d8d15be8301d9607c483a2dd9958ce79d1af180e51bd695220d72cc7cc(
    *,
    credentials_ref: typing.Union[IssuerSpecVenafiTppCredentialsRef, typing.Dict[builtins.str, typing.Any]],
    url: builtins.str,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_bundle_secret_ref: typing.Optional[typing.Union[IssuerSpecVenafiTppCaBundleSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac5433d9f83a8070e92ab6f524f5a848262fbab0127f670c864c4581e9eaf1e6(
    *,
    name: builtins.str,
    key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aa86795723230eb90c20ee071c8aa5a47c64b4b2b45ff84e5070eb3c6383dafb(
    *,
    name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass
